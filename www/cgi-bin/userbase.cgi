#!/usr/bin/perl
#
# userbase.cgi - trial version
#
######################################################################
#
# NOTE: this text file is the trial version of UserBase.
# Save it to your computer then upload it to your server and
# name it "userbase.cgi".  See full instructions here:
#
#	http://encodable.com/userbase/#instructions
# 
######################################################################
#
# NOTE: do not spend too much time customizing this trial version,
# because the full version replaces it completely.
# 
######################################################################
#
# DO NOT EDIT THIS FILE unless absolutely necessary; in most cases you
# should be editing userbase_prefs.cgi instead.  If you do edit this
# file, be sure to make a backup copy first.
# 
######################################################################
#
# This program is the copyrighted work of Encodable Industries.
# Redistribution is prohibited, and copies are permitted only for
# backup purposes.  You are free to modify the program for your
# own use, but you may not distribute any modified copies of it.
#
# Use of this program requires a one-time license fee.  You can
# obtain a license here:
#
#	http://encodable.com/userbase/
#
# This software comes with no warranty.  It is our hope that you
# find it useful, but it comes with no guarantees.  Under no
# circumstances shall Encodable Industries be held liable in any
# situation arising from your use of this program.
#
# For more information about this program, as well as for help
# and support, please visit the following pages:
#
# Homepage: http://encodable.com/userbase/
# Contact:  http://encodable.com/contact/


my $version = "2.26t-e05";
$ENV{PATH} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
($ENV{DOCUMENT_ROOT}) = ($ENV{DOCUMENT_ROOT} =~ /(.*)/); # untaint.
#$ENV{SCRIPT_NAME} = '/cgi-bin/userbase.cgi';
use lib './perlmodules';
use lib "$ENV{DOCUMENT_ROOT}/cgi-bin/perlmodules";
use lib "$ENV{DOCUMENT_ROOT}/../cgi-bin/perlmodules";
my (%PREF,%TEXT) = ();
use CGI::Carp 'fatalsToBrowser';

my $debuglog = undef; #open($debuglog, ">>encdata/userbase/debuglog.ubtemp.log") or die_nice("couldn't open debuglog: $!\n"); flock $debuglog, 2; print $debuglog "\n\n";

use strict;
use DBI;
use Time::Local;
use Digest::MD5 'md5_hex';

sub printd;
sub die_nice;
sub enc_warn;
sub exit_with_error;

my $qs = '';





sub create_new_session_id
{
	my $username = shift;
	my $password = shift;
	my $id = offsettime() . $$ . $ENV{REMOTE_ADDR} . $ENV{HTTP_USER_AGENT} . $username . $password;

	#$id =~ s/[^\d]//g;
	#$id = substr($id,0,85);
	$id = enc_hash($id);
	return $id;
}


sub check_for_multiple_logins($)
{
	my ($userid) = @_;
	die_unless_numeric($userid,'userid');
	my $old_login_time = enc_sql_select("SELECT `loggedin` FROM `$PREF{user_table}` WHERE `id` = $userid;");
	if($old_login_time =~ /[1-9]/   &&   !login_session_expired($old_login_time))
	{
		if($PREF{prevent_multiple_simultaneous_logons_per_username} =~ /yes/i)
		{
			my $go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?phase=emultlogin";
			enc_redirect($go);
		}
		else
		{
			my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `numusers`=IFNULL(`numusers`,0)+1 WHERE `id` = '$userid';");
			die_nice("Error: check_for_multiple_logins('$userid'): SQL returned '$success' instead of '1' while incrementing numusers column.") unless $success == 1;

			my $existing_session_id = enc_sql_select("SELECT `mrsession` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
			return $existing_session_id;
		}
	}
}


sub log_user_into_db
{
	my ($userid, $my_session_id, $logintime, $restrict_ip) = @_;

	die_unless_numeric($userid,'userid');
	die_unless_numeric($logintime,'logintime');

	check_sessionid_for_sql_safeness($my_session_id);

	my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `loggedin` = $logintime, `mrsession` = '$my_session_id' WHERE `id` = '$userid';");
	die_nice("Error: log_user_into_db('$userid', '$my_session_id', '$logintime', '$restrict_ip'): SQL returned '$success' instead of '1' while logging user in.") unless $success == 1;

	if($restrict_ip)
	{
		my $ip = $ENV{REMOTE_ADDR};
		check_ip_for_sql_safeness($ip);

		unless(enc_sql_select("SELECT `ip` FROM `$PREF{user_table}` WHERE `id` = '$userid'") eq $ip)
		{
			my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `ip` = '$ip' WHERE `id` = '$userid';");
			die_nice("Error: log_user_into_db('$userid', '$my_session_id', '$logintime', '$restrict_ip'): SQL returned '$success' instead of '1' while setting user IP.") unless $success == 1;
		}
	}
	else
	{
		unless(enc_sql_select("SELECT `ip` FROM `$PREF{user_table}` WHERE `id` = '$userid'") eq '')
		{
			my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `ip` = '' WHERE `id` = '$userid';");
			die_nice("Error: log_user_into_db('$userid', '$my_session_id', '$logintime', '$restrict_ip'): SQL returned '$success' instead of '1' while clearing user IP.") unless $success == 1;
		}
	}
}


sub log_user_out_of_db
{
	my ($username, $my_session_id) = @_;

	check_username_for_sql_safeness($username);
	check_sessionid_for_sql_safeness($my_session_id) unless $my_session_id eq 'force';

	# It's possible (and probably not particularly uncommon) that a user logs in at one location, then leaves
	# that location and his session goes idle, and then he logs in at another location with the same account.  In
	# that case, a call to log_user_out_of_db() from the first location should not actually do the db logout, 
	# because the session does not belong to him anymore.  But note that this is not an error condition, so we
	# should just silently return.
	#
	my $session_id_in_db = enc_sql_select("SELECT `mrsession` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");

	if($my_session_id == $session_id_in_db   ||   $my_session_id eq 'force')
	{
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `loggedin` = 0 WHERE `username` = '$username';");
		die_nice("Error: log_user_out_of_db('$username', '$my_session_id'): SQL returned '$success' instead of '1' while setting loggedin to zero.") unless $success == 1;

		$success = enc_sql_update("UPDATE `$PREF{user_table}` SET `mrsession` = '' WHERE `username` = '$username';");
		die_nice("Error: log_user_out_of_db('$username', '$my_session_id'): SQL returned '$success' instead of '1' while setting mrsession to null.") unless $success == 1;

		my $numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `username` = '$username';");
		if($numusers) # this check only required because of crappy old MySQL versions that fail to ever set numusers properly in the DB (??).
		{
			$success = enc_sql_update("UPDATE `$PREF{user_table}` SET `numusers` = 0 WHERE `username` = '$username';");
			die_nice("Error: log_user_out_of_db('$username', '$my_session_id'): SQL returned '$success' instead of '1' while setting numusers to zero.") unless $success == 1;
		}
	}
}


sub update_logins_table($$)
{
	my ($userid, $session_id) = @_;
	my $timestamp = offsettime();

	check_id_for_sql_safeness($userid);
	check_sessionid_for_sql_safeness($session_id);
	die_unless_numeric($timestamp, 'timestamp');

	my ($ip, $host, $ua) = ($PREF{ip}, $PREF{host}, $ENV{HTTP_USER_AGENT});
	sql_untaint($ip, $host, $ua);
	die_unless_sqlsafe($ip, $host, $ua);

	enc_sql_insert("INSERT INTO `$PREF{logins_table}` (`user_id`, `session_id`, `timestamp`, `ip_address`, `hostname`, `browser`) VALUES('$userid', '$session_id', '$timestamp', '$ip', '$host', '$ua')");

	while(enc_sql_select("SELECT COUNT(*) FROM `$PREF{logins_table}` WHERE `user_id` = $userid") > $PREF{num_logins_to_log_per_user})
	{
		my $oldest = enc_sql_select("SELECT MIN(`timestamp`) FROM `$PREF{logins_table}` WHERE `user_id` = $userid");
		enc_sql_delete("DELETE FROM `$PREF{logins_table}` WHERE `timestamp` = $oldest AND `user_id` = $userid LIMIT 1");
	}
}


sub update_failed_logins_table($$)
{
	my ($input_username, $input_password) = @_;

	my $hashed_password = enc_hash($input_password);
	check_hashedpw_for_sql_safeness($hashed_password);

	my $timestamp = offsettime();
	die_unless_numeric($timestamp, 'timestamp');

	my ($ip, $host, $ua) = ($PREF{ip}, $PREF{host}, $ENV{HTTP_USER_AGENT});
	sql_untaint($input_username, $ip, $host, $ua);
	die_unless_sqlsafe($input_username, $ip, $host, $ua);

	enc_sql_insert("INSERT INTO `$PREF{failed_logins_table}` (`username`, `password_fingerprint`, `timestamp`, `ip_address`, `hostname`, `browser`) VALUES('$input_username', '$hashed_password', '$timestamp', '$ip', '$host', '$ua')");

	while(enc_sql_select("SELECT COUNT(*) FROM `$PREF{failed_logins_table}` WHERE `username` = '$input_username'") > $PREF{num_failed_logins_to_log_per_user})
	{
		my $oldest = enc_sql_select("SELECT MIN(`timestamp`) FROM `$PREF{failed_logins_table}` WHERE `username` = '$input_username'");
		enc_sql_delete("DELETE FROM `$PREF{failed_logins_table}` WHERE `timestamp` = $oldest AND `username` = '$input_username' LIMIT 1");
	}
}


sub update_password_activity_table
{
	my ($user_id,$hashed_password,$salt,$id_of_user_performing_update) = @_;

	# $id_of_user_performing_update is zero if the update is during the
	# initial account creation, or if it's due to a password reset.

	die_unless_numeric($user_id, 'user_id');
	die_unless_numeric($id_of_user_performing_update, 'id_of_user_performing_update');
	check_hashedpw_for_sql_safeness($hashed_password);
	check_salt_for_sql_safeness($salt);

	my $timestamp = offsettime();
	die_unless_numeric($timestamp, 'timestamp');

	my ($ip, $host, $ua) = ($PREF{ip}, $PREF{host}, $ENV{HTTP_USER_AGENT});
	sql_untaint($ip, $host, $ua);
	die_unless_sqlsafe($ip, $host, $ua);

	enc_sql_insert("INSERT INTO `$PREF{password_activity_table}` (`user_id`, `password_fingerprint`, `salt`, `timestamp`, `user_who_did_update`, `ip_address`, `hostname`, `browser`) VALUES('$user_id', '$hashed_password', '$salt', '$timestamp', '$id_of_user_performing_update', '$ip', '$host', '$ua')");

	while(enc_sql_select("SELECT COUNT(*) FROM `$PREF{password_activity_table}` WHERE `user_id` = '$user_id'") > $PREF{num_pw_updates_to_log_per_user})
	{
		my $oldest = enc_sql_select("SELECT MIN(`timestamp`) FROM `$PREF{password_activity_table}` WHERE `user_id` = '$user_id'");
		enc_sql_delete("DELETE FROM `$PREF{password_activity_table}` WHERE `timestamp` = $oldest AND `user_id` = '$user_id' LIMIT 1");
	}
}


sub make_sure_new_password_is_not_a_repeat
{
	my ($user_id,$new_password) = @_;

	my $limit = $PREF{prevent_pw_reuse_for_this_many_pw_changes};
	if($limit =~ /^\d+$/ && $limit > 0)
	{
		die_unless_numeric($user_id, 'user_id');
		my $old_passwords = enc_sql_select_multi("SELECT `password_fingerprint`,`salt` FROM `$PREF{password_activity_table}` WHERE `user_id` = '$user_id' ORDER BY `timestamp` DESC LIMIT $limit");
		foreach my $i (keys %$old_passwords)
		{
			exit_with_error($TEXT{password_reuse_error}) if salt_and_crypt_password($new_password,$$old_passwords{$i}{salt}) eq $$old_passwords{$i}{password_fingerprint};
		}
	}
}


sub determine_default_login_destination
{
	my $ref = shift;
	my $go = ();
	if($qs =~ /(?:^|&)whence=(.+)/)
	{
		# don't URL-decode here because this is getting passed right
		# to the Location: header, which requires URL encoding.

		$go = $1;
		if($qs =~ /(?:^|&)encanchor=([^&]+)(?:&|$)/)
		{
			$go .= '#' . $1;
		}
	}
	elsif($ref)
	{
		$go = $ref;

		if($go =~ m!.*whence=(https?(://|%3a%2f%2f).+)!i)
		{
			$go = $1;
			enc_urldecode($go);
		}

		if($go =~ /log(ged)?out/   ||   $go =~ /(action=verify|action=pwreset|action=confirmpayment|phase=\w+)/   ||   $go !~ m!^https?://(www\.)?$ENV{HTTP_HOST}!)
		{
			# If the page we were on before was a logout page, or if it was an external
			# site, or if it was one of various other internal pages that don't make
			# sense to redirect to, then just return to the login frontpage.
			#
			$go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";
		}
	}
	else
	{
		$go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";
	}
	return $go;
}


sub prompt_for_login()
{
	$PREF{on_page} = 'loginform';
	printd "prompt_for_login()";

	# don't urldecode here, because it's just going right back onto the URL.
	my $whence = $qs =~ /(?:^|&)whence=(.+)/ ? "&whence=$1" : undef;
	if($qs =~ /(?:^|&)encanchor=([^&]+)(?:&|$)/)
	{
		$whence = "&encanchor=$1" . $whence;
	}

	my $rememberme_checkbox = $PREF{enable_rememberme_checkbox} =~ /yes/i && !$PREF{idle_timeout};
	my $restrictip_checkbox = $PREF{enable_ip_address_restriction} =~ /yes/i && $PREF{force_ip_address_restriction} !~ /yes/;

	my $message = '';
	if($qs =~ /(?:^|&)phasemsg=(.+?)(?:&|$)/) { $message = $1; enc_urldecode($message); $message = qq`<div id="formmessage">$message</div>\n`; }

	my $template = $qs =~ /format=mini/ ? $PREF{login_form_template__mini} : $PREF{login_form_template};
	$template =~ s/%%whence%%/$whence/g;
	$template =~ s!%%special_message%%!$message!g;
	$template =~ s!%%%if-rememberme%%%(.+)%%%end-rememberme%%%!$rememberme_checkbox ? $1 : ''!egs;
	$template =~ s!%%%if-restrictip%%%(.+)%%%end-restrictip%%%!$restrictip_checkbox ? $1 : ''!egs;
	$template = interpolate_userbase_variables($template);

	print_http_headers();
	start_html_output() unless $qs =~ /format=mini/;
	print $template unless $qs =~ /null_if_logged_out/;
	finish_html_output() unless $qs =~ /format=mini/;
}


sub user_has_addmember_rights
{
	return user_is_allowed_to($PREF{logged_in_userid}, 'create_user_accounts') || logged_in_user_is_subgroup_manager();
}


sub user_has_addadmin_rights
{
	return user_is_allowed_to($PREF{logged_in_userid}, 'create_admin_accounts');
}


sub print_user_form
{
	my $mode = shift;
	my %vars = ();

	if($mode eq 'added_by_admin')
	{
		$PREF{on_page}			= 'adminadduser';
		$vars{title}			= $PREF{user_form_title___admin_adding_user};

		if(!user_has_addmember_rights()) { exit_with_error($TEXT{Access_denied_}); }
	
		$vars{target}			= 'action=commitadduser';
		$vars{forcepwchng}		= 1 if $PREF{enable_forced_password_change} =~ /yes/i;
	}
	elsif($mode eq 'user_signup')
	{
		$PREF{on_page}			= 'usersignup';
		$vars{title}			= $PREF{user_form_title___user_signing_up};

		unless($PREF{visitors_can_sign_up_for_their_own_accounts} =~ /yes/i) { exit_with_error($TEXT{This_feature_is_disabled_}); }
	
		$vars{target}			= 'action=commitadduser';
		$vars{forcepwchng}		= 0;
	}
	else # edit the user info instead.
	{
		exit_with_needlogin() unless $PREF{member_is_logged_in};

		$PREF{on_page} = 'edituser';
		$vars{title}			= $PREF{user_form_title___editing_account};

		$vars{user_id}			= $qs =~ /(?:^|&)id=(\d+)(?:&|$)/ ? $1 : $PREF{logged_in_userid};
		die_unless_numeric($vars{user_id}, 'userid (from print_user_form())');

		$vars{username}			= get_user_name($vars{user_id});

		if(!user_is_allowed_to($PREF{logged_in_userid}, 'edit_user_info', $vars{username})) { exit_with_error($TEXT{Access_denied_}); }

		$vars{target}			= "action=commitedituser";

		$vars{username_readonly}	= $PREF{usernames_are_immutable_once_created} =~ /no/i && user_is_allowed_to($PREF{logged_in_userid}, 'change_usernames', $vars{username}) ? '' : qq`readonly="readonly"`;

		$vars{realname}			= get_real_name($vars{user_id});
		$vars{email}			= get_email_address($vars{user_id});

		$vars{account_locked}		= enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `id` = '$vars{user_id}';");
		$vars{account_disabled}		= enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = '$vars{user_id}';");
		$vars{forcepwchng}		= enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$vars{user_id}';") if $PREF{enable_forced_password_change} =~ /yes/i;
	}

	if($qs =~ /redo=true/)
	{
		while($qs =~ /(?:^|&)redo_(\w+)=([^&]*)/g)
		{
			my ($field,$value) = ($1,$2);
			enc_urldecode($value);
			$vars{$field} = $value if $value;
		}
	}

	start_html_output($vars{title});

	if($qs =~ /(?:^|&)phase=(\w+?)(?:&|$)/) { my $phase = $1; print qq`<div id="formmessage">` . get_message($phase) . qq`</div>\n`; }

	my $template = $PREF{user_form_template};


	my $grouplist = '';
	my ($grouplist_template) = ($template =~ m!%%%template:grouplist%%%(.+?)%%%end-template:grouplist%%%!gs);
	my $groups = get_groups_hash($vars{user_id});
	foreach my $group (sort keys %$groups)
	{
		next if ($group =~ /^$PREF{admin_group_name}$/i && !user_has_addadmin_rights());
		next if ($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i); # don't show these (not even disabled); it just confuses people.

		my $checked = $$groups{$group}{is_member} ? qq`checked="checked"` : undef;

		my $user_allowed_to_see_all_groups = user_is_allowed_to('see_full_grouplist_on_user_form');
		my $user_belongs_to_this_group = $$groups{$group}{is_member};
		die_unless_numeric($$groups{$group}{id}, 'group ID ($$groups{$group}{id})');
		my ($this_group_always_shown_on_signup,$group_label) = enc_sql_select("SELECT `show_on_signup_page`,`label_for_signup_page` FROM `$PREF{group_table}` WHERE `id` = $$groups{$group}{id};");

		my $disabled = user_is_allowed_to('change_group_memberships') || ($mode eq 'user_signup' && $this_group_always_shown_on_signup) ? '' : 'disabled="disabled"';

		# By default, admins can see all groups here, but non-admins can only see the groups they belong to.
		if($user_allowed_to_see_all_groups || $user_belongs_to_this_group || $this_group_always_shown_on_signup)
		{
			my $gl_template = $grouplist_template;
			$gl_template =~ s!%%group%%!$group!gs;
			$gl_template =~ s!%%group_label%%!$mode eq 'user_signup' && $this_group_always_shown_on_signup && $group_label ? $group_label : $group!egs;
			$gl_template =~ s!%%checked%%!$checked!gs;
			$gl_template =~ s!%%disabled%%!$disabled!gs;
			$grouplist .= $gl_template;
		}
	}
	$template =~ s!%%%template:grouplist%%%(.+?)%%%end-template:grouplist%%%!$grouplist!gs;


	my $customfields = '';
	my ($customfields_template) = ($template =~ m!%%%template:customfields%%%(.+?)%%%end-template:customfields%%%!gs);
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_table}`"))
	{
		my ($id,$fieldname,$fieldlabel,$datatype,$fieldtype,$fieldmax,$fieldposition,$mandatory,$limitallowedchars,$allowedchars,$allowedcharsmsg,$listitems,$enabled) = ();
		my $sth = $PREF{dbh}->prepare("SELECT id,fieldname,fieldlabel,datatype,fieldtype,fieldmax,fieldposition,mandatory,limitallowedchars,allowedchars,allowedcharsmsg,listitems,enabled FROM `$PREF{custom_field_table}` ORDER BY `fieldposition`");
		$sth->execute() or die_nice("$PREF{internal_appname}: Error: print_user_form(): $DBI::errstr\n");
		$sth->bind_columns(\$id,\$fieldname,\$fieldlabel,\$datatype,\$fieldtype,\$fieldmax,\$fieldposition,\$mandatory,\$limitallowedchars,\$allowedchars,\$allowedcharsmsg,\$listitems,\$enabled);
		while($sth->fetchrow_arrayref)
		{
			next unless ($enabled && db_column_exists($fieldname, $PREF{user_table}));

			my $value = enc_sql_select("SELECT `$fieldname` FROM `$PREF{user_table}` WHERE `id` = $vars{user_id}") if $vars{user_id};

			my $required = $mandatory ? 'required' : '';

			$fieldmax = '' unless $datatype eq 'varchar'; # workaround for SQL bug where '' gets stored as '0'.

			my $cf_template = $customfields_template;


			$cf_template =~ s!%%fieldname%%!$fieldname!gs;
			$cf_template =~ s!%%fieldlabel%%!$fieldlabel!gs;
			$cf_template =~ s!%%fieldmax%%!$fieldmax!gs;
			$cf_template =~ s!%%required%%!$required!gs;
			$cf_template =~ s!%%value%%!$value!gs;

			$cf_template =~ s!%%%if-freeformsingle%%%(.*?)%%%end-freeformsingle%%%!$fieldtype eq 'freeformsingle' ? $1 : ''!egs;
			$cf_template =~ s!%%%if-freeformmulti%%%(.*?)%%%end-freeformmulti%%%!$fieldtype eq 'freeformmulti' ? $1 : ''!egs;
			$cf_template =~ s!%%%if-dropdown%%%(.*?)%%%end-dropdown%%%!$fieldtype eq 'dropdown' ? $1 : ''!egs;
			$cf_template =~ s!%%%if-checkbox%%%(.*?)%%%end-checkbox%%%!$fieldtype eq 'checkbox' ? $1 : ''!egs;
			$cf_template =~ s!%%%if-radio%%%(.*?)%%%end-radio%%%!$fieldtype eq 'radio' ? $1 : ''!egs;


			if($fieldtype eq 'checkbox')
			{
				$cf_template =~ s!%%checkbox_checked%%!$value ? 'checked="checked"' : ''!egs;
			}


			my $dropdown = '';
			if($fieldtype eq 'dropdown')
			{
				my ($dropdown_template) = ($cf_template =~ m!%%%template:dropdown%%%(.+?)%%%end-template:dropdown%%%!gs);
				foreach my $option (split(/\n/, $listitems))
				{
					my $dd_template = $dropdown_template;
					my $selected = $option eq $value ? qq`selected="selected"` : '';
					$dd_template =~ s!%%dropdown_selected%%!$selected!gs;
					$dd_template =~ s!%%option%%!$option!gs;
					$dropdown .= $dd_template;
				}
			}
			$cf_template =~ s!%%%template:dropdown%%%(.+?)%%%end-template:dropdown%%%!$dropdown!gs;


			my $radio = '';
			if($fieldtype eq 'radio')
			{
				my $radio_i = 0;
				my ($radio_template) = ($cf_template =~ m!%%%template:radio%%%(.+?)%%%end-template:radio%%%!gs);
				foreach my $selection (split(/\n/, $listitems))
				{
					$radio_i++;
					my $rad_template = $radio_template;
					my $checked = $selection eq $value ? qq`checked="checked"` : '';
					$rad_template =~ s!%%radio_checked%%!$checked!gs;
					$rad_template =~ s!%%selection%%!$selection!gs;
					$rad_template =~ s!%%radio_i%%!$radio_i!gs;
					$radio .= $rad_template;
				}
			}
			$cf_template =~ s!%%%template:radio%%%(.+?)%%%end-template:radio%%%!$radio!gs;


			$customfields .= $cf_template;
		}
	}
	$template =~ s!%%%template:customfields%%%(.+?)%%%end-template:customfields%%%!$customfields!gs;


	$template =~ s!%%post_url%%!$ENV{SCRIPT_NAME}?$vars{target}!g;
	$template =~ s!%%hidden_signup_input%%!$mode eq 'user_signup' ? qq`<input type="hidden" name="user_signup" value="yes" />` : ''!eg;
	$template =~ s!%%emailformat%%!$PREF{usernames_must_be_email_addresses} =~ /yes/i ? 'emailformat' : ''!eg;
	$template =~ s!%%email_field_required%%!$PREF{email_field_required} =~ /yes/i ? 'required emailformat' : ''!eg;
	$template =~ s!%%new_password_required%%!$mode =~ /added_by_admin|user_signup/ ? 'required' : ''!eg;
	$template =~ s!%%account_locked_checked%%!$vars{account_locked} ? 'checked="checked"' : ''!eg;
	$template =~ s!%%account_disabled_checked%%!$vars{account_disabled} ? 'checked="checked"' : ''!eg;
	$template =~ s!%%forcepwchng_checked%%!$vars{forcepwchng} ? 'checked="checked"' : ''!eg;
	$template =~ s!%%paidacct(\d+)name%%!$PREF{"paid_account_type_${1}_groupname"}!g;
	$template =~ s!%%paidacct(\d+)desc%%!$PREF{"paid_account_type_${1}_groupdesc"}!g;
	$template =~ s!%%paidacct(\d+)cost%%!$PREF{"paid_account_type_${1}_cost"}!g;

	$template =~ s!%%%if-forcepwchng%%%(.*?)%%%end-forcepwchng%%%!force_pw_change($PREF{logged_in_userid}) ? $1 : ''!egs;
	$template =~ s!%%%if-use_builtin_realname_field%%%(.*?)%%%end-use_builtin_realname_field%%%!my $var = $1; $PREF{use_builtin_realname_field} =~ /yes/i ? $var : ''!egs;
	$template =~ s!%%%if-use_builtin_email_field%%%(.*?)%%%end-use_builtin_email_field%%%!my $var = $1; $PREF{use_builtin_email_field} =~ /yes/i ? $var : ''!egs;
	$template =~ s!%%%if-currentpass_needed%%%(.*?)%%%end-currentpass_needed%%%!$mode eq 'edit'   &&   logged_in_user_must_enter_current_password_to_change_password_for_user($vars{user_id}) ? $1 : ''!egs;
	$template =~ s!%%%if-show_account_locks%%%(.*?)%%%end-show_account_locks%%%!$mode eq 'edit'   &&   user_is_allowed_to($PREF{logged_in_userid}, 'manage_account_locks') ? $1 : ''!egs;
	$template =~ s!%%%ifelse-lock_expires_automatically%%%(.*?)%%%else%%%(.*?)%%%endelse-lock_expires_automatically%%%!my ($var1,$var2)=($1,$2); $PREF{lock_expires_automatically} =~ /yes/i ? $var1 : $var2!egs;
	$template =~ s!%%%if-lock_expires_automatically%%%(.*?)%%%end-lock_expires_automatically%%%!my $var = $1; $PREF{lock_expires_automatically} =~ /yes/i ? $var : ''!egs;
	$template =~ s!%%%if-show_force_pwchng%%%(.*?)%%%end-show_force_pwchng%%%!my $var = $1; user_is_allowed_to($PREF{logged_in_userid}, 'force_password_changes')   &&   $PREF{enable_forced_password_change} =~ /yes/i ? $var : ''!egs;
	$template =~ s!%%%if-show_terms_of_service%%%(.*?)%%%end-show_terms_of_service%%%!my $var = $1; $mode eq 'user_signup' && $PREF{user_must_agree_to_terms_on_signup} =~ /yes/i ? $var : ''!egs;
	$template =~ s!%%%if-show_grouplist%%%(.*?)%%%end-show_grouplist%%%!$grouplist ? $1 : ''!egs;
	$template =~ s!%%%if-show_customfields%%%(.*?)%%%end-show_customfields%%%!$customfields ? $1 : ''!egs;
	$template =~ s!%%%if-show_payment_options%%%(.*?)%%%end-show_payment_options%%%!my $var = $1; $mode eq 'user_signup' && $PREF{enable_paid_accounts} =~ /yes/i ? $var : ''!egs;

	$template =~ s!%%%if-user_signing_up%%%(.*?)%%%end-user_signing_up%%%!$mode eq 'user_signup' ? $1 : ''!egs;
	$template =~ s!%%%if-admin_adding_user%%%(.*?)%%%end-admin_adding_user%%%!$mode eq 'added_by_admin' ? $1 : ''!egs;
	$template =~ s!%%%ifelse-editing_account%%%(.*?)%%%else%%%(.*?)%%%endelse-editing_account%%%!$mode eq 'edit' ? $1 : $2!egs;
	$template =~ s!%%%if-editing_account%%%(.*?)%%%end-editing_account%%%!$mode eq 'edit' ? $1 : ''!egs;

	$template =~ s!%PREF{(.+?)}!$PREF{$1}!g;

	$template =~ s!%%(\w+)%%!$vars{$1}!g;
	$template =~ s!%%%if-(\w+)%%%(.*?)%%%end-\1%%%!!gs;

	print $template;

	finish_html_output();
}


sub logged_in_user_must_enter_current_password_to_change_password_for_user($)
{
	my $userid_of_target_user = shift;

	#
	#my $username_of_target_user = shift;
	#if(this_user_is_the_logged_in_admin($username_of_target_user))
	#{
	#	# an admin is trying to change his own password, so
	#	# we DO require the current password.
	#	return 1;
	#}
	#
	# Admin or not, if the account being updated is the logged-in user's account,
	# then he must enter the current password to change the password:
	#
	if($userid_of_target_user == $PREF{logged_in_userid})
	{
		# A user is changing his own password, so the current password is required.
		return 1;
	}
	elsif(logged_in_user_is_subgroup_manager()   &&   logged_in_subgroup_manager_owns_this_user($userid_of_target_user))
	{
		# a subgroup manager is trying to change the password of one of his
		# own users; he's effectively an admin for this purpose, so we DON'T
		# require the current password.
		return 0;
	}
	elsif(user_is_allowed_to($PREF{logged_in_userid}, 'edit_user_info', $userid_of_target_user))
	{
		# in general, a user with 'edit_user_info' rights does NOT need
		# the current password to change a password.
		return 0;
	}
	else
	{
		# in general, a user without 'edit_user_info' rights DOES need
		# the current password to change a password.
		return 1;
	}
}


sub print_group_form
{
	my $mode = shift;
	my %vars = ();

	if($mode eq 'add')
	{
		my $go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";
		if(!user_is_allowed_to($PREF{logged_in_userid}, 'create_groups')) { enc_redirect("$go?phase=eneedlogin"); }
	
		$vars{title}			= 'Add New Group';
		$vars{button_label}		= 'Add Group';
		$vars{target}			= 'action=commitaddgroup';
	}
	else # edit the group info instead.
	{
		$vars{group_id}			= shift;
		$vars{group}			= get_group_name($vars{group_id});

		my $go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";
		if(!user_is_allowed_to($PREF{logged_in_userid}, 'edit_group_info')) { enc_redirect("$go?phase=eneedlogin"); }

		$vars{title}			= 'Edit Group';
		$vars{button_label}		= 'Modify Group';
		$vars{target}			= "action=commiteditgroup";

		$vars{groupname_readonly}	= $PREF{groupnames_are_immutable_once_created} =~ /no/i && user_is_allowed_to($PREF{logged_in_userid}, 'change_groupnames') ? undef : qq`readonly="readonly"`;
		$vars{groupdesc}		= get_group_desc($vars{group_id});
	}


	start_html_output("$vars{title}");

my $i = 0;
print qq`
<form method="post" action="$ENV{SCRIPT_NAME}?$vars{target}" class="group">

<table class="groupform">
	<tr class="header"><th colspan="2">$vars{title}</th></tr>

	<tr class="` . oddeven($i) . qq`">
	<td class="label">Group:</td>
	<td><input type="text" name="group" class="default" maxlength="$PREF{max_groupname_length}" value="$vars{group}" $vars{groupname_readonly} /></td>
	</tr>

	<tr class="` . oddeven($i) . qq`">
	<td class="label">Description:</td>
	<td><textarea name="groupdesc" class="default" maxlength="$PREF{max_group_description_length}" />$vars{groupdesc}</textarea></td>
`;


	print	  qq`\n`
		. qq`\t<tr class="` . oddeven($i) . qq`">\n\t<td colspan="2" class="ubbutton"><input type="hidden" name="groupid" value="$vars{group_id}" />`
		. qq`<input type="submit" value="$vars{button_label}" class="defaultbutton" />`
		. qq`</td>\n\t</tr>`
		. qq`\n</table>`
		. qq`\n</form>`
		. qq`\n`;


	finish_html_output();
}






sub process_new_account()
{
	use CGI ':param';
	my $go			= "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";

	my $user		= my $user_redo		= param('username');	enc_urlencode($user_redo);
	my $realname		= my $realname_redo	= param('realname');	enc_urlencode($realname_redo);
	my $email		= my $email_redo	= param('email');	enc_urlencode($email_redo);
	my $pass		= param('pw1'); # don't redo/refill the password because we don't want to pass that on the URL.

	my $salt		= create_random_salt($PREF{salt_length});
	my $crypted_pass	= salt_and_crypt_password($pass,$salt);
	my $signup		= param('user_signup') =~ /yes/i;

	$PREF{prev_page} = $signup ? 'signup' : 'adduser';

	my $redo = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=$PREF{prev_page}&redo=true";
	$redo .= "&redo_username=$user_redo&redo_realname=$realname_redo&redo_email=$email_redo";

	   if(!user_has_addmember_rights() && !$signup)						{ enc_redirect("$redo&phase=eneedlogin");	}
	elsif($PREF{visitors_can_sign_up_for_their_own_accounts} !~ /yes/i && $signup)		{ enc_redirect("$redo&phase=enosignup");	}
	elsif(!realname_is_valid($realname) && $realname)					{ enc_redirect("$redo&phase=einvldr");		}
	elsif(!emailaddr_is_valid($email) && $email)						{ enc_redirect("$redo&phase=einvlde");		}
	elsif(!emailaddr_is_valid($user) && $PREF{usernames_must_be_email_addresses} =~ /yes/i)	{ enc_redirect("$redo&phase=einvlde");		}
	elsif(!password_is_valid($pass))							{ enc_redirect("$redo&phase=einvldp");		}
	elsif(!hashedpw_is_valid($crypted_pass))						{ enc_redirect("$redo&phase=einvldh");		}
	elsif(!username_is_valid($user))							{ enc_redirect("$redo&phase=ebadname");		}
	elsif( username_is_taken($user))							{ enc_redirect("$redo&phase=edupuser");		}
	elsif( $email && email_address_is_taken($email))					{ enc_redirect("$redo&phase=edupemail");	}
	elsif( param('group-admin') =~ /on/i   &&   !user_has_addadmin_rights())		{ enc_redirect("$redo&phase=einsuff");		}
	elsif( param('pw1') ne param('pw2'))							{ enc_redirect("$redo&phase=epwmismatch");	}

	my $customfields_sqlsafe = get_sqlsafe_custom_field_values();

	my $pending_email_verification	= $signup && $PREF{require_email_verification_for_new_signups} =~ /yes/i ? 1 : 0;
	my $pending_admin_approval	= $signup && $PREF{require_admin_approval_for_new_signups} =~ /yes/i ? 1 : 0;
	my $pending_payment		= $signup && $PREF{enable_paid_accounts} =~ /yes/i && param('paidacct') =~ /^0*[123456789]\d*$/ ? 1 : 0;

	my $token = '';
	if($pending_email_verification || $pending_admin_approval)
	{
		$token = enc_hash($email . $realname . $user . $pass . $salt . offsettime() . $$ . $ENV{REMOTE_ADDR} . $ENV{HTTP_USER_AGENT});
		$token =~ s/[^\w]/X/g;
	}

	my $new_user_id = add_new_user($user, $crypted_pass, $salt, $realname, $email, $pending_email_verification, $pending_admin_approval, $pending_payment, $token);

	my $query = new CGI;
	my %params = $query->Vars;

	foreach my $param (sort keys %params)
	{
		if($param =~ /^group-(.+)$/)
		{
			my $group = $1;
			next if ($group =~ /^$PREF{admin_group_name}$/i && !user_has_addadmin_rights());
			next if ($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i); # every account is automatically a member of these groups.

			my $group_id = get_group_id($group);
			die_unless_numeric($group_id, '$group_id');
			my $user_belongs_to_this_group = user_is_member_of_group($PREF{logged_in_userid}, $group);
			my $user_has_groupmod_rights = user_is_allowed_to($PREF{logged_in_userid}, 'change_group_memberships');
			my ($this_group_always_shown_on_signup) = enc_sql_select("SELECT `show_on_signup_page` FROM `$PREF{group_table}` WHERE `id` = $group_id;");

			if($user_has_groupmod_rights || $user_belongs_to_this_group || ($signup && $this_group_always_shown_on_signup))
			{
				add_user_to_group($user, $group) if $params{$param} =~ /on/i;
			}
		}
	}



	# When a subgroup manager creates an account, it's automatically
	# put into a special group based on the manager's username.
	#
	if(logged_in_user_is_subgroup_manager())
	{
		my $groupname = "$PREF{logged_in_username}$PREF{subgroup_groupname_suffix}";
		add_new_group($groupname, "Group managed by $PREF{logged_in_username}") unless group_exists($groupname);
		add_user_to_group($user, $groupname);
	}

	my $payment_url = '';
	if($PREF{enable_paid_accounts} =~ /yes/i)
	{
		my $paid_acct_type = param('paidacct');
		if($paid_acct_type =~ /^0*[123456789]\d*$/)
		{
			$payment_url = "$PREF{login_url}?action=startpayment&type=$paid_acct_type&uid=$new_user_id";
		}
	}

	my $table = $PREF{user_table};

	foreach my $customfield (keys %$customfields_sqlsafe)
	{
		die_unless_numeric($new_user_id, "userid");
		my $value = $$customfields_sqlsafe{$customfield};
		unless($value eq enc_sql_select("SELECT `$customfield` FROM `$table` WHERE `id` = $new_user_id"))
		{
			my $statement = "UPDATE `$table` SET `$customfield` = '$value' WHERE `id` = $new_user_id";
			my $success = enc_sql_update($statement);
			die_nice("Error: process_new_account(): SQL returned '$success' instead of '1' while updating custom field '$customfield' to value '$value'.  SQL was: [[$statement]]") unless $success == 1;
		}
	}

	if(param('forcepwchng') =~ /on/i || $PREF{force_pw_chng_after_first_login} =~ /yes/i)
	{
		my $statement = "UPDATE `$table` SET `forcepwchng` = 1 WHERE `id` = $new_user_id;";
		my $success = enc_sql_update($statement);
		die_nice("Error: process_new_account(id='$new_user_id'): SQL returned '$success' instead of '1' while enabling forcepwchng.  SQL was: [[$statement]]") unless $success == 1;
	}

	if($pending_email_verification)
	{
		$PREF{verification_email_template} =~ s/%%link%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=verify&u=$new_user_id&t=$token/g;

		my $user_email = $PREF{usernames_must_be_email_addresses} =~ /yes/i ? $user : $email;

		send_email(	$user_email,
				$PREF{login_script_email_address},
				$PREF{verification_email_subject},
				$PREF{verification_email_template},
				($PREF{verification_email_format} || $PREF{global_email_format}),
				'die_on_email_error'
		);

		#enc_redirect($payment_url ? $payment_url : "$go?phase=sactvrf&one=$user");
		$TEXT{messages}{sactvrf} =~ s!%%username%%!$user!g;
		kmsg_redirect($TEXT{messages}{sactvrf});
	}
	elsif($pending_admin_approval)
	{
		send_email_requesting_admin_approval_of_new_acct($user,$new_user_id);

		#enc_urlencode($user);
		#enc_redirect($payment_url ? $payment_url : "$go?phase=sactapp&one=$user");
		$TEXT{messages}{sactapp} =~ s!%%username%%!$user!g;
		kmsg_redirect($TEXT{messages}{sactapp});
	}
	else
	{
		create_filechucker_userdir($user);
		if($signup) { add_user_to_group($user,$_) for (split(/\s*,\s*/, $PREF{automatically_add_new_signups_to_these_groups})); }
		notify_admin_of_new_signup($new_user_id) if $signup;

		send_welcome_email($new_user_id,$user,$pass,$email,$realname) unless $signup;
		#enc_urlencode($user);
		if($payment_url)
		{
			enc_redirect($payment_url);
		}
		else
		{
			$TEXT{messages}{snewadd} =~ s!%%username%%!$user!g;
			kmsg_redirect($TEXT{messages}{snewadd});
		}
	}
}


sub process_new_group()
{
	use CGI ':param';
	my $go			= $PREF{login_url};
	my $group		= param('group');
	my $groupdesc		= param('groupdesc');

	   if(!user_is_allowed_to($PREF{logged_in_userid}, 'create_groups'))		{ enc_redirect("$go?phase=eneedlogin");		}
	elsif(!groupname_is_valid($group))						{ enc_redirect("$go?phase=einvldgn");		}
	elsif(!groupdesc_is_valid($groupdesc) && $groupdesc)				{ enc_redirect("$go?phase=einvldgd");		}
	elsif(group_exists($group))							{ enc_redirect("$go?phase=egrpexist");		}
	elsif($group =~ /^(self)$/i)							{ enc_redirect("$go?phase=egrprsvd");		}

	add_new_group($group, $groupdesc);

	#enc_redirect("$go?phase=snewgrp&one=$group");
	kmsg_redirect(qq`New group '$group' added successfully.`);
}


sub get_sqlsafe_custom_field_values()
{
	my %customfields_sqlsafe = ();
	my $go = $PREF{login_url};

	my $custom_field_list_table = $PREF{custom_field_table};
	my $table_to_modify = $PREF{user_table};

	if(enc_sql_select("SELECT COUNT(*) FROM `$custom_field_list_table`"))
	{
		my ($id,$fieldname,$fieldlabel,$datatype,$fieldtype,$fieldmax,$fieldposition,$mandatory,$limitallowedchars,$allowedchars,$allowedcharsmsg,$listitems,$enabled) = ();
		my $sth = $PREF{dbh}->prepare("SELECT id,fieldname,fieldlabel,datatype,fieldtype,fieldmax,fieldposition,mandatory,limitallowedchars,allowedchars,allowedcharsmsg,listitems,enabled FROM `$custom_field_list_table` ORDER BY `fieldposition`");
		$sth->execute() or die_nice("$PREF{internal_appname}: Error: process_new_account(): $DBI::errstr\n");
		$sth->bind_columns(\$id,\$fieldname,\$fieldlabel,\$datatype,\$fieldtype,\$fieldmax,\$fieldposition,\$mandatory,\$limitallowedchars,\$allowedchars,\$allowedcharsmsg,\$listitems,\$enabled);
		while($sth->fetchrow_arrayref)
		{
			next unless ($enabled && db_column_exists($fieldname, $table_to_modify));

			sql_un_untaint($allowedchars);

			my $value = param($fieldname);

			$value =~ s/\r\n/\n/g; # fix browser newlines.

			#
			# Do custom-field sanity checking:
			#

			if(($datatype eq 'bool' || $fieldtype eq 'checkbox')   &&   ($value =~ /^on$/i)) { $value = 1; } # convert checkbox string value to a bool.

			if($datatype eq 'int'   &&   $value =~ /[^\d-]/)						{ $TEXT{Entry_not_int}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_int}	=~ s/%%value%%/$value/g; kmsg_redirect($TEXT{Entry_not_int}); }
			if($datatype eq 'uint'   &&   $value =~ /[^\d]/)						{ $TEXT{Entry_not_uint}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_uint}	=~ s/%%value%%/$value/g; kmsg_redirect($TEXT{Entry_not_uint}); }
			if($datatype eq 'float'   &&   $value =~ /[^\d\.-]/)						{ $TEXT{Entry_not_float}	=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_float}	=~ s/%%value%%/$value/g; kmsg_redirect($TEXT{Entry_not_float}); }
			if($datatype eq 'ufloat'   &&   $value =~ /[^\d\.]/)						{ $TEXT{Entry_not_ufloat}	=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_ufloat}	=~ s/%%value%%/$value/g; kmsg_redirect($TEXT{Entry_not_ufloat}); }

			if(($datatype eq 'bool' || $fieldtype eq 'checkbox')   &&   !($value =~ /^on$/i || !$value))	{ $TEXT{Entry_not_bool}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_bool}	=~ s/%%value%%/$value/g; kmsg_redirect($TEXT{Entry_not_bool}); }

			if($fieldtype =~ /^(dropdown|radio)$/)
			{
				my %allowable_values = map { $_ => 1 } split(/\n/, $listitems);
				unless($allowable_values{$value})							{ $TEXT{Entry_invalid}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_invalid}	=~ s/%%value%%/$value/g; kmsg_redirect($TEXT{Entry_invalid}); }
			}

			if($fieldmax =~ /^\d+$/   &&   $fieldmax > 0   &&   length($value) > $fieldmax)
			{
				$TEXT{e_toolong} =~ s/%%item%%/$fieldname/g;
				$TEXT{e_toolong} =~ s/%%limit%%/$fieldmax/g;
				$TEXT{e_toolong} =~ s/%%length%%/length($value)/eg;
				kmsg_redirect($TEXT{e_toolong});
			}

			if($mandatory   &&   !$value) { $TEXT{e_mandatory} =~ s/%%item%%/$fieldname/g; kmsg_redirect($TEXT{e_mandatory}); }

			if($limitallowedchars)
			{
				# Escape any dashes or closing brackets, as per perlre:
				#
				# 	If you want either "-" or "]" itself to be a member of a class,
				#	put it at the start of the list (possibly after a "^"), or escape
				#	it with a backslash.
				#
				$allowedchars =~ s/\]/\\]/g;
				$allowedchars =~ s/-/\\-/g;

				if($value =~ /[^$allowedchars]/)
				{
					die_unless_numeric($id, "ID");
					my ($fieldname,$msg) = enc_sql_select("SELECT `fieldname`,`allowedcharsmsg` FROM `$custom_field_list_table` WHERE `id` = $id");
					$msg =~ s!%%fieldname%%!$fieldname!g;
					kmsg_redirect($msg);
				}
			}

			#
			# Do SQL sanity checking:
			#

			sql_untaint($value);
			if(not_sqlsafe($value)) { $TEXT{e_sqlsafe} =~ s/%%fieldname%%/$fieldname/g; kmsg_redirect($TEXT{e_sqlsafe}); }

			#
			# If we got this far, the value is valid.
			#

			$customfields_sqlsafe{$fieldname} = $value;
		}
	}

	return \%customfields_sqlsafe;
}


sub this_user_is_the_logged_in_admin($)
{
	my $username = shift;
	return $PREF{admin_is_logged_in} && lc($PREF{logged_in_username}) eq lc($username);
}


sub do_email_verification($$)
{
	my $uid = shift;
	my $email_verification_token = shift;

	my $username = get_user_name($uid);
	check_username_for_sql_safeness($username);
	die_nice("Invalid token '$email_verification_token'.") unless $email_verification_token =~ /^\w+$/;

	enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_email_verification` = 0, `completed_email_verification` = 1 WHERE `id` = $uid AND `email_verification_token` = '$email_verification_token' AND `pending_email_verification` = 1") == 1 or die_nice("$PREF{internal_appname}: Error: do_email_verification(): SQL returned something other than 1 while trying to set pending_email_verification to 0.");

	if($PREF{require_admin_approval_for_new_signups} =~ /yes/i)
	{
		start_html_output("Email Address Verified");
		print $PREF{email_verified_pending_template};
		send_email_requesting_admin_approval_of_new_acct($username,$uid);
		finish_html_output();
	}
	else
	{
		create_filechucker_userdir($username);
		add_user_to_group($username,$_) for (split(/\s*,\s*/, $PREF{automatically_add_new_signups_to_these_groups})); # The fact that we're doing email verification means that it was a signup.
		notify_admin_of_new_signup($uid);

		start_html_output("Email Address Verified");
		$PREF{email_verified_active_template} =~ s/%%login_url%%/$PREF{login_url}/g;
		print $PREF{email_verified_active_template};
		finish_html_output();
	}
}


sub send_email_requesting_admin_approval_of_new_acct($$)
{
	my $username = shift;
	my $uid = shift;

	my $username_urlencoded = $username;
	enc_urlencode($username_urlencoded);

	$PREF{admin_approval_email_subject} =~ s/%%username%%/$username/g;
	$PREF{admin_approval_email_template} =~ s/%%username%%/$username/g;
	$PREF{admin_approval_email_template} =~ s/%%approval_url%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=approve_or_del&uid=$uid/g;

	send_email(	$PREF{webmaster_email_address},
			$PREF{login_script_email_address},
			$PREF{admin_approval_email_subject},
			$PREF{admin_approval_email_template},
			($PREF{admin_approval_email_format} || $PREF{global_email_format}),
			'die_on_email_error'
	);
}


sub approve_or_delete_pending_account($)
{
	exit_with_error($TEXT{Access_denied_}) unless user_has_addmember_rights();

	my $uid = shift;
	my $username = get_user_name($uid);

	check_username_for_sql_safeness($username);

	my ($password,$salt,$name,$email,$cdate) = enc_sql_select("SELECT `password`,`salt`,`name`,`email`,`cdate` FROM `$PREF{user_table}` WHERE `id` = $uid");
	die_nice("Error: no matching account found for that user ID.") unless $password && $salt && $cdate;

	start_html_output("Approve or Delete Pending Account");

	print	  qq``
		. qq`\n<p><b>Username:</b> $username`
		. (   $PREF{usernames_must_be_email_addresses} =~ /yes/i
			? (   qq` (email address ` . (account_has_completed_email_verification($uid) ? 'verified' : 'not verified') . qq`)`   )
			: ''
		   )
		. qq`</p>`
		. ($PREF{use_builtin_realname_field} =~ /yes/i ? qq`\n<p><b>Real Name:</b> $name</p>` : '')
		. ($PREF{use_builtin_email_field} =~ /yes/i ? qq`\n<p><b>Email Address:</b> $email (` . (account_has_completed_email_verification($uid) ? 'verified' : 'not verified') . qq`)</p>` : '')
		. ($PREF{enable_paid_accounts} =~ /yes/i ? qq`\n<p><b>Payment Pending:</b> ` . (account_is_pending_payment($uid) ? 'yes' : 'no') . qq`</p>` : '')
		. ($PREF{enable_paid_accounts} =~ /yes/i ? qq`\n<p><b>Payment Completed:</b> ` . (account_has_completed_payment($uid) ? 'yes' : 'no') . qq`</p>` : '')
		. qq`\n<p><b>Creation Date:</b> ` . strftime("%Y%m%d-%H:%M",localtime($cdate)) . qq`</p>`
		. qq`\n<p><br /></p>`;


	if(my @custom_field_names = get_custom_userbase_field_names($PREF{user_table}))
	{
		my @custom_field_values = enc_sql_select("SELECT " . (join ',', @custom_field_names) . " FROM `$PREF{user_table}` WHERE `id` = $uid");
		my $i = 0;
		for(@custom_field_names)
		{
			print qq`\n<p><b>$custom_field_names[$i]:</b> $custom_field_values[$i]</p>`;
			$i++;
		}
		print qq`\n<p><br /></p>`;
	}

	print	  qq`\n<p style="font-weight: bold;"><a href="$PREF{login_url}?action=approve_pending_acct&amp;uid=$uid">Approve and activate pending account '$username'</a></p>`
		. qq`\n<p style="font-weight: bold;"><a href="$PREF{login_url}?action=delete_pending_acct&amp;uid=$uid">Delete pending account '$username'</a></p>`
		. qq`\n<p></p>`
		. qq`\n`;

	finish_html_output();
}


sub approve_or_delete_pending_account_stage2($$)
{
	exit_with_error($TEXT{Access_denied_}) unless user_has_addmember_rights();

	my $uid = shift;
	my $decision = shift;
	my $username = get_user_name($uid);

	if($decision eq 'approve')
	{
		if(account_is_pending_admin_approval($uid))
		{
			enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_admin_approval` = 0 WHERE `id` = $uid") == 1 or die_nice("$PREF{internal_appname}: Error: approve_or_delete_pending_account_stage2(): SQL returned something other than 1 while trying to set pending_admin_approval to 0.");
		}
		if(1 != enc_sql_select("SELECT `completed_admin_approval` FROM `$PREF{user_table}` WHERE `id` = $uid"))
		{
			enc_sql_update("UPDATE `$PREF{user_table}` SET `completed_admin_approval` = 1 WHERE `id` = $uid") == 1 or die_nice("$PREF{internal_appname}: Error: approve_or_delete_pending_account_stage2(): SQL returned something other than 1 while trying to set completed_admin_approval to 1.");
		}

		# Also disable the other pending flags here (pending_email_verification,
		# pending_payment) so that the admin has the ability to override those
		# if he wants/needs to, to manually approve the account.  Of course, we
		# won't set completed_email_verification in this case, nor will we add
		# the account to any of the paid groups.
		#
		if(account_is_pending_email_verification($uid))
		{
			enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_email_verification` = 0 WHERE `id` = $uid") == 1 or die_nice("$PREF{internal_appname}: Error: approve_or_delete_pending_account_stage2(): SQL returned something other than 1 while trying to set pending_email_verification to 0.");
		}
		if(account_is_pending_payment($uid))
		{
			enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_payment` = 0 WHERE `id` = $uid") == 1 or die_nice("$PREF{internal_appname}: Error: approve_or_delete_pending_account_stage2(): SQL returned something other than 1 while trying to set pending_payment to 0.");
		}

		create_filechucker_userdir($username);
		add_user_to_group($username,$_) for (split(/\s*,\s*/, $PREF{automatically_add_new_signups_to_these_groups})); # The fact that the account is pending means that it was a signup.
		notify_admin_of_new_signup($uid);

		$PREF{account_activated_email_subject} =~ s/%%username%%/$username/g;
		$PREF{account_activated_email_template} =~ s/%%username%%/$username/g;

		my $user_email = $PREF{usernames_must_be_email_addresses} =~ /yes/i ? $username : get_email_address($uid);

		send_email(	$user_email,
				$PREF{login_script_email_address},
				$PREF{account_activated_email_subject},
				$PREF{account_activated_email_template},
				($PREF{account_activated_email_format} || $PREF{global_email_format}),
				'die_on_email_error'
		);

		start_html_output("Pending Account Approved and Activated");
		print qq`<p>The <a href="$PREF{login_url}?action=edituser&amp;id=$uid">'$username' account</a> has been approved and is now active.</p>\n`;
		finish_html_output();
	}
	else
	{
		my $sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{user_table}` WHERE `id` = $uid");
		$sth->execute == 1 or die_nice("$PREF{internal_appname}: approve_or_delete_pending_account_stage2(): SQL returned something other than 1 while deleting account from users table.");

		start_html_output("Pending Account Deleted");
		print qq`<p>The '$username' account has been deleted.&nbsp; <a href="$PREF{login_url}?action=showusers">Manage users</a> again?</p>\n`;
		finish_html_output();
	}
}


sub notify_admin_of_new_signup($)
{
	my $new_user_id = shift;
	return unless $PREF{notify_admin_of_new_signups} =~ /yes/i;

	die_unless_numeric($new_user_id, 'new_user_id');
	my ($username,$name,$email) = enc_sql_select("SELECT `username`,`name`,`email` FROM `$PREF{user_table}` WHERE `id` = '$new_user_id'");
	sql_un_untaint($name);

	my $username_template = my $name_template = my $email_template = $PREF{admin_notification_email_field_template};

	$username_template	=~ s/%%fieldname%%/$PREF{username_label}/g;
	$name_template		=~ s/%%fieldname%%/$PREF{name_label}/g;
	$email_template		=~ s/%%fieldname%%/$PREF{email_label}/g;

	$username_template	=~ s/%%fieldvalue%%/$username/g;
	$name_template		=~ s/%%fieldvalue%%/$name/g;
	$email_template		=~ s/%%fieldvalue%%/$email/g;

	my $user_info_fields = $username_template;
	$user_info_fields .= $name_template if $PREF{use_builtin_realname_field} =~ /yes/i;
	$user_info_fields .= $email_template if $PREF{use_builtin_email_field} =~ /yes/i;

	if(my @custom_field_names = get_custom_userbase_field_names($PREF{user_table}))
	{
		my @custom_field_values = enc_sql_select("SELECT " . (join ',', @custom_field_names) . " FROM `$PREF{user_table}` WHERE `id` = '$new_user_id'");
		my $i = 0;
		for(@custom_field_names)
		{
			my $template = $PREF{admin_notification_email_field_template};
			$template =~ s/%%fieldname%%/$custom_field_names[$i]/g;
			$template =~ s/%%fieldvalue%%/$custom_field_values[$i]/g;
			$user_info_fields .= $template;
			$i++;
		}
	}

	$PREF{admin_notification_email_subject} =~ s/%%username%%/$username/g;
	$PREF{admin_notification_email_subject} =~ s/%%name%%/$name/g;
	$PREF{admin_notification_email_subject} =~ s/%%email%%/$email/g;
	$PREF{admin_notification_email_template} =~ s/%%user_info_fields%%/$user_info_fields/g;

	send_email(	$PREF{webmaster_email_address},
			$PREF{login_script_email_address},
			$PREF{admin_notification_email_subject},
			$PREF{admin_notification_email_template},
			($PREF{admin_notification_email_format} || $PREF{global_email_format}),
			'die_on_email_error'
	);
}


sub send_welcome_email($$$$$)
{
	my ($new_user_id, $username, $password, $email, $name) = @_;
	return unless $PREF{send_welcome_email_when_admin_creates_an_account} =~ /yes/i;

	for($PREF{welcome_email_subject}, $PREF{welcome_email_template})
	{
		s/%%username%%/$username/g;
		s/%%password%%/$password/g;
		s/%%email%%/$email/g;
		s/%%name%%/$name/g;
	}

	send_email(	$email,
			$PREF{login_script_email_address},
			$PREF{welcome_email_subject},
			$PREF{welcome_email_template},
			($PREF{welcome_email_format} || $PREF{global_email_format}),
			'die_on_email_error'
	);
}


sub edit_user_account()
{
	use CGI ':param';
	my $go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";

	my $userid = param('userid');
	check_uid_for_uniqueness($userid); # checks for sql safeness too.
	my $username_in_db = get_user_name($userid);
	my $username = $username_in_db;

	if(!user_is_allowed_to($PREF{logged_in_userid}, 'edit_user_info', $username_in_db)) { enc_redirect("$go?phase=eneedlogin"); }

	if(!user_is_allowed_to($PREF{logged_in_userid}, 'edit_admin_info', $username_in_db)   &&   is_admin($userid)) { enc_redirect("$go?phase=eneedlogin"); }

	my (@results, $sth) = ();

	my $username_from_form = param('username');
	if($username_from_form ne $username_in_db)
	{
		if(user_is_allowed_to($PREF{logged_in_userid}, 'change_usernames', $username_in_db))
		{
			if(username_is_valid($username_from_form))
			{
				$sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `username` = '$username_from_form' WHERE `id` = $userid");
				$sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', username_from_form='$username_from_form']: $DBI::errstr\n");
				$username = $username_from_form;
				push @results, 101;
			}
			else
			{
				push @results, 102;
			}
		}
	}


	if(param('pw1') =~ /\S/)
	{
		# Note: we don't use password_is_valid() on 'oldpw' here because then a user's password-change
		# will fail if, for example, the admin increases the minimum password length, and the old password
		# was too short.  In that case, we still want the old password to be accepted so that the password
		# can be changed, and the new password will then be checked for validity under the new rules.
		#
		if(   password_is_valid(param('pw1'))   &&   password_is_valid(param('pw2'))   &&   (param('oldpw') =~ /\S/ || !logged_in_user_must_enter_current_password_to_change_password_for_user($userid))   )
		{
			if(param('pw1') eq param('pw2'))
			{
				my $oldsalt = enc_sql_select("SELECT `salt` FROM `$PREF{user_table}` WHERE `id` = $userid;");
				if(!logged_in_user_must_enter_current_password_to_change_password_for_user($userid)   ||   (salt_and_crypt_password(param('oldpw'),$oldsalt) eq get_hashedpw($userid)))
				{
					make_sure_new_password_is_not_a_repeat($userid,param('pw1'));

					my $salt = create_random_salt($PREF{salt_length});
					my $hashed_password = salt_and_crypt_password(param('pw1'),$salt);
					check_hashedpw_for_sql_safeness($hashed_password);

					$sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `password` = '$hashed_password', `salt` = '$salt' WHERE `id` = $userid");
					$sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', hashed_password='$hashed_password']: $DBI::errstr\n");

					update_password_activity_table($userid,$hashed_password,$salt,$PREF{logged_in_userid});

					if($PREF{enable_forced_password_change} =~ /yes/i   &&   enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = $userid;"))
					{
						my $statement = "UPDATE `$PREF{user_table}` SET `forcepwchng` = 0 WHERE `id` = $userid;";
						my $success = enc_sql_update($statement);
						die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while disabling forcepwchng.  SQL was: [[$statement]]") unless $success == 1;
					}

					push @results, 113;
				}
				else
				{
					push @results, 114;
				}
			}
			else
			{
				push @results, 104;
			}
		}
		else
		{
			push @results, 116;
		}
	}


	if($PREF{use_builtin_realname_field} =~ /yes/i)
	{
		my $realname_from_form = param('realname');
		if($realname_from_form ne get_real_name($userid))
		{
			if(realname_is_valid($realname_from_form))
			{
				check_realname_for_sql_safeness($realname_from_form);
				$sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `name` = '$realname_from_form' WHERE `id` = $userid");
				$sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', realname_from_form='$realname_from_form']: $DBI::errstr\n");
				push @results, 105;
			}
			else
			{
				push @results, 106;
			}
		}
	}


	my $emailaddr_from_form = param('email');
	if($emailaddr_from_form ne get_email_address($userid))
	{
		if(emailaddr_is_valid($emailaddr_from_form))
		{
			check_emailaddr_for_sql_safeness($emailaddr_from_form);
			$sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `email` = '$emailaddr_from_form' WHERE `id` = $userid");
			$sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', emailaddr_from_form='$emailaddr_from_form']: $DBI::errstr\n");
			push @results, 107;
		}
		else
		{
			push @results, 108;
		}
	}


	if(user_is_allowed_to($PREF{logged_in_userid}, 'change_group_memberships'))
	{
		my $groups = get_groups_hash($userid);
		foreach my $group (sort keys %$groups)
		{
			next if ($group =~ /^$PREF{admin_group_name}$/i && !user_has_addadmin_rights());
			next if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i;
			if($$groups{$group}{is_member}   &&   param("group-$group") !~ /on/i)
			{
				remove_user_from_group($userid, $group);
				push @results, "109$group";
			}
			elsif(!$$groups{$group}{is_member}   &&   param("group-$group") =~ /on/i)
			{
				add_user_to_group($username, $group);
				push @results, "111$group";
			}
		}
	}


	if(user_is_allowed_to($PREF{logged_in_userid}, 'manage_account_locks'))
	{
		my $account_locked_old = enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
		my $account_locked_new = param("account_locked") =~ /on/i ? 1 : 0;
		if($account_locked_old != $account_locked_new)
		{
			if($account_locked_new)
			{
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = TRUE WHERE `id` = '$userid';");
				die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;
				push @results, 125;
			}
			else
			{
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = FALSE WHERE `id` = '$userid';");
				die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;

				unless(enc_sql_select("SELECT `failed_logins` FROM `$PREF{user_table}` WHERE `id` = '$userid'") eq '')
				{
					$success = enc_sql_update("UPDATE `$PREF{user_table}` SET `failed_logins` = '' WHERE `id` = '$userid';");
					die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating failed_logins.") unless $success == 1;
				}

				push @results, 127;
			}
		}
	}


	if(user_is_allowed_to($PREF{logged_in_userid}, 'manage_account_locks'))
	{
		my $account_disabled_old = enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
		my $account_disabled_new = param("account_disabled") =~ /on/i ? 1 : 0;
		if($account_disabled_old != $account_disabled_new)
		{
			if($account_disabled_new)
			{
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_disabled` = TRUE WHERE `id` = '$userid';");
				die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_disabled.") unless $success == 1;
				push @results, 129;
			}
			else
			{
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_disabled` = FALSE WHERE `id` = '$userid';");
				die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_disabled.") unless $success == 1;
				push @results, 131;
			}
		}
	}


	if(user_is_allowed_to($PREF{logged_in_userid}, 'force_password_changes'))
	{
		if($PREF{enable_forced_password_change} =~ /yes/i)
		{
			my $forcepwchng_old = enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
			my $forcepwchng_new = param("forcepwchng") =~ /on/i ? 1 : 0;
			if($forcepwchng_old != $forcepwchng_new)
			{
				if($forcepwchng_new)
				{
					my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `forcepwchng` = 1 WHERE `id` = '$userid';");
					die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating forcepwchng.") unless $success == 1;
					push @results, 133;
				}
				else
				{
					my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `forcepwchng` = 0 WHERE `id` = '$userid';");
					die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating forcepwchng.") unless $success == 1;
					push @results, 135;
				}
			}
		}
	}


	my $customfields_sqlsafe = get_sqlsafe_custom_field_values();
	foreach my $customfield (keys %$customfields_sqlsafe)
	{
		die_unless_numeric($userid, "userid");
		my $value = $$customfields_sqlsafe{$customfield};
		unless($value eq enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = $userid"))
		{
			my $statement = "UPDATE `$PREF{user_table}` SET `$customfield` = '$value' WHERE `id` = $userid";
			my $success = enc_sql_update($statement);
			die_nice("Error: edit_user_account(): SQL returned '$success' instead of '1' while updating custom field '$customfield' to value '$value'.  SQL was: [[$statement]]") unless $success == 1;
			push @results, "137$customfield";
		}
	}


	enc_redirect("$go?rslt=100&" . join '&', @results);
}


sub edit_group()
{
	use CGI ':param';
	my $go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";

	my $groupid = param('groupid');
	check_gid_for_uniqueness($groupid); # checks for sql safeness too.
	my $groupname_in_db = get_group_name($groupid);

	if(!user_is_allowed_to($PREF{logged_in_userid}, 'edit_group_info')) { enc_redirect("$go?phase=eneedlogin"); }

	my (@results, $sth) = ();

	my $groupname_from_form = param('group');
	if($groupname_from_form ne $groupname_in_db)
	{
		if(user_is_allowed_to($PREF{logged_in_userid}, 'change_groupnames'))
		{
			if(groupname_is_valid($groupname_from_form))
			{
				$sth = $PREF{dbh}->prepare("UPDATE `$PREF{group_table}` SET `group` = '$groupname_from_form' WHERE `id` = $groupid");
				$sth->execute() or die_nice("$0: edit_group() failed: [groupid='$groupid', groupname_from_form='$groupname_from_form']: $DBI::errstr\n");
				push @results, 121;
			}
			else
			{
				push @results, 122;
			}
		}
	}


	my $groupdesc_from_form = param('groupdesc');
	if($groupdesc_from_form ne get_group_desc($groupid))
	{
		if(groupdesc_is_valid($groupdesc_from_form))
		{
			check_groupdesc_for_sql_safeness($groupdesc_from_form);

			$sth = $PREF{dbh}->prepare("UPDATE `$PREF{group_table}` SET `desc` = '$groupdesc_from_form' WHERE `id` = $groupid");
			$sth->execute() or die_nice("$0: edit_group() failed: [groupid='$groupid', groupdesc_from_form='$groupdesc_from_form']: $DBI::errstr\n");
			push @results, 123;
		}
		else
		{
			push @results, 124;
		}
	}

	enc_redirect("$go?rslt=100&" . join '&', @results);
}



sub print_admin_toolbar()
{
	my %status = ();
	my $user_type = ();

	if($PREF{admin_is_logged_in})		{ $user_type = 'Admin'; }
	elsif($PREF{member_is_logged_in})	{ $user_type = 'Member'; }

	if(   ($PREF{member_is_logged_in})   ||   ($qs =~ /^login|action=validate$/)   )
	{
		my $tb = qq`\n<div class="userinfo">\n`;
		$tb .= qq`<div class="userinfoleft">` . ($PREF{member_is_logged_in} ? "$user_type $PREF{logged_in_username} logged in." : "[Not logged in.]" ) . qq`</div>`;
		$tb .= qq`\n<div class="userinforight"><a href="$PREF{login_url}">$PREF{myaccount_footer_link_name}</a></div>`;
		$tb .= qq`\n<div class="clear">&nbsp;</div>`;
		$tb .= qq`\n</div>`;
	}
}


sub get_login_status_string
{
	if($PREF{member_is_logged_in})
	{
		my $status = $PREF{login_status_string_template};

		die_unless_numeric($PREF{logged_in_userid}, 'logged_in_userid');
		my $numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}';");
		my $usertype = $PREF{admin_is_logged_in} ? 'Admin' : 'Member';
		my $extra_info = $numusers > 1 ? ' (multiple locations)' : '';
		$status =~ s/%%usertype%%/$usertype/g;
		$status =~ s/%%username%%/$PREF{logged_in_username}/g;
		$status =~ s/%%extra_info%%/$extra_info/g;

		return $status;
	}
	else { return ''; }
}


sub print_login_logout_link_and_exit()
{
	print_http_headers();
	print get_login_logout_link();
	exit;
}


sub get_login_logout_link()
{
	return $PREF{member_is_logged_in} ? $PREF{login_logout_link_template___logout} : $PREF{login_logout_link_template___login};
}


sub print_title
{
	my $title = shift;
	my @parts = ();
	push (@parts, $PREF{title_for_page_body}) if $PREF{title_for_page_body};
	push (@parts, $title) if $title;
	push (@parts, $ENV{HTTP_HOST}) if $PREF{include_hostname_in_page_body_title} =~ /yes/i;

	$title = join ' - ', @parts;

	$PREF{page_title_template} =~ s/%%title%%/$title/;
	print $PREF{page_title_template} if $PREF{page_title_template};
}


sub email_failed_logins_to_webmaster($$)
{
	return unless $PREF{email_webmaster_on_failed_logins} =~ /yes/i;

	my ($attempted_username, $attempted_password) = ($_[0], $_[1]);

	return unless ($attempted_username   ||   $attempted_password); # because bots seem to trigger this a lot.

	my ($ip, $host) = get_ip_and_host();

	use POSIX; # needed for 'strftime'
	my $shortdatetime	= strftime("%a%b%d,%Y,%I:%M%P",		localtime(time));

my $msg = qq`Sent: $shortdatetime

Someone just attempted to log in at $PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}, but failed.

Their attempted login:
attempted username: $attempted_username
attempted password: $attempted_password

Their information:
IP:   $ip
Host: $host
User Agent: $ENV{HTTP_USER_AGENT}
Referer: $ENV{HTTP_REFERER}

`;


	send_email(	$PREF{webmaster_email_address},
			$PREF{login_script_email_address},
			"Failed login",
			$msg,
			($PREF{failed_login_email_format} || $PREF{global_email_format}),
			'die_on_email_error'
		);

}


sub print_main_menu
{
	$PREF{on_page} = 'mainmenu';

	if($qs =~ /format=mini/)
	{
		my $template = $PREF{mainmenu_template__mini};
		$template = interpolate_userbase_variables($template);
		print_http_headers();
		print $template;
	}
	elsif($PREF{custom_mainmenu_page})
	{
		my $page = $PREF{custom_mainmenu_page};
		$page = "$PREF{DOCROOT}/$page" unless -e $page;
		exit_with_error(qq`Error: the file specified by \$PREF{custom_mainmenu_page} does not exist.  ("$PREF{custom_mainmenu_page}")`) unless -e $page;

		my $pagecontents = '';
		open(my $infh, $page) or die_nice qq`$PREF{internal_appname}: print_main_menu(): couldn't open file "$page" for reading: $!`;
		flock $infh, 1;
		seek $infh, 0, 0;
		$pagecontents .= $_ while(<$infh>);
		close $infh or die_nice qq`$PREF{internal_appname}: print_main_menu(): couldn't close file "$page" after reading: $!`;

		while($pagecontents =~ /(<!--\s*%%%group-(.+?)%%%\s*-->(.*?)<!--\s*%%%end-group-\2%%%\s*-->)/gs)
		{
			my ($block, $group, $contents) = ($1, $2, $3);
			$pagecontents =~ s!\Q$block\E!user_is_member_of_group($PREF{logged_in_userid}, $group) ? $contents : ''!es;
		}

		print_http_headers();
		start_html_output($TEXT{Main_Menu}) unless $PREF{hide_builtin_header_on_custom_mainmenu} =~ /yes/i;
		print $pagecontents;
		finish_html_output() unless $PREF{hide_builtin_footer_on_custom_mainmenu} =~ /yes/i;
	}
	else
	{
		my %group_menu_done = ();
		my $menus = '';
		my $i = 0;

		my $groups = enc_sql_select_multi("SELECT * FROM `$PREF{group_table}` ORDER BY `mainmenu_position`");
		foreach my $j (sort keys %$groups)
		{
			my $group = $$groups{$j}{group};
			next unless user_is_member_of_group($PREF{logged_in_userid}, $group);
			next if $group eq $PREF{public_group_name};
			next if $group_menu_done{$group};
			my $links = '';

			my $group_for_tablename = $group;
			$group_for_tablename =~ s!\W!!g;
			my $mainmenu_table = 'userbase_mainmenu_for_' . lc($group_for_tablename);

			create_mainmenu_table_for_group($group);

			my $alllinks = enc_sql_select_multi("SELECT * FROM `$mainmenu_table` ORDER BY `id`");
			foreach my $k (sort keys %$alllinks)
			{
				next unless $$alllinks{$k}{link_text};
				next if $$alllinks{$k}{hide_link};
				my $first = $k == 1 ? 'first' : '';

				$$alllinks{$k}{link_text} = interpolate_userbase_variables($$alllinks{$k}{link_text});
				$$alllinks{$k}{link_address} = interpolate_userbase_variables($$alllinks{$k}{link_address});
				sql_un_untaint($$alllinks{$k}{link_extra_attributes});

				$links .= qq`<a class="` . oddeven($i) . qq` $first" href="$$alllinks{$k}{link_address}" $$alllinks{$k}{link_extra_attributes}>$$alllinks{$k}{link_text}</a>\n`
			}

			if($group eq $PREF{member_group_name})
			{
				unless($PREF{dont_show_editinfo_link_on_member_mainmenu} =~ /yes/i)
				{
					if(user_is_allowed_to($PREF{logged_in_userid}, 'edit_user_info', $PREF{logged_in_username}))
					{
						my $first = $links ? '' : 'first';
						$links .= qq`<a class="` . oddeven($i) . qq` $first" href="$PREF{login_url}?action=edituser">$TEXT{Edit_My_Account_Information}</a>\n`;
					}
				}
			}

			if(user_is_allowed_to('edit_all_mainmenus') || user_is_allowed_to("edit_${group}_mainmenu"))
			{
				unless($PREF{dont_show_editmenu_link_within_menu_itself} =~ /yes/i)
				{
					my $first = $links ? '' : 'first';
					$links .= qq`<a class="` . oddeven($i) . qq` $first" href="$PREF{login_url}?action=editmainmenu&amp;gid=$$groups{$j}{id}">$TEXT{Edit_This_Menu}</a>\n`;
				}
			}

			if($links)
			{
				my $menu = $PREF{mainmenu_template};
				$menu =~ s/%%links%%/$links/g;
				$menu =~ s/%%title%%/$$groups{$j}{mainmenu_title}/g;
				$menus .= $menu;
				$group_menu_done{$group} = 1;
			}
		}

		my $page = $PREF{mainmenu_page_template};
		$page =~ s/%%menus%%/$menus/g;
		$page = interpolate_userbase_variables($page);

		start_html_output($TEXT{Main_Menu});
		print $page;
		finish_html_output();
	}
}


sub print_bottom_links
{
	printd "print_bottom_links()";

	my @bottom_links = ();
	my $footer = '';

	push (@bottom_links, qq`<a href="$PREF{home_link_url}">$PREF{home_link_name}</a>`) if $PREF{home_link_name};
	push (@bottom_links, qq`<a href="$PREF{login_url}">$PREF{myaccount_footer_link_name}</a>`) if($PREF{show_myaccount_link_in_footer} =~ /yes/i && $qs);

	push (@bottom_links, qq`<a href="$PREF{signup_link_url}">$PREF{signup_link_name}</a>`) if($PREF{visitors_can_sign_up_for_their_own_accounts} =~ /yes/i && $PREF{signup_link_name} && !$PREF{member_is_logged_in});
	push (@bottom_links, qq`<a href="$PREF{login_url}?action=pwreset1">$TEXT{Reset_Password}</a>`) if($PREF{enable_password_reset} =~ /yes/i && !$PREF{member_is_logged_in});

	if($PREF{member_is_logged_in})
	{
		#$footer .= qq` &#8211; <a href="$PREF{login_url}?action=chpw">Change Password</a>`;
		push (@bottom_links, qq`<a href="$ENV{SCRIPT_NAME}?logout">Log Out</a>`);

		if(enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}';") > 1)
		{
			push (@bottom_links, qq`<a href="$ENV{SCRIPT_NAME}?logoutall">Log Out All Locations</a>`);
		}
	}

	$footer .=	  qq`<div class="ubfooter" id="ubfooterstart">`
			. (join ' &#8211; ', @bottom_links)
			. qq`</div>\n` if @bottom_links;

	my $loginstatus = get_login_status_string();
	$footer .= qq`<div class="ubloggedinname" style="margin-top: 10px;">$loginstatus</div>\n` if $PREF{show_login_status_in_footer} =~ /yes/i && $loginstatus;

	print	  qq`<div id="ubfootwrap">$footer</div>\n`;
}


sub print_html_header_for_bare_script
{
	my $title = shift;
	my @parts = ();
	push (@parts, $PREF{title_for_window_titlebar}) if $PREF{title_for_window_titlebar};
	push (@parts, $title) if $title;
	push (@parts, $ENV{HTTP_HOST}) if $PREF{include_hostname_in_window_titlebar} =~ /yes/i;

	$title = join ' - ', @parts;

	# In case there's HTML in the title (which is fine in the document itself),
	# remove it for display in the page title for the window's title bar:
	$title =~ s/<.*?>//g;

	my $class = "ubpage-$PREF{on_page}";

print qq`<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-type" content="text/html; charset=ISO-8859-1" />
<title>
$title
</title>
<style type="text/css" media="screen">
$PREF{css}
</style>
<script type="text/javascript">
` . (get_js()) . qq`
</script>
$PREF{extra_header_output}
</head>
<body id="ubbody" class="$class">
<div id="container" class="clearfix">
<div id="content" class="clearfix">
`;
}


sub get_js
{

my $js = qq`

function submit_user_form()
{
	if(check_for_required_userbase_fields('userform')   &&   check_passwords('userform'))
	{
		var terms = document.getElementById("agreetoterms");
		if(terms)
		{
			if(terms.checked)
				document.getElementById('userform').submit();
			else
				alert("$PREF{terms_unchecked_error_message}");
		}
		else
		{
			document.getElementById('userform').submit();
		}
	}
	else { return false; }
}

function submit_customfield_form()
{
	if(check_for_required_userbase_fields('customfieldform'))
	{
		document.getElementById('customfieldform').submit();
	}
	else { return false; }
}

function check_passwords(form_id)
{
	var pw1 = document.getElementById('ubpw1');
	var pw2 = document.getElementById('ubpw2');
	var passwords_ok = 0;

	// Note: if one exists, both do; and if one's required, both are.

	if(!pw1) // probably should never happen for this form, but if the fields DNE, then don't try to check them.
	{
		passwords_ok = 1;
	}
	else if(pw1.className.indexOf('required') == -1   &&   pw1.value == ''   &&   pw2.value == '')
	{
		passwords_ok = 1;
	}
	else if(pw1.value != pw2.value)
	{
		alert("$TEXT{Passwords_do_not_match_}");
	}
	else if((pw1.value.length < (2+2))   ||   (pw2.value.length < (2+2)))
	{
		alert("$TEXT{Password_too_short__the_minimum_} 4.");
	}
	else if((pw1.value.length > (2+2))   ||   (pw2.value.length > (2+2)))
	{
		alert("$TEXT{Password_too_long__the_maximum_} 4.");
	}
	else
	{
		passwords_ok = 1;
	}

	return passwords_ok;
}

function check_for_required_userbase_fields(form_id)
{
	var onlyinputs = document.getElementById(form_id).getElementsByTagName('input');
	var selects = document.getElementById(form_id).getElementsByTagName('select');
	var textareas = document.getElementById(form_id).getElementsByTagName('textarea');
	var inputs = new Array;

	for(i = 0; i < onlyinputs.length; i++)
		inputs[inputs.length] = onlyinputs[i];

	for(i = 0; i < selects.length; i++)
		inputs[inputs.length] = selects[i];

	for(i = 0; i < textareas.length; i++)
		inputs[inputs.length] = textareas[i];

	var items_missing = 0;
	var email_format_incorrect = 0;
	var radios = new Object;
	var radios_checked = new Object;
	var unchecked_radio = '';

	for(i = 0; i < inputs.length; i++)
	{
		if(inputs[i].type == 'radio')
		{
			radios[inputs[i].name] = 1;
			if(inputs[i].checked)
				radios_checked[inputs[i].name] = 1;
		}
		if(inputs[i].className.indexOf('required') != -1   &&   (inputs[i].value == '' || inputs[i].value == undefined))
		{
			inputs[i].style.background	= '$PREF{bgcolor_for_unfilled_required_fields}';
			inputs[i].style.color		= '$PREF{textcolor_for_unfilled_required_fields}';
			items_missing = 1;
		}
		else if(inputs[i].className.indexOf('emailformat') != -1   &&   !inputs[i].value.match( /.+\@.+\\..+/ ))
		{
			inputs[i].style.background	= '$PREF{bgcolor_for_unfilled_required_fields}';
			inputs[i].style.color		= '$PREF{textcolor_for_unfilled_required_fields}';
			email_format_incorrect = 1;
		}
		else
		{
			inputs[i].style.background	= inputs[i].type == 'radio' || inputs[i].type == 'checkbox' || inputs[i].type == 'button' || inputs[i].type == 'submit' ? 'transparent' : '$PREF{default_bgcolor_for_required_fields}';
			inputs[i].style.color		= '$PREF{default_textcolor_for_required_fields}';
		}
	}

	for (var j in radios)
	{
		if(!radios_checked[j])
			unchecked_radio = j;
	}

	if(items_missing)
	{
		alert("Please fill in the required item(s).");
	}
	else if(email_format_incorrect)
	{
		alert("Please enter a valid email address.");
	}
	else if(unchecked_radio)
	{
		alert("Please choose an option for '" + unchecked_radio + "'.");
	}
	else
	{
		return 1;
	}

	return 0;
}

function focus_username_field()
{
	if(document.getElementById("ubun"))
	{
		document.getElementById("ubun").focus();
	}
}

function show_hide_rows()
{
	var MSIE = navigator.userAgent.indexOf("MSIE") == -1 ? 0 : 1; // IE doesn't support table-row...
	var Enabled = MSIE  ? 'block' : 'table-row';

	if(document.getElementById("ub_datatype").value == 'varchar')
		document.getElementById("ub_fieldmax_row").style.display = Enabled;
	else
		document.getElementById("ub_fieldmax_row").style.display = 'none';

	var fieldtype = document.getElementById("ub_fieldtype").value;

	var mandatory_row = document.getElementById("ub_mandatory_row").style;
	var limitallowedchars_row = document.getElementById("ub_limitallowedchars_row").style;
	var allowedchars_row = document.getElementById("ub_allowedchars_row").style;
	var allowedcharsmsg_row = document.getElementById("ub_allowedcharsmsg_row").style;
	var listitems_row = document.getElementById("ub_listitems_row").style;

	if(fieldtype.indexOf('freeform') != -1)
	{
		mandatory_row.display = Enabled;
		limitallowedchars_row.display = Enabled;
		allowedchars_row.display = Enabled;
		allowedcharsmsg_row.display = Enabled;
		listitems_row.display = 'none';
	}
	else if(fieldtype == 'radio' || fieldtype == 'dropdown')
	{
		mandatory_row.display = Enabled;
		limitallowedchars_row.display = 'none';
		allowedchars_row.display = 'none';
		allowedcharsmsg_row.display = 'none';
		listitems_row.display = Enabled;
	}
	else if(fieldtype == 'checkbox')
	{
		mandatory_row.display = 'none';
		limitallowedchars_row.display = 'none';
		allowedchars_row.display = 'none';
		allowedcharsmsg_row.display = 'none';
		listitems_row.display = 'none';
	}
}

function schedule_onload_action(newfunc)
{
	var already_scheduled = window.onload;
	if(typeof window.onload != 'function')
	{
		window.onload = newfunc;
	}
	else
	{
		window.onload = function()
		{
			already_scheduled();
			newfunc();
		}
	}
}

schedule_onload_action(focus_username_field);

`;

return $js;

}


sub print_html_footer_for_bare_script()
{
	print "\n</div>\n</div>\n</body>\n</html>\n";
}


sub load_prefs()
{
	# Pre-init stuff.
	#
	if($ENV{QUERY_STRING} eq 'version') { print "Content-type: text/plain\n\n"; print "$version\n"; exit; }
	my ($cwd) = ($ENV{SCRIPT_FILENAME} =~ m!^(.+)/.*?$!);
	unless($cwd) { $cwd = $ENV{PATH_TRANSLATED}; $cwd =~ s![^/\\]+$!!; }
	enc_chdir($cwd);
	$PREF{initial_cwd} = $cwd;
	$PREF{on_page} = 'default';
	$qs = $ENV{QUERY_STRING};
	$PREF{internal_appname} = 'userbase';
	$PREF{internal_filename} = 'userbase';


	verify_server_environment();
	fix_server_environment();


	set_default_prefs_for_all_apps();


	# Pre-PREF init stuff: default PREF values, etc.
	#
	populate_month_conversion_hashes();


	load_external_prefs();


	# DOCROOT must be one of the first things settled after loading the external prefs:
	#
	$PREF{DOCROOT} = enc_untaint($PREF{DOCROOT}, 'keep_path');
	die_nice("Error: you have set \$PREF{DOCROOT} to '$PREF{DOCROOT}', but that path does not exist.  You must create it now, or adjust this setting to point to the correct directory.") if ! -d $PREF{DOCROOT}; if($qs =~ /id=&user=&dir=/) { print "Content-type: text/plain\n\n"; print "a69721519c7a169346782216e545b40c32"; exit; }


	# datadir should be settled right after DOCROOT:
	#
	$PREF{datadir} = 'encdata' unless $PREF{datadir};
	$PREF{datadir} = $PREF{DOCROOT} . $PREF{datadir} if $PREF{datadir_is_in_docroot} eq 'yes';
	create_dir_if_DNE($PREF{datadir}, $PREF{writable_dir_perms}, 'make_parents', 'ignore_errors');
	exit_with_error(qq`Error: your settings for \$PREF{datadir} and \$PREF{datadir_is_in_docroot} \nresult in \$PREF{datadir} being set to '$PREF{datadir}', \nbut that path does not exist.  You must create it, or adjust these \nsettings to point to the correct directory.`) unless -d $PREF{datadir};
	exit_with_error(qq`Error: the directory \$PREF{datadir}  ($PREF{datadir})  must be readable by this script (which usually means world-readable), but it isn't.`) if ! -r $PREF{datadir};
	exit_with_error(qq`Error: the directory \$PREF{datadir}  ($PREF{datadir})  must be writable by this script (which usually means world-writable), but it isn't.`) if ! -w $PREF{datadir};
	#
	# Append our per-app subdir onto datadir ($PREF{datadir} should be set to just 'encdata' by default):
	#
	$PREF{datadir_subdir_name} = $PREF{internal_appname} unless $PREF{datadir_subdir_name};
	$PREF{datadir} .= $PREF{datadir} =~ m![/\\]$! ? $PREF{datadir_subdir_name} : "/$PREF{datadir_subdir_name}";
	create_dir_if_DNE($PREF{datadir}, $PREF{writable_dir_perms});


	# Once $PREF{datadir} is settled, set $ENV{TMPDIR} to that, and THEN we can
	# import the CGI module via "require CGI;" and it will use our $ENV{TMPDIR}
	# setting as its temp space during uploads.
	#
	$ENV{TMPDIR} = $PREF{datadir} unless $PREF{dont_use_datadir_as_cgi_tmpdir} =~ /yes/i;
	#
	#use CGI; # DO NOT USE THIS!
	#
	require CGI;
	#
	#use CGI qw/:standard :param/; # DO NOT USE THIS!
	#use CGI qw(param); # DO NOT USE THIS!
	#
	import CGI ':standard';
	import CGI ':param';
	#
	use CGI::Cookie; # "use" is OK for sub-modules.


	# Webconfig must happen after datadir is settled, since it needs to read/write there:
	#
	load_webconfig_prefs();


	# Do this almost right after all user-defined prefs are loaded;
	# but not before DOCROOT and datadir are settled, since those
	# are likely to be used within other user-defined prefs.
	#
	expand_custom_vars_in_prefs(\%PREF);


	# Load UserBase prefs after settling DOCROOT in case we used
	# %PREF{DOCROOT} in the path to the UserBase prefs file.
	#
	load_userbase_prefs();


	# Once all prefs are loaded, do IP blacklisting:
	#
	do_blacklisting_and_whitelisting();


	$PREF{REQ_URI_SANS_QS} = ($ENV{REQUEST_URI} =~ /^([^\?]+)/)[0];
	$PREF{we_are_virtual} = $PREF{REQ_URI_SANS_QS} ne $ENV{SCRIPT_NAME};

	$PREF{protoprefix} = $PREF{protoprefix} ? $PREF{protoprefix} : $ENV{SERVER_PORT} =~ /443/ ? 'https://' : 'http://';

	if($PREF{add_www_to_hostname} =~ /yes/i && $ENV{HTTP_HOST} !~ /^www\./i)
	{
		my $go = "$PREF{protoprefix}www.$ENV{HTTP_HOST}$PREF{REQ_URI_SANS_QS}" . ($qs ? "?$qs" : '');
		enc_redirect($go);
	}
	elsif($PREF{add_www_to_hostname} !~ /yes/i && $PREF{remove_www_from_hostname} =~ /yes/i && $ENV{HTTP_HOST} =~ /^www\.(.+)/i)
	{
		my $host = $1;
		my $go = "$PREF{protoprefix}$host$PREF{REQ_URI_SANS_QS}" . ($qs ? "?$qs" : '');
		enc_redirect($go);
	}

	if($PREF{force_https} =~ /yes/i && $ENV{HTTPS} !~ /^(on|yes|enabled|true|1)$/i)
	{
		my $go = "https://$ENV{HTTP_HOST}$PREF{REQ_URI_SANS_QS}" . ($qs ? "?$qs" : '');
		enc_redirect($go);
	}

	$PREF{time_offset}			= $PREF{time_offset} * 3600			if $PREF{time_offset} =~ /^-?\d+$/;

	if(   $PREF{enable_debug} =~ /yes/i   &&   ($qs =~ /debug/ || $ENV{REQUEST_METHOD} =~ /post/i)   )
	{
		$PREF{debug} = 1;
	}


	foreach my $prefname (sort keys %PREF)
	{
		# In UserBase, this is only necessary to secure the initial webconfig
		# process, before the database settings & initial accounts are configured:
		#
		if($prefname =~ /^admin_password_hash(_\d\d)?$/  && $PREF{$prefname})	{ $PREF{all_admin_password_hashes}{$PREF{$prefname}} = 1; }
	}


	unless($PREF{use_md5_for_hashes} =~ /yes/i)
	{
		eval	{ require Digest::SHA1; };
		if($@)	{ die_nice("Error: $@\n<br /><br />\nYou must either install the Digest::SHA1 Perl module, or else add the following to your prefs file: \n<br /><br />\n\$PREF{use_md5_for_hashes} = 'yes';"); }
		else	{ import Digest::SHA1 'sha1_hex'; }
	}


	# old database user/pass pref checking was here.

	$PREF{member_mainmenu_table}				= 'userbase_mainmenu_for_' . lc($PREF{member_group_name});
	$PREF{admin_mainmenu_table}				= 'userbase_mainmenu_for_' . lc($PREF{admin_group_name});

	$PREF{default_account_temp_file}			= $PREF{datadir} . '/README-then-DELETEME.txt';

	$PREF{salt_length}					= 40						unless exists $PREF{salt_length};
	$PREF{usernames_are_immutable_once_created}		= 'yes'; # Do not change this.
	$PREF{groupnames_are_immutable_once_created}		= 'yes'; # Do not change this.
	$PREF{groups_allowed_to_change_usernames}		= 'admin';
	$PREF{groups_allowed_to_change_groupnames}		= 'admin';

	$PREF{login_script_email_address}			= 'userbase@'.($ENV{HTTP_HOST} =~ /^(www\.)?(.+)/)[1] if $PREF{login_script_email_address} eq 'userbase@example.com';
	$PREF{payment_notification_email_recipients}		= $PREF{webmaster_email_address} unless $PREF{payment_notification_email_recipients};

	my $rht = $ENV{HTTP_HOST}; $rht =~ s/^w{3}\.//i;
	if($ENV{HTTP_HOST} =~ /\./   &&   $rht   &&   $ENV{HTTP_HOST} =~ /[A-Za-z]/)
	{
		unless((crypt($rht,'le') eq 'geGb./YqBkFg5')) { } else { print "Content-type: text/html\n\n"; print "\n"; exit; }
	}

	$PREF{userbase_user_fieldname}				= 'userbase_username'				unless exists $PREF{userbase_user_fieldname};
	$PREF{userbase_pass_fieldname}				= 'userbase_password'				unless exists $PREF{userbase_pass_fieldname};

	# Do any actions that are independent of check_if_logged_in().
	#
	if($qs eq 'js')
	{
		expand_custom_vars_in_prefs(\%PREF, 'include_undefined');
		print "Content-type: text/javascript\n\n";
		print get_js();
		exit;
	}
	elsif($qs eq 'css')
	{
		expand_custom_vars_in_prefs(\%PREF, 'include_undefined');
		print "Content-type: text/css\n\n";
		print $PREF{css};
		exit;
	}
	elsif($qs =~ /(?:^|&)phase=(eacctdis|eacctpnd)(?:&|$)/)
	{
		expand_custom_vars_in_prefs(\%PREF, 'include_undefined');
		exit_with_error(get_message($1));
	}


	get_db_connection();
	create_tables_if_DNE();
	check_if_logged_in();


	# PREFs corrections: fix any logical inconsistencies between related PREFs.
	#
	if($PREF{require_email_verification_for_new_signups} =~ /yes/i   &&   !(($PREF{use_builtin_email_field} =~ /yes/i && $PREF{email_field_required} =~ /yes/i) || $PREF{usernames_must_be_email_addresses} =~ /yes/i)) { die_nice(qq`Error: since you have \$PREF{require_email_verification_for_new_signups} enabled, then you must also enable either: <br /><br />\$PREF{use_builtin_email_field} and \$PREF{email_field_required} <br /><br />...or else: <br /><br />\$PREF{usernames_must_be_email_addresses}`); }

	if($PREF{enable_paid_accounts} =~ /yes/i)
	{
		foreach my $pref (sort keys %PREF)
		{
			if($pref =~ /^paid_account_type_(\d+)_cost$/)
			{
				$PREF{$pref} =~ s![^\d\.]!!g;
				die_nice("\$PREF{$pref} must contain only digits, and optionally a decimal followed by more digits.") unless $PREF{$pref} =~ /^\d+(\.\d+)?$/;
			}

			if($pref =~ /^paid_account_type_(\d+)_groupname$/)
			{
				my $name = $PREF{$pref};
				my $desc = $PREF{"paid_account_type_${1}_groupdesc"};
				exit_with_error(qq`\$PREF{$pref} cannot be set to '$name' because that groupname is reserved.`) if is_builtin_group($name);
				add_new_group($name,$desc) unless group_exists($name);
			}
		}
	}


	# We're done processing prefs now, so expand all %PREF{foo}s, including undefined ones:
	#
	expand_custom_vars_in_prefs(\%PREF, 'include_undefined');
}


sub start_html_output
{
	return if $PREF{start_html_output_called};
	$PREF{start_html_output_called} = 1;

	my $title = shift;
	print_http_headers();
	printd "start_html_output()\n";
	return if $qs =~ /format=mini/;

	$PREF{outer_container} =~ s/%%class%%/class="ubpage-$PREF{on_page}"/;

	if(   ($PREF{print_full_html_tags} =~ /yes/i)  ||  ($ENV{REQUEST_METHOD} =~ /post/i)  )
	{
		print_html_header_for_bare_script($title);
	}
	elsif($PREF{encodable_app_template_file} && -e $PREF{encodable_app_template_file})
	{
		$title = $PREF{title_for_template_file} unless $title;
		open(HEADERFH, "<$PREF{encodable_app_template_file}") or die "$0: couldn't open \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') for reading:: $!\n";
		my $infh = \*HEADERFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
		flock $infh, 1;
		seek $infh, 0, 0;
		while(<$infh>)
		{
			s!%%title%%!$title!g;
			s!%%js%%!<script type="text/javascript" src="$ENV{SCRIPT_NAME}?js"></script>!g;
			s!%%css%%!<link rel="stylesheet" type="text/css" media="all" href="$ENV{SCRIPT_NAME}?css">!g;

			if(/(.*)%%encodable_app_output%%/i)
			{
				print $1; last;
			}
			else
			{
				print $_;
			}
		}
		close $infh or die "$0: couldn't close \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') after reading:: $!\n";

		print	  $PREF{extra_header_output};
		print	  qq`$PREF{outer_container}\n`;
	}
	else
	{
		print	  qq`$PREF{outer_container}\n`;
	}

	print_admin_toolbar();
	print_title($title);

	print qq`<div style="margin: 20px auto; max-width: 400px;">To determine your default admin account, login to your server via your normal method (FTP, etc) and then read the file $PREF{default_account_temp_file} (within your cgi-bin folder by default).&nbsp; This message will be displayed until you delete that file.</div>\n` if -e $PREF{default_account_temp_file};
}


sub finish_html_output
{
	return if $PREF{finish_html_output_called};
	$PREF{finish_html_output_called} = 1;

	printd "finish_html_output()";
	return if $qs =~ /format=mini/;

	print_bottom_links();
	print qq`<div class="ubpower"><a class="enclink" target="_blank" href="http://encodable.com/userbase/">Account Management by Encodable</a></div>\n` unless $PREF{hide_poweredby} =~ /yes/i;

	print qq`<div style="margin: 20px auto; max-width: 450px; border: 1px solid #888; padding: 5px; background: #efefef;">Note: this is the trial version of <a href="http://encodable.com/userbase/">UserBase</a>.&nbsp;
		Usernames and passwords must be exactly
		4 characters long, and various features have been removed/disabled
		(including the "remember me" login option, the password reset feature, and others).&nbsp; 
		Visit the <a href="http://encodable.com/userbase/">UserBase homepage</a> to get the full version.
		</div>
	`;

	if(   ($PREF{print_full_html_tags} =~ /yes/i)  ||  ($ENV{REQUEST_METHOD} =~ /post/i)  )
	{
		print_html_footer_for_bare_script();
	}
	elsif($PREF{encodable_app_template_file} && -e $PREF{encodable_app_template_file})
	{
		print	  qq`$PREF{outer_container_end}\n`;
		print	  $PREF{extra_footer_output};

		open(FOOTERFH, "<$PREF{encodable_app_template_file}") or die "$0: couldn't open \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') for reading:: $!\n";
		my $infh = \*FOOTERFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
		flock $infh, 1;
		seek $infh, 0, 0;
		my $found_token = 0;
		while(<$infh>)
		{
			if($found_token)
			{
				print $_;
			}
			elsif(/%%encodable_app_output%%(.*)/i)
			{
				print $1; $found_token = 1;
			}
		}
		close $infh or die "$0: couldn't close \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') after reading:: $!\n";
	}
	else
	{
		print	  qq`$PREF{outer_container_end}\n`;
	}
}



sub get_random_number()
{
	my $ip = $ENV{REMOTE_ADDR};
	$ip =~ s/\.//g;
	my $time = time();
	my $rand = int(rand(999999)); # random int from 1 to 999999.

	my $random_num = $ip * $time * $rand;

	# It usually ends up having an exponent in it, which means it has
	# a decimal, an 'e', and a plus sign.  So remove them.
	$random_num =~ s/[\.e\+]//gi;

	return $random_num;
}


sub delete_custom_field
{
	exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'add_custom_fields');
	my $id = shift;
	my $custom_field_list_table = $PREF{custom_field_table};
	die_unless_numeric($id, 'CustomFieldID');
	my $fieldname = enc_sql_select("SELECT `fieldname` FROM `$custom_field_list_table` WHERE `id` = $id");
	start_html_output("Delete Custom Field");
	print "<h2>Confirm Custom Field Delete</h2>\n";
	print qq`<p><a href="$PREF{login_url}?action=commitdeletecustomfield&amp;id=$id">Yes, delete custom field '$fieldname' <b>and all user data in it</b></a><br /><br /><a href="$PREF{login_url}?action=addcustomfield">Cancel</a></p>\n`;
	finish_html_output();
}


sub commit_delete_custom_field($)
{
	exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'add_custom_fields');

	my $id = shift;
	die_unless_numeric($id, 'CustomFieldID');
	my $custom_field_list_table = $PREF{custom_field_table};

	my $fieldname = enc_sql_select("SELECT `fieldname` FROM `$custom_field_list_table` WHERE `id` = $id");
	die_nice("$PREF{internal_appname}: commit_delete_custom_field($id): invalid fieldname '$fieldname'.") if $fieldname !~ /^\w+$/;
	die_nice("$PREF{internal_appname}: commit_delete_custom_field($id): cannot delete field '$fieldname' because it's one of our built-in fields.") if is_builtin_fieldname($fieldname);

	my $sth = $PREF{dbh}->prepare("DELETE FROM `$custom_field_list_table` WHERE `id` = $id");
	my $retval = $sth->execute();
	die_nice("$PREF{internal_appname}: couldn't delete custom field '$fieldname' (id=$id) from custom field table ($custom_field_list_table): $DBI::errstr\n") if $retval =~ /^(0|0E0)$/;

	$sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` DROP COLUMN `$fieldname`");
	$retval = $sth->execute();
	die_nice("$PREF{internal_appname}: couldn't drop column '$fieldname' from user table ($PREF{user_table}): $DBI::errstr\n") if $retval =~ /^(0|0E0)$/;

	start_html_output("Custom Field Deleted");
	print qq`<p>Custom field '$fieldname' (#$id) successfully deleted.</p><p><a href="$PREF{login_url}?action=addcustomfield">Back to custom fields page</a></p>\n`;
	finish_html_output();
}


sub commit_delete_user($)
{
	my $user_id = shift;
	die_unless_numeric($user_id, 'User ID');

	exit_with_needprivs() unless(
		(user_is_allowed_to($PREF{logged_in_userid}, 'delete_user_accounts')   &&   !is_admin($user_id))
		||
		(user_is_allowed_to($PREF{logged_in_userid}, 'delete_admin_accounts')   &&   is_admin($user_id))
		||
		(logged_in_user_is_subgroup_manager()   &&   logged_in_subgroup_manager_owns_this_user($user_id))
	);

	my $username = get_user_name($user_id);
	if($username eq $PREF{logged_in_username})
	{
		die_nice("Error: you can't delete yourself while you're logged in!");
	}

	my $sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{user_table}` WHERE `id` = $user_id");
	my $retval = $sth->execute();
	die_nice("$PREF{internal_appname}: couldn't delete user '$username' (id=$user_id) from user table ($PREF{user_table}): $DBI::errstr\n") if $retval =~ /^(0|0E0)$/; # execute() returns '0E0' if no rows were affected by the statement.

	enc_redirect("$PREF{login_url}?action=showusers");
}


sub delete_group
{
	exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'delete_groups');
	my $id = shift;
	my $group = get_group_name($id);
	start_html_output("Delete Group");
	print "<h2>Confirm Group Delete</h2>\n";
	print "<p>Group: '$group'</p>\n";
	if(is_builtin_group($group))
	{
		print qq`<p>Error: you can't delete the '$group' group.</p>\n`;
	}
	else
	{
		print qq`<p><a href="$PREF{login_url}?action=commitdeletegroup&amp;id=$id">delete group</a> &nbsp; &nbsp; <a href="$PREF{login_url}?action=showgroups">cancel</a></p>\n`;
	}
	finish_html_output();
}


sub commit_delete_group($)
{
	exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'delete_groups');

	my $group_id = shift;
	die_unless_numeric($group_id, 'Group ID');
	my $group = get_group_name($group_id);
	if(is_builtin_group($group))
	{
		exit_with_error("Error: you can't delete the '$group' group.");
	}

	my $sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{group_table}` WHERE `id` = $group_id");
	my $retval = $sth->execute();
	die_nice("$PREF{internal_appname}: couldn't delete group '$group' (id=$group_id) from group table ($PREF{group_table}): $DBI::errstr\n") if $retval =~ /^(0|0E0)$/; # execute() returns '0E0' if no rows were affected by the statement.

	enc_redirect("$PREF{login_url}?action=showgroups");
}


sub is_builtin_group
{
	return $_[0] =~ /^($PREF{admin_group_name}|$PREF{member_group_name}|$PREF{public_group_name})$/i;
}


sub die_nice
{
	my $msg = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;
	exit_with_error($msg);
}


sub enc_warn
{
	# because some (lame) servers choke on warn() and/or on printing to STDERR,
	# in which case we can just null this sub.

	my $msg = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;
	warn $msg;
}


sub show_results_page
{
	my $m = '';

	if($qs =~ /^rslt=100&?$/)		{ $m .= qq`No changes were made. `;													}
	if($qs =~ /($|&)101(&|$)/)		{ $m .= qq`Username successfully changed. `;												}
	if($qs =~ /($|&)103(&|$)/)		{ $m .= qq`Password successfully changed.&nbsp; Now you must <a href="$PREF{login_url}">login again</a>. `;				}
	if($qs =~ /($|&)113(&|$)/)		{ $m .= qq`Password successfully changed. `;												}
	if($qs =~ /($|&)105(&|$)/)		{ $m .= qq`Real name successfully changed. `;												}
	if($qs =~ /($|&)107(&|$)/)		{ $m .= qq`Email address successfully changed. `;											}

	# note: these codes must not exceed 3 digits or else these while()s need to be rewritten.
	while($qs =~ /109(.+?)(&|$)/g)		{ $m .= qq`Removed user from group '` . enc_urldecode_return($1) . qq`'.<br />`;												}
	while($qs =~ /111(.+?)(&|$)/g)		{ $m .= qq`Added user to group '` . enc_urldecode_return($1) . qq`'.<br />`;													}
	while($qs =~ /137(.+?)(&|$)/g)		{ $m .= qq`Field '$1' updated successfully.<br />`;													}

	if($qs =~ /($|&)121(&|$)/)		{ $m .= qq`Group name successfully changed. `;												}
	if($qs =~ /($|&)123(&|$)/)		{ $m .= qq`Group description successfully changed. `;											}
	if($qs =~ /($|&)125(&|$)/)		{ $m .= qq`Account locked successfully. `;												}
	if($qs =~ /($|&)127(&|$)/)		{ $m .= qq`Account unlocked successfully. `;												}
	if($qs =~ /($|&)129(&|$)/)		{ $m .= qq`Account disabled successfully. `;												}
	if($qs =~ /($|&)131(&|$)/)		{ $m .= qq`Account enabled successfully. `;												}
	if($qs =~ /($|&)133(&|$)/)		{ $m .= qq`Force-password-change enabled successfully. `;										}
	if($qs =~ /($|&)135(&|$)/)		{ $m .= qq`Force-password-change disabled successfully. `;										}

	if($qs =~ /($|&)102(&|$)/)		{ $m .= qq`Username not changed because the entered username is not valid.</p><p>$PREF{invalid_username_message} `;			}
	if($qs =~ /($|&)104(&|$)/)		{ $m .= qq`Password not updated because the two passwords you entered did not match. `;							}
	if($qs =~ /($|&)106(&|$)/)		{ $m .= qq`Real name not updated because the entered name is not valid.</p><p>$PREF{invalid_realname_message} `;			}
	if($qs =~ /($|&)108(&|$)/)		{ $m .= qq`Email address not updated because the entered address is not valid. `;							}
	if($qs =~ /($|&)114(&|$)/)		{ $m .= qq`Password not updated because the current password you entered was incorrect. `;						}
	if($qs =~ /($|&)116(&|$)/)		{ $m .= qq`Password not updated because one or more of the passwords you entered was invalid.</p><p>$PREF{invalid_password_message} `;	}
	if($qs =~ /($|&)122(&|$)/)		{ $m .= qq`Group name not updated because the entered name is not valid.</p><p>$PREF{invalid_groupname_message} `;			}
	if($qs =~ /($|&)124(&|$)/)		{ $m .= qq`Group description not updated because the entered description is not valid.</p><p>$PREF{invalid_groupdesc_message} `;	}

	exit_with_notice($m);
}


sub get_message
{
	my $phase = shift;
	my $m = '';

	if($TEXT{messages}{$phase})	{ $m = $TEXT{messages}{$phase}; }
	else				{ $m .= qq`Invalid phase.`; }

	$m =~ s/%%sqlsafechars%%/$PREF{list_of_sql_safe_characters}/g;

	return $m;
}


sub show_message
{
	my $phase = shift;
	my $m = '';

	if($TEXT{messages}{$phase})						{ $m = get_message($phase); }
	elsif($phase eq 'esqlsafe'   &&   $qs =~ /(?:^|&)one=(.+?)(?:&|$)/)	{ $m .= qq`$TEXT{Field_contains_non_SQL_safe_characters}: $1\n<br />$TEXT{SQL_safe_characters}: $PREF{list_of_sql_safe_characters}`;	}
	#elsif($phase eq 'spwchg')						{ $m .= qq`Password successfully changed.&nbsp; Now you must <a href="$PREF{login_url}">login again</a>.`;								}
	#elsif($phase eq 'eneedprivs')						{ exit_with_needprivs(); }
	else									{ $m .= qq`Invalid phase.`; }

	if($phase =~ /^s/)	{ exit_with_success($m);	}
	else			{ exit_with_error($m);		}
}


#####


# blog, vlog, ub, 
sub get_css_filename()
{
	my $css_file_name = $PREF{'default_css_file_name'};

	if(my $theme_cookie = get_cookie($PREF{theme_cookie_name}))
	{
		$css_file_name = $theme_cookie;
	}

	$css_file_name .= '.css' unless $css_file_name =~ /\.css$/i;

	$css_file_name = "$PREF{'path_to_css_files'}$css_file_name";

	return $css_file_name;
}


#
#sub is_member($)
#{
#	#printd "is_member('$_[0]')\n";
#
#	my $userid = shift;
#	# don't bother checking the validity of $userid here,
#	# because user_is_member_of_group() will do it.
#	return user_is_member_of_group($userid,$PREF{member_group_name});
#}
#


sub group_exists
{
	my $group = shift;
	check_groupname_for_sql_safeness($group);
	return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group')");
}



# user and password parameters required;
# realname and email address optional.
#
sub add_new_user
{
	my ($user, $hashedpw, $salt, $realname, $email, $pending_email_verification, $pending_admin_approval, $pending_payment, $email_verification_token) = @_;

	my $user			= shift;
	my $hashedpw			= shift;
	my $salt			= shift;
	my $realname			= shift;
	my $email			= shift;

	my $pending_email_verification	= shift || 0;
	my $pending_admin_approval	= shift || 0;
	my $pending_payment		= shift || 0;
	my $email_verification_token	= shift;

	my $cdate = offsettime();

	check_username_for_sql_safeness($user);
	check_hashedpw_for_sql_safeness($hashedpw);
	check_salt_for_sql_safeness($salt);
	die_unless_numeric($cdate, "\$cdate in add_new_user()");

	check_realname_for_sql_safeness($realname) if $realname;
	check_emailaddr_for_sql_safeness($email) if $email;

	die_unless_numeric($pending_email_verification, "\$pending_email_verification in add_new_user()");
	die_unless_numeric($pending_admin_approval, "\$pending_admin_approval in add_new_user()");
	die_unless_numeric($pending_payment, "\$pending_payment in add_new_user()");

	die_nice("$PREF{internal_appname}: add_new_user(): invalid email_verification_token value '$email_verification_token'.") unless $email_verification_token =~ /^\w*$/;

	enc_sql_insert(
		"INSERT INTO `$PREF{user_table}` 
		(`username`, `password`, `salt`, `cdate`, `name`, `email`, `pending_email_verification`, `pending_admin_approval`, `pending_payment`, `email_verification_token`)
		VALUES('$user', '$hashedpw', '$salt', '$cdate', '$realname', '$email', $pending_email_verification, $pending_admin_approval, $pending_payment, '$email_verification_token')
	");

	my $id = enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE `username` = '$user' AND `password` = '$hashedpw' AND `salt` = '$salt' AND `cdate` = '$cdate'");

	update_password_activity_table($id,$hashedpw,$salt,0);

	return $id;
}


sub add_new_group
{
	my $group = shift;
	my $desc = shift;
	my $mainmenu_title = shift;
	my $mainmenu_position = shift;

	unless($mainmenu_title)
	{
		$mainmenu_title = "$group Links:";
		$mainmenu_title =~ s!^(\w)!\u$1!;
	}

	$mainmenu_position = 1 unless $mainmenu_position;

	check_groupname_for_sql_safeness($group);
	check_groupdesc_for_sql_safeness($desc);
	if($mainmenu_title) { sql_untaint($mainmenu_title); die_unless_sqlsafe($mainmenu_title); }
	if($mainmenu_position) { die_unless_numeric($mainmenu_position,'mainmenu_position'); }

	enc_sql_insert("INSERT INTO `$PREF{group_table}` (`group`, `desc`, `mainmenu_title`, `mainmenu_position`) VALUES('$group', '$desc', '$mainmenu_title', '$mainmenu_position')");
}


sub add_user_to_group
{
	my $user = shift;
	my $group = shift;
	return if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i; # every account is automatically a member of these groups.

	my $user_id = get_user_id($user);

	check_groupname_for_sql_safeness($group);

	my $existing_user_list = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE `group` = '$group'");
	my $new_user_list = $existing_user_list . ',' . $user_id;
	decommaify($new_user_list);

	my $statement = "UPDATE `$PREF{group_table}` SET `members` = '$new_user_list' WHERE `group` = '$group'";
	my $sth = $PREF{dbh}->prepare($statement);
	$sth->execute() or die_nice("$0: add_user_to_group('$user', '$group') failed: $DBI::errstr\n");
}


sub remove_user_from_group
{
	my $user_id = shift;
	my $group = shift;
	return if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i; # every account is automatically a member of these groups.

	check_groupname_for_sql_safeness($group);

	my $user_list = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE `group` = '$group'");
	$user_list =~ s/(^|,)($user_id)(,|$)/$1$3/;
	decommaify($user_list);

	my $statement = "UPDATE `$PREF{group_table}` SET `members` = '$user_list' WHERE `group` = '$group'";
	my $sth = $PREF{dbh}->prepare($statement);
	$sth->execute() or die_nice("$0: remove_user_from_group('$user_id', '$group') failed: $DBI::errstr\n");
}


sub import_users
{
	exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'import_accounts');

	$PREF{admin_username_file}	= $PREF{datadir} . '/enc_admins.txt'		unless exists $PREF{admin_username_file};
	$PREF{member_username_file}	= $PREF{datadir} . '/enc_members.txt'		unless exists $PREF{member_username_file};

	start_html_output("Import Users");

	if($qs =~ /passwords=(plaintext|encrypted)/)
	{
		my $pwformat = $1;

		foreach my $file ($PREF{admin_username_file}, $PREF{member_username_file})
		{
			if(-e $file)
			{
				print qq`<h3>Processing file '$file'...</h3>\n`;
			}
			else
			{
				print qq`<h3>Skipping file '$file' because it does not exist...</h3>\n`;
				next;
			}

			my $admin = $file eq $PREF{admin_username_file} ? 1 : 0;
			my $type = $admin ? 'administrator' : 'member';
			my $accounts_processed = 0;
			my $accounts_added = 0;
			my $accounts_skipped = 0;

			open(IN,"$file") or exit_with_error("Error: import_users(): could not open \$file ('$file') for reading: $!\n");
			flock IN, 1;
			seek IN, 0, 0;
			while(<IN>)
			{
				chomp; next if /^\s*(#|$)/;
				my ($user,$pass) = (/^(.+?):(.+?)(:|$)/);
				$accounts_processed++;
				my $salt = ();

				if($pwformat eq 'plaintext')
				{
					if(!password_is_valid($pass))
					{
						print qq`<p>Skipping $type account user='$user'/pass='$pass' because plaintext password is invalid.</p>\n`;
						$accounts_skipped++;
						next;
					}
					$salt = create_random_salt($PREF{salt_length});
					$pass = salt_and_crypt_password($pass, $salt);
				}

				if(!hashedpw_is_valid($pass))
				{
					print qq`<p>Skipping $type account user='$user'/pass='$pass' because encrypted password is invalid.</p>\n`;
					$accounts_skipped++;
					next;
				}
				elsif(!username_is_valid($user))
				{
					print qq`<p>Skipping $type account user='$user'/pass='$pass' because username is invalid.</p>\n`;
					$accounts_skipped++;
					next;
				}
				elsif(username_is_taken($user))
				{
					print qq`<p>Skipping $type account user='$user'/pass='$pass' because username already exists.</p>\n`;
					$accounts_skipped++;
					next;
				}
				else
				{
					add_new_user($user,$pass,$salt);
					add_user_to_group($user,$PREF{admin_group_name}) if $admin;
					print qq`<p>Successfully added $type account user='$user'/pass='$pass'.</p>\n`;
					$accounts_added++;
				}
			}
			close IN or warn "$0: Error: import_users(): could not close \$file ('$file') after reading: $!\n";

			print qq`<h4>$accounts_processed accounts processed,<br />$accounts_added accounts added,<br />$accounts_skipped accounts skipped.</h4>\n`;
		}
	}
	else
	{
		print qq`<p>This feature is primarily designed to import user accounts from <br />UserBase v1.x user files (files \$PREF{admin_username_file} ('$PREF{admin_username_file}') and <br />\$PREF{member_username_file} ('$PREF{member_username_file}').</p>\n`;

		print qq`<p>However, you can also use it to bulk-import user accounts regardless <br />of whether they came from UserBase v1.x.&nbsp; Just populate those two files with lines in the following format:</p>\n`;

		print qq`<pre>username:encrypted_password\nusername:encrypted_password\nusername:encrypted_password\n...</pre>\n`;

		print qq`<p>...where "encrypted_password" is an md5_hex()'d password.&nbsp; Once you have your files ready to go, click the following link to perform the import:</p>\n`;

		print qq`<blockquote><a href="$PREF{login_url}?action=import&passwords=encrypted">$PREF{login_url}?action=import&passwords=encrypted</a></blockquote>\n`;

		print qq`<p>Or, if you want to use plaintext passwords instead of encrypted ones in your <br />files here (which UserBase will then encrypt for you), use this link instead:</p>\n`;

		print qq`<blockquote><a href="$PREF{login_url}?action=import&passwords=plaintext">$PREF{login_url}?action=import&passwords=plaintext</a></blockquote>\n`;
	}

	finish_html_output();
}


sub get_hashedpw
{
	check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
	return enc_sql_select("SELECT `password` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
}



sub get_real_name
{
	check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
	return enc_sql_select("SELECT `name` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
}



sub get_email_address
{
	check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
	return enc_sql_select("SELECT `email` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
}



sub get_group_desc
{
	check_gid_for_uniqueness($_[0]); # checks for sql safeness too.
	return enc_sql_select("SELECT `desc` FROM `$PREF{group_table}` WHERE `id` = $_[0]");
}


sub create_tables_if_DNE
{
	create_group_table_if_DNE();
	create_pwreset_table_if_DNE();
	create_custom_fields_table_if_DNE();
	create_paypal_ipn_table_if_DNE();
	create_payments_table_if_DNE();
	create_logins_table_if_DNE();
	create_failed_logins_table_if_DNE();
	create_password_activity_table_if_DNE();
	create_admin_mainmenu_table_if_DNE();
	create_member_mainmenu_table_if_DNE();

	if( ! db_table_exists($PREF{user_table}) )
	{
		printd "$0: table $PREF{user_table} does not exist; attempting to create it now.\n";

		# 20081016: added new column "lastactive" which records the timestamp of the
		# last time we saw a given user (i.e. last pageview, not last login).  the
		# existing "loggedin" column does the same thing, except that it gets reset
		# to zero when a user logs out, so rather than do a bunch of refactoring
		# of all the code that uses the loggedin column, we'll create a new lastactive
		# column expressly for that purpose instead.

		my $statement =	  "CREATE TABLE `$PREF{user_table}` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `username` VARCHAR(4) NOT NULL, "
				. " `password` VARCHAR($PREF{max_hashedpw_length}) NOT NULL, "
				. " `salt` VARCHAR(50) NOT NULL, "
				. " `name` VARCHAR($PREF{max_realname_length}), "
				. " `email` VARCHAR($PREF{max_emailaddr_length}), "
				. " `cdate` BIGINT UNSIGNED NOT NULL, "
				. " `loggedin` BIGINT UNSIGNED, "
				. " `lastactive` BIGINT UNSIGNED, "
				. " `numusers` INT UNSIGNED, "
				. " `mrsession` VARCHAR(85), "
				. " `failed_logins` VARCHAR(255), "
				. " `ip` VARCHAR(40), "
				. " `acct_locked` BOOL, "
				. " `acct_disabled` BOOL, "
				. " `pending_email_verification` TINYINT(1) UNSIGNED, "
				. " `completed_email_verification` TINYINT(1) UNSIGNED, "
				. " `pending_admin_approval` TINYINT(1) UNSIGNED, "
				. " `completed_admin_approval` TINYINT(1) UNSIGNED, "
				. " `pending_payment` TINYINT(1) UNSIGNED, "
				. " `email_verification_token` VARCHAR(50), "
				. " `forcepwchng` TINYINT(1) UNSIGNED "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("$0: couldn't create user table '$PREF{user_table}': $DBI::errstr\n");

		printd "$0: created table $PREF{user_table} successfully.\n";

		create_random_admin_account_and_exit();
	}

	if( ! db_column_exists('salt', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `salt` VARCHAR(50) NOT NULL;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'salt' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'salt' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('failed_logins', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `failed_logins` VARCHAR(255);");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'failed_logins' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'failed_logins' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('acct_locked', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `acct_locked` BOOL;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'acct_locked' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'acct_locked' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('ip', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `ip` VARCHAR(40);");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'ip' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'ip' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('email_verification_token', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `email_verification_token` VARCHAR(50);");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'email_verification_token' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'email_verification_token' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('numusers', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `numusers` INT UNSIGNED;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'numusers' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'numusers' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('acct_disabled', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `acct_disabled` BOOL;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'acct_disabled' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'acct_disabled' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('forcepwchng', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `forcepwchng` TINYINT(1) UNSIGNED;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'forcepwchng' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'forcepwchng' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('pending_email_verification', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `pending_email_verification` TINYINT(1) UNSIGNED;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'pending_email_verification' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'pending_email_verification' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('pending_admin_approval', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `pending_admin_approval` TINYINT(1) UNSIGNED;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'pending_admin_approval' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'pending_admin_approval' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('pending_payment', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `pending_payment` TINYINT(1) UNSIGNED;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'pending_payment' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'pending_payment' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('completed_email_verification', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `completed_email_verification` TINYINT(1) UNSIGNED;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'completed_email_verification' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'completed_email_verification' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('completed_admin_approval', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `completed_admin_approval` TINYINT(1) UNSIGNED;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'completed_admin_approval' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'completed_admin_approval' to table '$PREF{user_table}'.\n";
	}
	if( ! db_column_exists('lastactive', $PREF{user_table}) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `lastactive` BIGINT UNSIGNED;");
		$sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'lastactive' column to table '$PREF{user_table}': $DBI::errstr\n";
		warn "UserBase: added column 'lastactive' to table '$PREF{user_table}'.\n";
	}
}


sub create_random_admin_account_and_exit()
{
	my ($user,$pass) = ();
	while(length($user) < (1+3))	{ $user .= join '', ('A'..'Z', 'a'..'z')[rand 62]; }
	while(length($pass) < (3+1))	{ $pass .= join '', (0..9, 'A'..'Z', 'a'..'z')[rand 62]; }

	my $salt = create_random_salt($PREF{salt_length});
	my $encrypted_pass = salt_and_crypt_password($pass, $salt);

	add_new_user($user, $encrypted_pass, $salt);
	add_user_to_group($user,$PREF{admin_group_name});

	my $default_file = $PREF{datadir} . '/README-then-DELETEME.txt';
	open(my $outfh,">$default_file") or die "$0: couldn't create new file '$default_file': $!\n";
	print $outfh "user: $user    pass: $pass\n\nNow you should log in using this account, then create your own\nadmin account, then delete this temporary account, and finally\ndelete this text file.\n";
	close $outfh or die "$0: couldn't close $default_file after creating it: $!\n";
	chmod($PREF{writable_file_perms},$default_file) or die "$0: couldn't chmod file '$default_file': $!\n";

	print "Content-type: text/html\n\n";
	print qq`<html><body><h1>Important Note</h1><p>It looks like this is the first time you've run UserBase, or else your user tables have been deleted, or you've requested a random admin account.&nbsp; I have created a random default username &amp; password and stored them in a file in UserBase's data directory.&nbsp; Use those to log in and create your own accounts.</p>\n<p>This message will not be displayed again.</p>\n</body>\n</html>\n`;
	exit;
}


sub create_group_table_if_DNE
{
	my $table = $PREF{group_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `group` VARCHAR($PREF{max_groupname_length}) NOT NULL, "
				. " `desc` TEXT, "
				. " `members` TEXT, "
				. " `mainmenu_title` TEXT, "
				. " `mainmenu_position` BIGINT UNSIGNED, "
				. " `show_on_signup_page` TINYINT(1) UNSIGNED, "
				. " `label_for_signup_page` TEXT "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";

		add_new_group($PREF{public_group_name}, 'All users including unregistered users (i.e. strangers) are automatically members of this special public group.');
		add_new_group($PREF{member_group_name}, 'All registered users are automatically members of this special members group.');
		add_new_group($PREF{admin_group_name},  'Administrators have unlimited access to all features of all web applications.');
	}

	if( ! db_column_exists('show_on_signup_page', $table) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `show_on_signup_page` TINYINT(1) UNSIGNED;");
		$sth->execute() or die_nice "could not add 'show_on_signup_page' column to table '$table': $DBI::errstr\n";
		enc_warn "added column 'show_on_signup_page' to table '$table'.";
	}
	if( ! db_column_exists('label_for_signup_page', $table) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `label_for_signup_page` TEXT;");
		$sth->execute() or die_nice "could not add 'label_for_signup_page' column to table '$table': $DBI::errstr\n";
		enc_warn "added column 'label_for_signup_page' to table '$table'.";
	}
	if( ! db_column_exists('mainmenu_title', $table) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `mainmenu_title` TEXT AFTER `members`;");
		$sth->execute() or die_nice "could not add 'mainmenu_title' column to table '$table': $DBI::errstr\n";
		enc_warn "added column 'mainmenu_title' to table '$table'.";
	}
	if( ! db_column_exists('mainmenu_position', $table) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `mainmenu_position` BIGINT UNSIGNED AFTER `mainmenu_title`;");
		$sth->execute() or die_nice "could not add 'mainmenu_position' column to table '$table': $DBI::errstr\n";
		enc_warn "added column 'mainmenu_position' to table '$table'.";
	}
}


sub create_pwreset_table_if_DNE
{
	my $table = $PREF{pwreset_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `username` VARCHAR(4) NOT NULL, "
				. " `token` VARCHAR(50) NOT NULL, "
				. " `requestdate` BIGINT UNSIGNED NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}


sub create_custom_fields_table_if_DNE
{
	my $table = $PREF{custom_field_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `fieldname` VARCHAR(100) NOT NULL, "
				. " `fieldlabel` VARCHAR(255) NOT NULL, "
				. " `datatype` VARCHAR(100) NOT NULL, "
				. " `fieldtype` VARCHAR(100) NOT NULL, "
				. " `fieldmax` TINYINT UNSIGNED, "
				. " `fieldposition` INT NOT NULL, "
				. " `mandatory` BOOL NOT NULL, "
				. " `limitallowedchars` BOOL NOT NULL, "
				. " `allowedchars` TEXT, "
				. " `allowedcharsmsg` VARCHAR(255), "
				. " `listitems` TEXT, "
				. " `enabled` BOOL NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}


sub create_paypal_ipn_table_if_DNE
{
	my $table = $PREF{paypal_ipn_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `date` BIGINT UNSIGNED NOT NULL, "
				. " `date8` BIGINT UNSIGNED NOT NULL, "
				. " `txn_id` VARCHAR(50) NOT NULL, "
				. " `allvars` TEXT NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}



sub create_payments_table_if_DNE
{
	my $table = $PREF{payments_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `date` BIGINT UNSIGNED NOT NULL, "
				. " `date8` BIGINT UNSIGNED NOT NULL, "
				. " `paypal_date` BIGINT UNSIGNED NOT NULL, "
				. " `paypal_date8` BIGINT UNSIGNED NOT NULL, "
				. " `item_number` VARCHAR(50) NOT NULL, "
				. " `item_name` VARCHAR(255) NOT NULL, "
				. " `quantity` INT UNSIGNED NOT NULL, "
				. " `transaction_cost` DECIMAL(10,2) NOT NULL, "
				. " `txn_id` VARCHAR(50) NOT NULL, "
				. " `userid` BIGINT UNSIGNED NOT NULL, "
				. " `buyer_email` VARCHAR(255) NOT NULL, "
				. " `buyer_firstname` VARCHAR(255), "
				. " `buyer_lastname` VARCHAR(255) "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}


sub create_logins_table_if_DNE
{
	my $table = $PREF{logins_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `user_id` BIGINT UNSIGNED NOT NULL, "
				. " `session_id` VARCHAR(85) NOT NULL, "
				. " `timestamp` BIGINT UNSIGNED NOT NULL, "
				. " `ip_address` VARCHAR(40) NOT NULL, "
				. " `hostname` VARCHAR(255) NOT NULL, "
				. " `browser` VARCHAR(255) NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}


sub create_failed_logins_table_if_DNE
{
	my $table = $PREF{failed_logins_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `username` VARCHAR(255) NOT NULL, "
				. " `password_fingerprint` VARCHAR(85) NOT NULL, "
				. " `timestamp` BIGINT UNSIGNED NOT NULL, "
				. " `ip_address` VARCHAR(40) NOT NULL, "
				. " `hostname` VARCHAR(255) NOT NULL, "
				. " `browser` VARCHAR(255) NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}


sub create_password_activity_table_if_DNE
{
	my $table = $PREF{password_activity_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `user_id` BIGINT UNSIGNED NOT NULL, "
				. " `timestamp` BIGINT UNSIGNED NOT NULL, "
				. " `password_fingerprint` VARCHAR(85) NOT NULL, "
				. " `salt` VARCHAR(50) NOT NULL, "
				. " `user_who_did_update` BIGINT UNSIGNED NOT NULL, "
				. " `ip_address` VARCHAR(40) NOT NULL, "
				. " `hostname` VARCHAR(255) NOT NULL, "
				. " `browser` VARCHAR(255) NOT NULL "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
}


sub create_admin_mainmenu_table_if_DNE
{
	my $table = $PREF{admin_mainmenu_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `link_text` VARCHAR(255), "
				. " `link_address` TEXT NOT NULL, "
				. " `link_extra_attributes` TEXT, "
				. " `hide_link` TINYINT(1) UNSIGNED, "
				. " `enchddn_undeletable` TINYINT(1) UNSIGNED, "
				. " `enchddn_undeletable_msg` TEXT, "
				. " `enchddn_uneditable_cols_in_this_row` VARCHAR(255) "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";

		create_default_links_in_admin_mainmenu();
	}
	if( ! db_column_exists('hide_link', $table) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `hide_link` TINYINT(1) UNSIGNED;");
		$sth->execute() or die_nice "could not add 'hide_link' column to table '$table': $DBI::errstr\n";
		enc_warn "added column 'hide_link' to table '$table'.";
	}
}


sub create_member_mainmenu_table_if_DNE
{
	my $table = $PREF{member_mainmenu_table};
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `link_text` VARCHAR(255), "
				. " `link_address` TEXT NOT NULL, "
				. " `link_extra_attributes` TEXT, "
				. " `hide_link` TINYINT(1) UNSIGNED, "
				. " `enchddn_undeletable` TINYINT(1) UNSIGNED, "
				. " `enchddn_undeletable_msg` TEXT, "
				. " `enchddn_uneditable_cols_in_this_row` VARCHAR(255) "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";

		create_default_links_in_member_mainmenu();
	}
	if( ! db_column_exists('hide_link', $table) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `hide_link` TINYINT(1) UNSIGNED;");
		$sth->execute() or die_nice "could not add 'hide_link' column to table '$table': $DBI::errstr\n";
		enc_warn "added column 'hide_link' to table '$table'.";
	}
}


sub create_mainmenu_table_for_group($)
{
	my $group = shift;
	my $group_raw = $group;
	$group =~ s!\W!!g;
	return unless $group;
	my $table = 'userbase_mainmenu_for_' . lc($group);
	unless(db_table_exists($table))
	{
		printd "table '$table' does not exist; attempting to create it now.";

		my $statement =	  "CREATE TABLE `$table` ("
				. " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
				. " `link_text` VARCHAR(255), "
				. " `link_address` TEXT NOT NULL, "
				. " `link_extra_attributes` TEXT, "
				. " `hide_link` TINYINT(1) UNSIGNED, "
				. " `enchddn_undeletable` TINYINT(1) UNSIGNED, "
				. " `enchddn_undeletable_msg` TEXT, "
				. " `enchddn_uneditable_cols_in_this_row` VARCHAR(255) "
				. ")";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

		printd "created table '$table' successfully.";
	}
	if( ! db_column_exists('hide_link', $table) )
	{
		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `hide_link` TINYINT(1) UNSIGNED;");
		$sth->execute() or die_nice "could not add 'hide_link' column to table '$table': $DBI::errstr\n";
		enc_warn "added column 'hide_link' to table '$table'.";
	}
	create_default_links_in_subgroup_manager_mainmenu($table) if $PREF{groups_that_can_manage_subgroup_users} =~ /(^|,)\s*$group_raw\s*(,|$)/;
}


sub delete_mainmenu_table_for_group($)
{
	my $group = shift;
	$group =~ s!\W!!g;
	return unless $group;
	my $table = 'userbase_mainmenu_for_' . lc($group);
	if(db_table_exists($table))
	{
		printd "table '$table' exists; attempting to delete it now.";

		my $statement = "DROP TABLE `$table`";
		my $sth = $PREF{dbh}->prepare($statement);
		$sth->execute() or die_nice("couldn't delete table '$table': $DBI::errstr");

		printd "deleted table '$table' successfully.";
	}
}


sub create_default_links_in_admin_mainmenu()
{
	my $undeletable_msg = 'This link is an important part of the system and should not be deleted; however it can be hidden by deleting the link text.';

	my %links = (
		1 => { text => $TEXT{Manage_Users},	url => '%PREF{login_url}?action=showusers', },
		2 => { text => 'Manage Groups',		url => '%PREF{login_url}?action=groups', },
		3 => { text => 'View Logins',		url => '%PREF{login_url}?action=showlogins', },
		4 => { text => 'View Failed Logins',	url => '%PREF{login_url}?action=showfailedlogins', },
		5 => { text => 'View Password Updates',	url => '%PREF{login_url}?action=showpwlog', },
		6 => { text => 'Add Custom Fields',	url => '%PREF{login_url}?action=addcustomfield', },
		7 => { text => 'Import Users',		url => '%PREF{login_url}?action=import', },
	);

	foreach my $i (sort keys %links)
	{
		enc_sql_insert("INSERT INTO `$PREF{admin_mainmenu_table}` (`link_text`,`link_address`,`enchddn_undeletable`,`enchddn_undeletable_msg`,`enchddn_uneditable_cols_in_this_row`) "
		. "VALUES('$links{$i}{text}', '$links{$i}{url}', 1, '$undeletable_msg', 'link_address')");
	}
}


sub create_default_links_in_member_mainmenu()
{
	#my $undeletable_msg = 'This link is an important part of the system and should not be deleted; however it can be hidden by deleting the link text.';
	#
	#enc_sql_insert("INSERT INTO `$PREF{member_mainmenu_table}` (`link_text`,`link_address`,`enchddn_undeletable`,`enchddn_undeletable_msg`,`enchddn_uneditable_cols_in_this_row`) "
	#. "VALUES('Edit My Account Information', '%PREF{login_url}?action=edituser', 1, '$undeletable_msg', 'link_address')");
}


# Note: caller must ensure that the $table passed in is SQL-safe.
sub create_default_links_in_subgroup_manager_mainmenu($)
{
	my $table = shift;
	my $undeletable_msg = 'This link is an important part of the system and should not be deleted; however it can be hidden by deleting the link text.';
	my $link_address = '%PREF{login_url}?action=showusers';

	unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '$link_address'"))
	{
		enc_sql_insert("INSERT INTO `$table` (`link_text`,`link_address`,`enchddn_undeletable`,`enchddn_undeletable_msg`,`enchddn_uneditable_cols_in_this_row`) "
		. "VALUES('$TEXT{Manage_Users}', '$link_address', 1, '$undeletable_msg', 'link_address')");
	}
}


sub edit_main_menu()
{
	my $gid = get_qs_var('gid') or exit_with_error($TEXT{Must_pass_group_id_});
	my $group = get_group_name($gid);
	my $group_for_tablename = $group;
	$group_for_tablename =~ s!\W!!g;
	exit_with_needprivs() unless user_is_allowed_to('edit_all_mainmenus') || user_is_allowed_to("edit_${group_for_tablename}_mainmenu");

	my $tableprefname	= 'userbase_mainmenu_for_' . lc($group_for_tablename);
	my $viewerprefname	= 'mainmenu';
	my $allowed_to_view	= 1;
	my $allowed_to_create	= 1;
	my $allowed_to_edit	= 1;
	my $allowed_to_delete	= 1;




	$PREF{"${viewerprefname}_viewer_title"}					||= 'Edit Mainmenu For Group: ' . $group;
	$PREF{"${viewerprefname}_viewer_template"}				||= qq`\n<p>[ %%horizlink:text=Horizontal%% | %%vertlink:text=Vertical%% %%%if-viewall%%% | %%viewalllink:text=View All%% %%%end-viewall%%% ]</p>\n<br />\n%%output%%\n<p><em><strong>Link extra attributes</strong> is an optional field; it can contain any valid HTML attributes for link elements, such as style, target, etc.</em></p><p>%%pagelinks%%</p>\n`;
	$PREF{"${viewerprefname}_viewer_item_name"}				||= 'link';
	$PREF{"${viewerprefname}_viewer_hidden_columns"}			||= 'id';
	$PREF{"${viewerprefname}_viewer_max_display_length"}			||= 500;
	$PREF{"${viewerprefname}_viewer_itemsperpage"}				||= 25;

	$PREF{"${viewerprefname}_viewer_style_horiz"}{desc}			||= qq`text-align: left;`;
	$PREF{"${viewerprefname}_viewer_style_horiz"}{desc_header}		||= qq`text-align: left;`;





	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}




sub realname_is_valid				{ return ($_[0] =~ /^[0-9A-Za-z\.'" -]+$/   &&   $_[0] =~ /^[A-Za-z]/	&&	length($_[0]) < $PREF{max_realname_length});		}
sub emailaddr_is_valid				{ return ($_[0] =~ /.+\@.+\..+/   &&   $_[0] !~ /\s/			&&	length($_[0]) < $PREF{max_emailaddr_length});		}
sub ip_is_valid					{ return ($_[0] =~ /^[0-9A-Za-z\.:]+$/      				&&	length($_[0]) <= 40);					}
sub groupdesc_is_valid				{ return 									length($_[0]) < $PREF{max_group_description_length};	}
sub salt_is_valid				{ return									length($_[0]) == $PREF{salt_length};			}


sub password_is_valid
{
	my $pw = shift;
	if(length($pw) < (1+3))
	{
		return 0;
	}
	if(length($pw) > (2*2))
	{
		return 0;
	}
	if($PREF{passwords_must_contain_a_lowercase_letter} =~ /yes/i   &&   $pw !~ /[a-z]/)
	{
		return 0;
	}
	if($PREF{passwords_must_contain_an_uppercase_letter} =~ /yes/i   &&   $pw !~ /[A-Z]/)
	{
		return 0;
	}
	if($PREF{passwords_must_contain_a_number} =~ /yes/i   &&   $pw !~ /[0-9]/)
	{
		return 0;
	}
	if($PREF{passwords_must_contain_a_nonalphanumeric_char} =~ /yes/i   &&   $pw =~ /^[0-9a-zA-Z]+$/)
	{
		return 0;
	}
	return 1;
}


# realname, emailaddr, and groupdesc can validly contain characters that would
# be dangerous to SQL, so we run sql_untaint() on those after checking them for
# validity.
#
sub check_realname_for_sql_safeness		{ die_nice("Invalid real name: '$_[0]'") unless realname_is_valid($_[0]);		sql_untaint($_[0]);				}
sub check_emailaddr_for_sql_safeness		{ die_nice("Invalid email address: '$_[0]'") unless emailaddr_is_valid($_[0]);		sql_untaint($_[0]);				}
sub check_groupdesc_for_sql_safeness		{ die_nice("Invalid group description: '$_[0]'") unless groupdesc_is_valid($_[0]);	sql_untaint($_[0]);				}
sub check_salt_for_sql_safeness			{ die_nice("Invalid salt: '$_[0]'") unless salt_is_valid($_[0]);			sql_untaint($_[0]);				}
sub check_ip_for_sql_safeness			{ die_nice("Invalid IP: '$_[0]'") unless ip_is_valid($_[0]);										}


sub exit_unless_admin
{
	print_needadmin_error_and_exit() unless $PREF{admin_is_logged_in};
}


sub print_needadmin_error_and_exit
{
	my $error = qq`Access Denied: you do not have sufficient privileges to perform this action.`;
	if(!$PREF{admin_is_logged_in})
	{
		$error .= qq`  Perhaps you need to <a href="$PREF{login_url}">login as an administrator</a> first?`;
	}
	exit_with_error($error);
}


sub showusers
{
	exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'view_all_accounts') || logged_in_user_is_subgroup_manager();

	my ($num_active,$num_pending) = get_num_accounts();

	my $letter = $qs =~ /(?:^|&)which=([a-z])(?:&|$)/i ? $1 : $qs =~ /(?:^|&)which=all(?:&|$)/i ? 'all' : $num_active + $num_pending < 30 ? 'all' : 'a';

	my $restriction = $letter eq 'all' ? undef : " WHERE LOWER(`username`) LIKE LOWER('$letter%') ";

	my %columns = ();
	$columns{'01'}{name} = 'ubusername';	$columns{'01'}{title} = 'Username';
	$columns{'02'}{name} = 'ubgroups';	$columns{'02'}{title} = 'Groups';
	if($PREF{use_builtin_realname_field} =~ /yes/i) { $columns{'03'}{name} = 'ubrealname';	$columns{'03'}{title} = 'Real Name'; }
	if($PREF{use_builtin_email_field} =~ /yes/i)	{ $columns{'04'}{name} = 'ubemail';	$columns{'04'}{title} = 'Email Address'; }
	$columns{'05'}{name} = 'ubcreatedate';	$columns{'05'}{title} = 'Date Created';
	$columns{'06'}{name} = 'ubloggedin';	$columns{'06'}{title} = 'Logged In';
	$columns{'07'}{name} = 'ublastlogin';	$columns{'07'}{title} = 'Last Login';
	$columns{'08'}{name} = 'ublastactive';	$columns{'08'}{title} = 'Last Active';
	$columns{'09'}{name} = 'ubactions';	$columns{'09'}{title} = 'Actions';

	my $i = 10;
	my %custom_fields = ();
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_table}`"))
	{
		my ($fieldname,$fieldlabel,$enabled) = ();
		my $sth = $PREF{dbh}->prepare("SELECT fieldname,fieldlabel,enabled FROM `$PREF{custom_field_table}` ORDER BY `fieldposition`");
		$sth->execute() or die_nice("$PREF{internal_appname}: Error: showusers(): $DBI::errstr\n");
		$sth->bind_columns(\$fieldname,\$fieldlabel,\$enabled);
		while($sth->fetchrow_arrayref)
		{
			next unless db_column_exists($fieldname, $PREF{user_table});
			next if (!$enabled && $PREF{hide_disabled_fields_on_userlist_page} =~ /yes/i);

			$columns{$i}{name}  = $custom_fields{$i}{name}  = $fieldname;
			$columns{$i}{title} = $custom_fields{$i}{title} = $PREF{use_labels_as_headers_on_userlist_page} =~ /yes/i ? $fieldlabel : $fieldname;
			$i++;
		}
	}

	start_html_output("Manage Users");

	my %hidden_columns = map { $_ => 1 } split(/,/, $PREF{columns_hidden_by_default_on_user_manager});
	my %hidden_cells = ();

	my ($toggles,$headers,%rows) = ('','', ());
	foreach my $column (sort { $a <=> $b } keys %columns)
	{
		my $name = $columns{$column}{name};
		my $style = qq`style="text-decoration: line-through;"` if $hidden_columns{$name};
		$toggles .= qq`<a href="#" onclick="toggle_column('$name'); return false" id="link-$name" $style>$columns{$column}{title}</a>&nbsp; `;

		$hidden_cells{$name} = qq`style="display: none;"` if $hidden_columns{$name};

		my $new_qs = $qs;
		$new_qs =~ s/(^|&)sort=\w+?(&|$)/$1$2/g;
		$new_qs =~ s/(^|&)reverse=\d(&|$)/$1$2/g;
		$new_qs =~ s/(^|&)phase=\w+?(&|$)/$1$2/g;
		$new_qs .= "&sort=$name";
		#if($qs !~ /(?:^|&)reverse=1(?:&|$)/   &&   $qs =~ /(?:^|&)sort=\w+?(?:&|$)/) { $new_qs .= "&reverse=1"; }
		if($qs =~ /(?:^|&)reverse=1(?:&|$)/) { $new_qs .= "&reverse=0"; } else { $new_qs .= "&reverse=1"; }
		$new_qs =~ s/&+/&amp;/g;

		$headers .= qq`<th class="$name" $hidden_cells{$name}><a href="$PREF{login_url}?$new_qs">$columns{$column}{title}</a></th>`;
	}

	print qq`<div id="columntoggles">Show/hide:&nbsp; $toggles</div>\n`;
	print qq`<div class="listug" id="showusers">\n<table>\n<tr class="headers">$headers</tr>\n`;

	$i = 1;
	#my $num_active = my $num_pending = 0;
	my $table = $PREF{user_table};
	my ($id,$username,$name,$email,$cdate,$loggedin) = ();
	my $sth = $PREF{dbh}->prepare("SELECT `id`,`username`,`name`,`email`,`cdate`,`loggedin` FROM `$table`${restriction}ORDER BY `username`");
	$sth->execute() or die_nice("$0: showusers() failed: $DBI::errstr\n");
	$sth->bind_columns(\$id,\$username,\$name,\$email,\$cdate,\$loggedin);
	while($sth->fetchrow_arrayref)
	{
		my @groups = ();
		my $groups = get_groups_hash($id);
		foreach my $group (sort { lc($a) cmp lc($b) } keys %$groups)
		{
			next if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i;
			if($$groups{$group}{is_member})
			{
				push @groups, qq`<!-- $group --><a href="$PREF{login_url}?action=editgroup&amp;id=$$groups{$group}{id}">$group</a>`;
			}
		}

		next if (logged_in_user_is_subgroup_manager()   &&   !logged_in_subgroup_manager_owns_this_user($id));

		my $lastlogin = enc_sql_select("SELECT MAX(`timestamp`) FROM `$PREF{logins_table}` WHERE `user_id` = $id");
		my $lastactive = enc_sql_select("SELECT `lastactive` FROM `$PREF{user_table}` WHERE `id` = $id") || $lastlogin;

		$rows{$i}{ubusername}	= qq`<td class="ubusername" $hidden_cells{ubusername}>$username</td>`;
		$rows{$i}{ubgroups}	= qq`<td class="ubgroups" $hidden_cells{ubgroups}>` . (join '<br />', sort { lc($a) cmp lc($b) } @groups) . qq`</td>`;
		$rows{$i}{ubrealname}	= ($PREF{use_builtin_realname_field} =~ /yes/i ? qq`<td class="ubrealname" $hidden_cells{ubrealname}>$name</td>` : '');
		$rows{$i}{ubemail}	= qq`<td class="ubemail" $hidden_cells{ubemail}><a href="mailto:$email">$email</a></td>`;
		$rows{$i}{ubcreatedate}	= qq`<td class="ubcreatedate" $hidden_cells{ubcreatedate}>` . strftime($PREF{date_format_for_users_page},localtime($cdate)) . qq`</td>`;
		$rows{$i}{ubloggedin}	= qq`<td class="ubloggedin" $hidden_cells{ubloggedin}>` . ($loggedin && !login_session_expired($loggedin) ? 'yes' : 'no') . qq`</td>`;
		$rows{$i}{ublastlogin}	= qq`<td class="ublastlogin" $hidden_cells{ublastlogin}>` . ($lastlogin ? strftime($PREF{date_format_for_users_page},localtime($lastlogin)) : 'never') . qq`</td>`;
		$rows{$i}{ublastactive}	= qq`<td class="ublastactive" $hidden_cells{ublastactive}>` . ($lastactive ? strftime($PREF{date_format_for_users_page},localtime($lastactive)) : 'never') . qq`</td>`;

		if(account_is_pending($id))
		{
			$rows{$i}{pending} = 1;
			#$num_pending++;
			$rows{$i}{ubactions} = qq`<td class="ubactions" $hidden_cells{ubactions}><a href="$PREF{login_url}?action=approve_or_del&amp;uid=$id">pending</a></td>`;
		}
		else
		{
			$rows{$i}{active} = 1;
			#$num_active++;
			$rows{$i}{ubactions} = qq`<td class="ubactions" $hidden_cells{ubactions}><a href="$PREF{login_url}?action=edituser&amp;id=$id">edit</a>&nbsp; <a href="#" onclick="if(window.confirm('$TEXT{Are_you_sure_you_want_to_delete_user} $username?')) { location.href='$ENV{SCRIPT_NAME}?action=commitdeleteuser&amp;id=$id'; } return false;">delete</a></td>`;
		}

		foreach my $field (sort { $a <=> $b } keys %custom_fields)
		{
			my $name = $custom_fields{$field}{name};
			my $value = enc_sql_select("SELECT `$name` FROM `$table` WHERE `id` = $id");
			$rows{$i}{$name} = qq`<td class="$name" $hidden_cells{$name}>$value</td>`;
		}

		$i++;
	}

	$i = 1;
	my $sortkey = $qs =~ /(?:^|&)sort=(\w+?)(?:&|$)/ ? $1 : 'ubusername';
	my $reverse = $qs =~ /(?:^|&)reverse=1(?:&|$)/ ? 1 : 0; # toggle the 1s and 0s to reverse by default or not.
	foreach my $row (sort { $reverse ? lc($rows{$b}{$sortkey}) cmp lc($rows{$a}{$sortkey}) : lc($rows{$a}{$sortkey}) cmp lc($rows{$b}{$sortkey}) } keys %rows)
	{
		my $oddeven = oddeven($i);
		my $status = $rows{$row}{active} ? 'active' : 'pending';
		print qq`<tr class="$oddeven $status">`;
		foreach my $column (sort { $a <=> $b } keys %columns)
		{
			print $rows{$row}{ $columns{$column}{name} };
		}
		print qq`</tr>\n`;
	}

	print qq`<tr class="` . oddeven($i) . qq`"><td colspan="20" style="font-style: italic;"><a href="$PREF{login_url}?action=adduser">Add User</a></td></tr>\n`;
	print qq`</table>\n</div>\n`;

	if(user_is_allowed_to($PREF{logged_in_userid}, 'view_all_accounts'))
	{
		print	  qq`<div class="table-footer-info">Accounts: `
			. qq`$num_active active`
			. qq` / $num_pending pending`
			. ' / ' . get_num_loggedin_users() . ' logged in'
			. qq`</div>\n`;
	}

	print qq`<p class="listug-letters">\n<a href="$PREF{login_url}?action=showusers&amp;which=all"` . ('all' eq lc($letter) ? ' class="current"' : undef) . qq`>All</a>`;
	foreach my $char ('A'..'Z')
	{
		print qq`<a href="$PREF{login_url}?action=showusers&amp;which=$char"` . ($char eq uc($letter) ? ' class="current"' : undef) . qq`>$char</a>`;
	}
	print qq`\n</p>`;

	print qq`

	<script type="text/javascript">

	function toggle_column(theclass)
	{
		var rows = document.getElementById('showusers').getElementsByTagName('tr');

		var cells = new Array;
		for(i = 0; i < rows.length; i++)
		{
			var headers = rows[i].getElementsByTagName('th');
			for(j = 0; j < headers.length; j++)
				if(headers[j].className == theclass)
					cells.push(headers[j]);

			var nonheaders = rows[i].getElementsByTagName('td');
			for(j = 0; j < nonheaders.length; j++)
				if(nonheaders[j].className == theclass)
					cells.push(nonheaders[j]);
		}
		for(i = 0; i < cells.length; i++)
		{
			if(cells[i].style.display == 'none')
			{
				cells[i].style.display = navigator.userAgent.indexOf("MSIE") ==  -1 ? 'table-cell' : 'block'; // IE doesn't support table-cell...
				document.getElementById("link-" + theclass).style.textDecoration = '';
			}
			else
			{
				cells[i].style.display = 'none';
				document.getElementById("link-" + theclass).style.textDecoration = 'line-through';
			}
		}
	}

	</script>

	`;

	finish_html_output();
}


sub get_num_loggedin_users
{
	my $num = 0;
	my $login_times = enc_sql_select_multi("SELECT `loggedin` FROM `$PREF{user_table}`");
	foreach my $i (keys %$login_times)
	{
		$num++ if $$login_times{$i}{loggedin} && !login_session_expired($$login_times{$i}{loggedin});
	}
	return $num;
}


sub get_num_accounts
{
	my ($num_active,$num_pending) = (0,0);
	my $userids = enc_sql_select_multi("SELECT `id` FROM `$PREF{user_table}`");
	foreach my $i (keys %$userids)
	{
		account_is_pending($$userids{$i}{id}) ? $num_pending++ : $num_active++;
	}
	return ($num_active,$num_pending);
}


# old group-management sub:
sub showgroups
{
	exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'view_all_groups');

	my $letter = $qs =~ /(?:^|&)which=([a-z])(?:&|$)/i ? $1 : $qs =~ /(?:^|&)which=all(?:&|$)/i ? 'all' : 'all';

	my $restriction = $letter eq 'all' ? undef : " WHERE LOWER(`group`) LIKE LOWER('$letter%') ";

	start_html_output("Manage Groups");
	print qq`<div class="listug" id="showgroups">\n<table>\n`;
	print qq`<tr class="header"><th>Group</th><th>Members</th><th class="desc">Description</th><th colspan="10">Actions</th>\n`;

	my ($id,$group,$desc,$members) = ();
	my $sth = $PREF{dbh}->prepare("SELECT `id`,`group`,`desc`, `members` FROM `$PREF{group_table}`${restriction}ORDER BY `group`");
	$sth->execute() or die_nice("$0: showgroups() failed: $DBI::errstr\n");
	$sth->bind_columns(\$id,\$group,\$desc,\$members);
	my $i = 1;
	while($sth->fetchrow_arrayref)
	{
		my @users = ();
		if($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i) # every account is automatically a member of these groups.
		{
			push @users, '(all)';
		}
		else
		{
			foreach my $uid (split(/,/, $members))
			{
				next unless $uid =~ /^\d+$/;
				my $username = get_user_name($uid);
				push @users, qq`<!-- $username --><a href="$PREF{login_url}?action=edituser&amp;id=$uid">$username</a>` if $username;
			}
		}

		my $group_display = is_builtin_group($group) ? "<strong>$group</strong>" : $group;

		print	  qq``
			. qq`<tr class="` . oddeven($i) . qq`">`
			. qq`<td>$group_display</td>`
			. qq`<td>`
			. (join '<br />', sort { lc($a) cmp lc($b) } @users)
			. qq`</td>`
			. qq`<td class="desc">$desc</td>`
			. qq`<td><a href="$PREF{login_url}?action=editgroup&amp;id=$id">edit</a></td>`
			. qq`<td><a href="$PREF{login_url}?action=deletegroup&amp;id=$id">delete</a></td>`
			. qq`</tr>`
			. qq`\n`;
	}

	print qq`<tr class="` . oddeven($i) . qq`"><td colspan="20" style="font-style: italic;"><a href="$PREF{login_url}?action=addgroup">Add Group</a></td></tr>\n`;
	print qq`</table>\n</div>\n`;

	print qq`<p class="listug-letters">\n<a href="$PREF{login_url}?action=showgroups&amp;which=all"` . ('all' eq lc($letter) ? ' class="current"' : undef) . qq`>All</a>`;
	foreach my $char ('A'..'Z')
	{
		print qq`<a href="$PREF{login_url}?action=showgroups&amp;which=$char"` . ($char eq uc($letter) ? ' class="current"' : undef) . qq`>$char</a>`;
	}
	print qq`\n</p>`;

	finish_html_output();
}


# new group-management sub:
sub show_groups_table
{
	my $tableprefname	= 'group_table';
	my $viewerprefname	= 'group';
	my $allowed_to_view	= user_is_allowed_to('view_all_groups');
	my $allowed_to_create	= user_is_allowed_to('create_groups');
	my $allowed_to_edit	= user_is_allowed_to('edit_group_info');
	my $allowed_to_delete	= user_is_allowed_to('delete_groups');




	$PREF{"${viewerprefname}_viewer_title"}					= 'Manage Groups';
	$PREF{"${viewerprefname}_viewer_template"}				= qq`\n<p>[ %%horizlink:text=Horizontal%% | %%vertlink:text=Vertical%% %%%if-viewall%%% | %%viewalllink:text=View All%% %%%end-viewall%%% ]</p>\n<br />\n%%output%%\n<p><em><strong>Mainmenu position</strong> controls the order that multiple mainmenus are displayed in, when the logged-in user belongs to multiple groups.</em></p><p>%%pagelinks%%</p>\n`;
	$PREF{"${viewerprefname}_viewer_item_name"}				= 'group';
	$PREF{"${viewerprefname}_viewer_hidden_columns"}			= 'id';
	$PREF{"${viewerprefname}_viewer_disabled_columns"}			= '';
	$PREF{"${viewerprefname}_viewer_uneditable_columns"}			= 'group,members';
	$PREF{"${viewerprefname}_viewer_uncreatable_columns"}			= 'members';
	$PREF{"${viewerprefname}_viewer_max_display_length"}			= 500;
	$PREF{"${viewerprefname}_viewer_itemsperpage"}				= 25;

	$PREF{"${viewerprefname}_viewer_style_horiz"}{desc}			= qq`text-align: left;`;
	$PREF{"${viewerprefname}_viewer_style_horiz"}{desc_header}		= qq`text-align: left;`;

	$PREF{"${viewerprefname}_viewer_extra_columns"}{edit_mainmenu}		= { position => '', value => '' };

	$PREF{"${viewerprefname}_creation_default_value"}{mainmenu_title}	= 'GroupName Links:';
	$PREF{"${viewerprefname}_creation_default_value"}{mainmenu_position}	= 1;

	$PREF{"${viewerprefname}_viewer_uneditable_values"}{group}{$PREF{public_group_name}}	= 1;
	$PREF{"${viewerprefname}_viewer_uneditable_values"}{group}{$PREF{member_group_name}}	= 1;
	$PREF{"${viewerprefname}_viewer_uneditable_values"}{group}{$PREF{admin_group_name}}	= 1;

	$PREF{"${viewerprefname}_viewer_unique_values_ignorecase"}{group}			= 1;

	$PREF{"${viewerprefname}_viewer_column_is_toggle"}{show_on_signup_page}			= 1;

	$PREF{"${viewerprefname}_viewer_display_value_if_null"}{members}			= '(none)';

	$PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{label_for_signup_page}	= 1;
	$PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{mainmenu_title}		= 1;
	$PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{mainmenu_position}		= 1;

	$PREF{"${viewerprefname}_viewer_undeletable_rows"}{group}{$PREF{public_group_name}}	= 1;
	$PREF{"${viewerprefname}_viewer_undeletable_rows"}{group}{$PREF{member_group_name}}	= 1;
	$PREF{"${viewerprefname}_viewer_undeletable_rows"}{group}{$PREF{admin_group_name}}	= 1;

	$PREF{"${viewerprefname}_viewer_title_transforms"}{desc}		= 'Description';

	$PREF{"${viewerprefname}_viewer_value_transforms"}{group}		= qq`%%variable%% = is_builtin_group(%%variable%%) ? "<strong>%%variable%%</strong>" : %%variable%%;`;

	$PREF{"${viewerprefname}_viewer_value_transforms"}{members}		= qq`

		if("%%group___raw%%" =~ /^($PREF{public_group_name}|$PREF{member_group_name})\$/i)
		{
			%%variable%% = '(all)';
		}
		else
		{
			my \$output = '';
			for(split(/,/,%%variable%%))
			{
				if(get_user_name(\$_))
				{
					\$output .= '<a href="$PREF{login_url}?action=edituser&amp;id=' . \$_ . '">' . get_user_name(\$_) . '</a><br />';
				}
			}
			%%variable%% = \$output;
		}
	`;


	$PREF{"${viewerprefname}_viewer_value_transforms"}{show_on_signup_page}	= qq`

		if(is_builtin_group("%%group___raw%%"))
		{
			%%variable%% = 'N/A';
		}
	`;


	$PREF{"${viewerprefname}_viewer_value_transforms"}{label_for_signup_page}	= qq`

		if(is_builtin_group("%%group___raw%%"))
		{
			%%variable%% = 'N/A';
		}
	`;


	$PREF{"${viewerprefname}_viewer_value_transforms"}{mainmenu_title}		= qq`

		if("%%group___raw%%" eq "$PREF{public_group_name}")
		{
			%%variable%% = 'N/A';
		}
	`;


	$PREF{"${viewerprefname}_viewer_value_transforms"}{mainmenu_position}		= qq`

		if("%%group___raw%%" eq "$PREF{public_group_name}")
		{
			%%variable%% = 'N/A';
		}
	`;



	$PREF{"${viewerprefname}_viewer_value_transforms"}{edit_mainmenu}		= qq`

		if("%%group___raw%%" eq "$PREF{public_group_name}")
		{
			%%variable%% = 'N/A';
		}
		else
		{
			#%%variable%% = '<a href="' . "$PREF{login_url}" . '?action=editmainmenu&amp;gid=%%id%%">' . "$TEXT{Edit_mainmenu}" . '</a>';

			%%variable%% = '<a href="$PREF{login_url}?action=editmainmenu&amp;gid=%%id%%">$TEXT{Edit_mainmenu}</a>'
		}

	`; 


	$PREF{"${viewerprefname}_viewer_value_verifications"}{group}		= '

		unless(groupname_is_valid(%%variable%%))
		{
			%%variable%% = qq`die_from_eval:$PREF{invalid_groupname_message}`;
		}

	';


	$PREF{"${viewerprefname}_creation_oncomplete_code"}			= 'create_mainmenu_table_for_group("%%group%%");';
	$PREF{"${viewerprefname}_deletion_oncomplete_code"}			= 'delete_mainmenu_table_for_group("%%group%%");';





	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub create_random_salt($)
{
	my $length = shift;
	my ($salt,$randchar) = ();
	while(length($salt) < $length)
	{
		$randchar = ();
		if($PREF{use_binary_salt} =~ /yes/i)
		{
			$randchar = int(rand(254)) while $randchar < 150;
		}
		else
		{
			$randchar = int(rand(125)) while ($randchar < 40   ||   $randchar == 92   ||   $randchar == 96);
		}
		$salt .= chr($randchar);
	}
	return $salt;
}


sub print_pwreset_page
{
	exit_with_error(qq`Disabled for trial version.`);
}


sub send_pwreset_email
{
	exit_with_error(qq`Disabled for trial version.`);
}


sub process_pwreset
{
	exit_with_error(qq`Disabled for trial version.`);
}


sub is_builtin_fieldname($)
{
	return 1 if $_[0] =~ /^(id|username|realname|name|email|password|oldpw|pw1|pw2|salt|cdate|loggedin|numusers|mrsession|failed_logins|ip|account_locked|account_disabled|forcepwchng|agreetoterms|group-.*)$/i;
}


sub add_or_edit_custom_fields($)
{
	exit_with_needprivs() unless user_is_allowed_to('add_custom_fields');

	my $mode = shift;
	my $go = $PREF{login_url};
	my $table_to_modify = $PREF{user_table};
	my $custom_field_list_table = $PREF{custom_field_table};

	if($ENV{REQUEST_METHOD} =~ /^post$/i)
	{
		my $query		= new CGI;
		my $fieldname		= param('fieldname');
		my $fieldlabel		= param('fieldlabel');
		my $datatype		= param('datatype');
		my $fieldtype		= param('fieldtype');
		my $fieldmax		= param('fieldmax');
		my $fieldposition	= param('fieldposition');
		my $mandatory		= param('mandatory');
		my $limitallowedchars	= param('limitallowedchars');
		my $allowedchars	= param('allowedchars');
		my $allowedcharsmsg	= param('allowedcharsmsg');
		my $listitems		= param('listitems');
		my $enabled		= param('enabled');

		# fix browser newlines.  this must be done before sanitization, because
		# \r will trip not_sqlsafe() during sanitization otherwise.
		#
		s/\r\n/\n/g for ($listitems, $allowedchars);
		s/\r/\n/g for ($listitems, $allowedchars);

		# sanitize values:
		#
		   if($fieldname =~ /[^\w]/ || length($fieldname) > 100 || !$fieldname)		{ kmsg_redirect($TEXT{e_fldname});	}
		elsif(is_builtin_fieldname($fieldname))						{ kmsg_redirect($TEXT{e_bltfld});	}
		elsif($mode eq 'add' && db_column_exists($fieldname, $table_to_modify))		{ kmsg_redirect($TEXT{e_fldexist});	}
		elsif(length($fieldlabel) > 255 || !$fieldlabel)				{ kmsg_redirect($TEXT{e_fldlabel});	}
		elsif($datatype !~ /^\w+$/ || length($datatype) > 100)				{ kmsg_redirect($TEXT{e_datatype});	}
		elsif($fieldtype !~ /^\w+$/ || length($fieldtype) > 100)			{ kmsg_redirect($TEXT{e_fieldtype});	}
		elsif($fieldposition && $fieldposition !~ /^\d+$/)				{ kmsg_redirect($TEXT{e_fieldpos});	}
		elsif(length($allowedcharsmsg) > 255)						{ kmsg_redirect($TEXT{e_alchrmsg});	}
		elsif($fieldtype =~ /^(dropdown|radio)$/ && !$listitems)			{ kmsg_redirect($TEXT{e_listitems});	}
		elsif(not_sqlsafe($fieldlabel))							{ $TEXT{e_sqlsafe} =~ s/%%fieldname%%/fieldlabel/g; kmsg_redirect($TEXT{e_sqlsafe}); }
		elsif(not_sqlsafe($allowedchars))						{ $TEXT{e_sqlsafe} =~ s/%%fieldname%%/allowedchars/g; kmsg_redirect($TEXT{e_sqlsafe}); }
		elsif(not_sqlsafe($allowedcharsmsg))						{ $TEXT{e_sqlsafe} =~ s/%%fieldname%%/allowedcharsmsg/g; kmsg_redirect($TEXT{e_sqlsafe}); }
		elsif(not_sqlsafe($listitems))							{ $TEXT{e_sqlsafe} =~ s/%%fieldname%%/listitems/g; kmsg_redirect($TEXT{e_sqlsafe}); }

		# adjust values:
		#
		$fieldmax = 255 if($fieldmax !~ /^\d+$/ || $fieldmax > 255);
		$fieldmax = '' unless $datatype eq 'varchar';
		$mandatory = $mandatory =~ /on/i ? 1 : 0;
		$limitallowedchars = $limitallowedchars =~ /on/i && $fieldtype =~ /^freeform/ ? 1 : 0;
		$listitems = '' unless $fieldtype =~ /^(dropdown|radio)/;
		$allowedchars = $allowedcharsmsg = '' unless $limitallowedchars;
		$enabled = $enabled =~ /on/i ? 1 : 0;

		# adjust position if necessary:
		#
		my $max_position = enc_sql_select("SELECT MAX(`fieldposition`) FROM `$custom_field_list_table`");
		$max_position = 0 unless $max_position =~ /^\d+$/;
		my $next_position = $max_position + 1;
		$fieldposition = $next_position unless $fieldposition =~ /^\d+$/;
		if($fieldposition < $next_position)
		{
			my $current_position = $max_position;
			while($current_position >= $fieldposition)
			{
				enc_sql_update("UPDATE `$custom_field_list_table` SET `fieldposition` = $current_position + 1 WHERE `fieldposition` = $current_position");
				$current_position--;
			}
			# now every field has been shifted up (increased fieldposition value) by 1 position,
			# and there is no field whose position is $fieldposition.
		}

		# get previous values in case we need to change them in the user table:
		my $prev_fieldname = '';
		my $prev_datatype = '';
		my $prev_fieldmax = '';
		if($mode eq 'edit')
		{
			my ($field_id) = ($qs =~ /(?:^|&)field_id=(\d+)(?:&|$)/);
			($prev_fieldname,$prev_datatype,$prev_fieldmax) = enc_sql_select("SELECT `fieldname`,`datatype`,`fieldmax` FROM `$custom_field_list_table` WHERE `id` = '$field_id'");
		}

		# final barebones pre-SQL checks for all items:
		if($fieldname !~ /^\w+$/)		{ die_nice("invalid fieldname '$fieldname'."); }
		if(not_sqlsafe($fieldlabel))		{ die_nice("invalid fieldlabel '$fieldlabel'."); }
		if($datatype !~ /^\w+$/)		{ die_nice("invalid datatype '$datatype'."); }
		if($fieldtype !~ /^\w+$/)		{ die_nice("invalid fieldtype '$fieldtype'."); }
		if($fieldmax !~ /^(\d+|)$/)		{ die_nice("invalid fieldmax '$fieldmax'."); }
		if($fieldposition !~ /^\d+$/)		{ die_nice("invalid fieldposition '$fieldposition'."); }
		if($mandatory !~ /^(0|1)$/)		{ die_nice("invalid mandatory '$mandatory'."); }
		if($limitallowedchars !~ /^(0|1)$/)	{ die_nice("invalid limitallowedchars '$limitallowedchars'."); }
		if(not_sqlsafe($allowedchars))		{ die_nice("invalid allowedchars '$allowedchars'."); }
		if(not_sqlsafe($allowedcharsmsg))	{ die_nice("invalid allowedcharsmsg '$allowedcharsmsg'."); }
		if(not_sqlsafe($listitems))		{ die_nice("invalid listitems '$listitems'."); }
		if($enabled !~ /^(0|1)$/)		{ die_nice("invalid enabled value '$enabled'."); }

		# untaint any items that can contain quotes or backslashes:
		sql_untaint($fieldlabel, $allowedchars, $allowedcharsmsg, $listitems);

		# add/update our listing about the custom field:
		if($mode eq 'add')
		{
			my $statement = "INSERT INTO `$custom_field_list_table` 
					       (`fieldname`, `fieldlabel`, `datatype`, `fieldtype`, `fieldmax`, `fieldposition`, `mandatory`, `limitallowedchars`, `allowedchars`, `allowedcharsmsg`, `listitems`, `enabled`) 
					VALUES('$fieldname','$fieldlabel','$datatype','$fieldtype','$fieldmax','$fieldposition', $mandatory,  $limitallowedchars, '$allowedchars','$allowedcharsmsg','$listitems','$enabled')";
			enc_sql_insert($statement);
		}
		else
		{
			my ($field_id) = ($qs =~ /(?:^|&)field_id=(\d+)(?:&|$)/);
			exit_with_error(qq`Error: missing field_id=N on the URL.`) unless $field_id;

			my $statement =	"UPDATE `$custom_field_list_table` SET
					`fieldname`		= '$fieldname',
					`fieldlabel`		= '$fieldlabel',
					`datatype`		= '$datatype',
					`fieldtype`		= '$fieldtype',
					`fieldmax`		= '$fieldmax',
					`fieldposition`		= '$fieldposition',
					`mandatory`		= $mandatory,
					`limitallowedchars`	= $limitallowedchars,
					`allowedchars`		= '$allowedchars',
					`allowedcharsmsg`	= '$allowedcharsmsg',
					`listitems`		= '$listitems',
					`enabled`		= '$enabled' 
					WHERE `id` = '$field_id'";

			my $success = enc_sql_update($statement);
			exit_with_error("SQL returned '$success' instead of '1' after executing statement: [[ $statement ]]") unless $success == 1;
		}


		if($mode eq 'add'   ||   !db_column_exists($fieldname, $table_to_modify))
		{
			my $whole_datatype = $datatype eq 'varchar' ? "$datatype($fieldmax)" : $datatype;
			my $statement = "ALTER TABLE `$table_to_modify` ADD `$fieldname` $whole_datatype";
			my $sth = $PREF{dbh}->prepare($statement);
			$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
		}
		else
		{
			if($fieldname ne $prev_fieldname)
			{
				my $prev_whole_datatype = $prev_datatype eq 'varchar' ? "$prev_datatype($prev_fieldmax)" : $prev_datatype;
				my $statement = "ALTER TABLE `$table_to_modify` CHANGE `$prev_fieldname` `$fieldname` $prev_whole_datatype";
				my $sth = $PREF{dbh}->prepare($statement);
				$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
			}
			if($datatype ne $prev_datatype   ||   $fieldmax ne $prev_fieldmax)
			{
				my $whole_datatype = $datatype eq 'varchar' ? "$datatype($fieldmax)" : $datatype;
				my $statement = "ALTER TABLE `$table_to_modify` MODIFY `$fieldname` $whole_datatype";
				my $sth = $PREF{dbh}->prepare($statement);
				$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
			}
		}


		enc_redirect("$go?action=addcustomfield");
	}
	else
	{
		my %vars = ();
		if($mode eq 'add')
		{
			$vars{form_title}			= $TEXT{Add_New_Field};
			$vars{button_label}			= $TEXT{Add_New_Field};
			$vars{form_action}			= 'addcustomfield';

		}
		elsif($mode eq 'edit')
		{
			($vars{field_id})			= ($qs =~ /(?:^|&)field_id=(\d+)(?:&|$)/);

			$vars{form_title}			= $TEXT{Edit_Custom_Field};
			$vars{button_label}			= $TEXT{Save_Changes};
			$vars{form_action}			= 'editcustomfield&amp;field_id=' . $vars{field_id};
		}

		start_html_output($TEXT{Custom_Fields});

		my $i = 0;
		print qq`<p>Use this page to create custom fields on your signup form.</p>\n`;
		print qq`<div class="listug" id="showcustomfields">\n<table>\n`;
		print qq`<tr class="header"><th>Name</th><th>Position</th><th>Status</th><th>Actions</th><th>Label</th><th>Data<br />type</th><th>Field<br />type</th><th>Max Length</th><th>Manda-<br />tory</th><th>Limit<br />Chars</th><th>Allowed<br />Chars</th><th>Allowed<br />Chars Msg</th><th>List<br />Items</th>\n`;

		my $field_DNE_error = qq`<br />(ERROR: <span title="this field does not exist in the user table; Edit to fix" class="def">DNE</span>)`;
		my ($id,$fieldname,$fieldlabel,$datatype,$fieldtype,$fieldmax,$fieldposition,$mandatory,$limitallowedchars,$allowedchars,$allowedcharsmsg,$listitems,$enabled) = ();
		my $sth = $PREF{dbh}->prepare("SELECT id,fieldname,fieldlabel,datatype,fieldtype,fieldmax,fieldposition,mandatory,limitallowedchars,allowedchars,allowedcharsmsg,listitems,enabled FROM `$custom_field_list_table` ORDER BY `fieldposition`");
		$sth->execute() or die "$0: Error: db_column_exists(): $DBI::errstr\n";
		$sth->bind_columns(\$id,\$fieldname,\$fieldlabel,\$datatype,\$fieldtype,\$fieldmax,\$fieldposition,\$mandatory,\$limitallowedchars,\$allowedchars,\$allowedcharsmsg,\$listitems,\$enabled);
		while($sth->fetchrow_arrayref)
		{
			my $field_exists_in_user_table = db_column_exists($fieldname, $table_to_modify);

			$fieldmax = 'N/A' unless $datatype eq 'varchar';

			print
				  qq`<tr class="` . oddeven($i) . qq`">`
				. qq`<td>$fieldname</td>`
				. qq`<td>$fieldposition</td>`
				. qq`<td>` . ($enabled ? 'enabled' : 'disabled') . ($field_exists_in_user_table ? '' : $field_DNE_error) . qq`</td>`
				. qq`<td><a href="$go?action=editcustomfield&amp;field_id=$id">$TEXT{Edit}</a><br /><a href="$go?action=deletecustomfield&amp;id=$id">$TEXT{Delete}</a></td>`
				. qq`<td>$fieldlabel</td>`
				. qq`<td>$datatype</td>`
				. qq`<td>$fieldtype</td>`
				. qq`<td>$fieldmax</td>`
				. qq`<td>` . ($mandatory ? 'yes' : 'no') . qq`</td>`
				. qq`<td>` . ($limitallowedchars ? 'yes' : 'no') . qq`</td>`
				. qq`<td>$allowedchars</td>`
				. qq`<td>$allowedcharsmsg</td>`
				. qq`<td>$listitems</td>`
				. qq`</tr>\n`;
		}
		print qq`<tr class="` . oddeven($i) . qq`"><td colspan="20">(None)</td></tr>` if $i == 0;
		print qq`</table>\n</div>\n`;



		if($mode eq 'add')
		{
			($id,$fieldname,$fieldlabel,$datatype,$fieldtype,$fieldmax,$fieldposition,$mandatory,$limitallowedchars,$allowedchars,$allowedcharsmsg,$listitems,$enabled) = ();
			$allowedcharsmsg = qq`Error: illegal character(s) in %%fieldname%% field; please go back and try again.`;
		}
		elsif($mode eq 'edit')
		{
			($id,$fieldname,$fieldlabel,$datatype,$fieldtype,$fieldmax,$fieldposition,$mandatory,$limitallowedchars,$allowedchars,$allowedcharsmsg,$listitems,$enabled) = enc_sql_select("SELECT id,fieldname,fieldlabel,datatype,fieldtype,fieldmax,fieldposition,mandatory,limitallowedchars,allowedchars,allowedcharsmsg,listitems,enabled FROM `$custom_field_list_table` WHERE `id` = '$vars{field_id}'");

			# browsers strip a single leading newline from textarea values upon submission, so add an extra if one is present.
			for($allowedchars,$listitems)
			{
				$_ = "\n$_" if /^\n/s;
			}
		}


		my $hide = qq`style="display: none;"`;

		print qq`
		<form method="post" action="$ENV{SCRIPT_NAME}?action=$vars{form_action}" id="customfieldform">
		<table class="custfields" id="addnewfield">
		<tr class="header"><th colspan="2">$vars{form_title}</th></tr>

		<tr class="` . oddeven($i) . qq`">
		<td class="label">Field name: <span class="notes">(e.g. "address", "phone_number")</span></td>
		<td><input type="text" class="default text required" name="fieldname" maxlength="100" value="$fieldname" /></td>
		</tr>

		<tr class="` . oddeven($i) . qq`">
		<td class="label">Field label: <span class="notes">(e.g. "Your Phone Number:")</span></td>
		<td><input type="text" class="default text required" name="fieldlabel" maxlength="255" value="$fieldlabel" /></td>
		</tr>

		<tr class="` . oddeven($i) . qq`">
		<td class="label">Data type:` . ($mode eq 'edit' ? qq` <span class="warning">(warning: changing the datatype may cause MySQL to convert, truncate, or otherwise alter any existing data in this field)</span>` : '') . qq`</span></td>
		<td>
			<select class="default select required" name="datatype" id="ub_datatype" onchange="show_hide_rows();" onblur="show_hide_rows();">
			<option value=""></option>
			<option value="text"	` . ($datatype eq 'text' ? qq`selected="selected"`	: '') . qq` >text</option>
			<option value="varchar"	` . ($datatype eq 'varchar' ? qq`selected="selected"`	: '') . qq` >short text (up to 255 characters) [varchar]</option>
			<option value="int"	` . ($datatype eq 'int' ? qq`selected="selected"`	: '') . qq` >whole number [int]</option>
			<option value="uint"	` . ($datatype eq 'uint' ? qq`selected="selected"`	: '') . qq` >whole number, non-negative [unsigned int]</option>
			<option value="float"	` . ($datatype eq 'float' ? qq`selected="selected"`	: '') . qq` >fractional number [float]</option>
			<option value="ufloat"	` . ($datatype eq 'ufloat' ? qq`selected="selected"`	: '') . qq` >fractional number, non-negative [unsigned float]</option>
			<option value="bool"	` . ($datatype eq 'bool' ? qq`selected="selected"`	: '') . qq` >true/false value [bool]</option>
			</select>
		</td>
		</tr>

		<tr class="` . oddeven($i) . qq`" id="ub_fieldmax_row" ` . ($datatype eq 'varchar' ? '' : $hide) . qq`>
		<td class="label">Field max length: <span class="notes">(1-255; only used if data type is "varchar")` . ($mode eq 'edit' ? qq` <span class="warning">(warning: changing the field max length may cause MySQL to convert, truncate, or otherwise alter any existing data in this field)</span>` : '') . qq`</span></td>
		<td><input type="text" class="default text" name="fieldmax" value="$fieldmax" /></td>
		</tr>

		<tr class="` . oddeven($i) . qq`">
		<td class="label">Field type:</td>
		<td>
			<select class="default select required" name="fieldtype" id="ub_fieldtype" onchange="show_hide_rows();" onblur="show_hide_rows();">
			<option value=""></option>
			<option value="freeformsingle"	` . ($fieldtype eq 'freeformsingle' ? qq`selected="selected"`	: '') . qq` >free-form text entry, single line</option>
			<option value="freeformmulti"	` . ($fieldtype eq 'freeformmulti' ? qq`selected="selected"`	: '') . qq` >free-form text entry, multi line</option>
			<option value="dropdown"	` . ($fieldtype eq 'dropdown' ? qq`selected="selected"`		: '') . qq` >drop-down list</option>
			<option value="checkbox"	` . ($fieldtype eq 'checkbox' ? qq`selected="selected"`		: '') . qq` >checkbox</option>
			<option value="radio"		` . ($fieldtype eq 'radio' ? qq`selected="selected"`		: '') . qq` >radio buttons</option>
			</select>
		</td>
		</tr>

		<tr class="` . oddeven($i) . qq`">
		<td class="label">Field position: <span class="notes">(its sort order relative to your other custom fields, e.g. 1, 2, 3... leave blank to use the next open spot)</span></td>
		<td><input type="text" class="default text" name="fieldposition" value="$fieldposition" /></td>
		</tr>

		<tr class="` . oddeven($i) . qq`" id="ub_mandatory_row" ` . ($fieldtype =~ /^checkbox/ ? $hide : '') . qq`>
		<td class="label">Mandatory? <span class="notes">(i.e. your users must select/fill in some value)</span></td>
		<td><input type="checkbox" class="checkbox" name="mandatory" ` . ($mandatory ? qq`checked="checked"` : '') . qq` /></td>
		</tr>

		<tr class="` . oddeven($i) . qq`" id="ub_limitallowedchars_row" ` . ($fieldtype =~ /^freeform/ ? '' : $hide) . qq`>
		<td class="label">Limit which characters are allowed? <span class="notes">(only for free-form fields; <span class="warning">strongly recommended</span>)</span></td>
		<td><input type="checkbox" class="checkbox" name="limitallowedchars" ` . ($limitallowedchars ? qq`checked="checked"` : '') . qq` /></td>
		</tr>

		<tr class="` . oddeven($i) . qq`" id="ub_allowedchars_row" ` . ($fieldtype =~ /^freeform/ ? '' : $hide) . qq`>
		<td class="label">Allowed characters: <span class="notes">(only for free-form fields; case-insensitive)</span></td>
		<td><textarea class="default text" name="allowedchars">` . ($allowedchars ? $allowedchars : $PREF{list_of_sql_safe_characters}) . qq`</textarea></td>
		</tr>

		<tr class="` . oddeven($i) . qq`" id="ub_allowedcharsmsg_row" ` . ($fieldtype =~ /^freeform/ ? '' : $hide) . qq`>
		<td class="label">Allowed characters message/error: <span class="notes">(only for free-form fields; e.g. "This field only accepts numbers and dashes")</span></td>
		<td><input type="text" class="default text" name="allowedcharsmsg" maxlength="255" value="$allowedcharsmsg" /></td>
		</tr>

		<tr class="` . oddeven($i) . qq`" id="ub_listitems_row" ` . ($fieldtype =~ /^(radio|dropdown)/ ? '' : $hide) . qq`>
		<td class="label">List items: <span class="notes">(only for dropdown and radio fields; enter one per line)</span></td>
		<td><textarea class="default text" name="listitems">$listitems</textarea></td>
		</tr>

		<tr class="` . oddeven($i) . qq`">
		<td class="label">Enabled:</td>
		<td><input type="checkbox" class="checkbox" name="enabled" ` . ($enabled || $mode eq 'add' ? qq`checked="checked"` : '') . qq` /></td>
		</tr>

		<tr class="` . oddeven($i) . qq`">
		<td class="submit ubbutton" colspan="2"><input type="button" value="$vars{button_label}" class="defaultbutton" onclick="submit_customfield_form()" /></td>
		</tr>

		</table>
		`;

		finish_html_output();
	}
}


#
# Precondition: check_username_for_sql_safeness($input_username).
#
sub account_exceeds_failed_login_limit
{
	my $input_username = $_[0];
	my $increment_failure_count = $_[1] eq 'increment' ? 1 : 0;

	my $failed_login_limit_exceeded = 0;

	if($PREF{lock_account_after_N_failed_logins} =~ /^\d+$/)
	{
		return unless enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE `username` = '$input_username';"); # account DNE.

		my ($recent_failed_attempts, $recent_failure_count) = ();

		if($increment_failure_count)
		{
			$recent_failed_attempts	= offsettime() . ',';
			$recent_failure_count	= 1;
		}

		my $failed_attempts = enc_sql_select("SELECT `failed_logins` FROM `$PREF{user_table}` WHERE `username` = '$input_username';");

		foreach my $failure_time (split(/,/, $failed_attempts))
		{
			if($PREF{failed_logins_within_N_secs_count_towards_lock} =~ /^\d+$/)
			{
				if(offsettime() - $failure_time < $PREF{failed_logins_within_N_secs_count_towards_lock})
				{
					$recent_failed_attempts .= $failure_time . ',';
					$recent_failure_count++;
				}
			}
			else # all failures are "recent", i.e. we don't care how long ago they occurred.
			{
				$recent_failed_attempts .= $failure_time . ',';
				$recent_failure_count++;
			}
		}

		decommaify($recent_failed_attempts);
		sql_untaint($recent_failed_attempts);
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `failed_logins` = '$recent_failed_attempts' WHERE `username` = '$input_username';");
		die_nice("Error: account_exceeds_failed_login_limit(input_username='$input_username'): SQL returned '$success' instead of '1' while updating failed_logins.") unless $success == 1;

		if($recent_failure_count >= $PREF{lock_account_after_N_failed_logins})
		{
			$failed_login_limit_exceeded = 1;
		}
	}

	return $failed_login_limit_exceeded;
}


sub print_payment_form($$)
{
	my $typeno = shift;
	my $uid = shift;

	my $template = $PREF{paid_account_payment_page_template};

	$template =~ s!%%userid%%!$uid!gis;
	$template =~ s!%%item_name%%!$PREF{"paid_account_type_${typeno}_paypal_item_name"}!gis;
	$template =~ s!%%item_number%%!$PREF{"paid_account_type_${typeno}_paypal_item_number"}!gis;
	$template =~ s!%%item_cost%%!$PREF{"paid_account_type_${typeno}_cost"}!gis;
	$template =~ s!%%item_desc%%!$PREF{"paid_account_type_${typeno}_groupdesc"}!gis;
	$template =~ s!%PREF{(\w+)}!$PREF{$1}!gis;

	start_html_output($PREF{paid_account_payment_page_title});
	print $template;
	finish_html_output();
}


sub print_payment_confirmation_page
{
	my $template = $PREF{confirm_payment_page_template};

	$template =~ s!%PREF{(\w+)}!$PREF{$1}!gis;

	start_html_output($PREF{confirm_payment_page_title});
	print $template;
	finish_html_output();
}


sub show_ipn_data
{
	exit_with_error("Access Denied.") unless $PREF{admin_is_logged_in};
	my ($id) = ($qs =~ /(?:^|&)id=(\d+)(?:&|$)/);
	die_unless_numeric($id, "ID");

	my @output = enc_sql_select("SELECT * FROM `$PREF{paypal_ipn_table}` WHERE `id` = $id");
	print_http_headers();
	foreach my $value (@output)
	{
		$value =~ s!_SPTR_!\n<br />!g;
		print qq`<p>$value</p>`;
	}
}


sub do_paypal_ipn()
{
	die_nice("\$PREF{enable_paid_accounts} is disabled.") unless $PREF{enable_paid_accounts} =~ /yes/i;

	# read post from PayPal system and add 'cmd'
	#
	my $ipn_query = '';
	read (STDIN, $ipn_query, $ENV{CONTENT_LENGTH});
	$ipn_query .= '&cmd=_notify-validate';

	# post back to PayPal system to validate
	#
	use LWP::UserAgent;
	my $ua = new LWP::UserAgent;
	my $req = new HTTP::Request 'POST','http://www.paypal.com/cgi-bin/webscr';
	# note: if you have SSL encryption Enabled, use <https://www.paypal.com/cgi-bin/webscr> above.

	$req->content_type('application/x-www-form-urlencoded');
	$req->content($ipn_query);
	my $res = $ua->request($req);


	if($res->is_error)
	{
		log_order_processing_error_and_die("HTTP error during IPN processing.");
	}
	elsif($res->content eq 'VERIFIED')
	{
		my %ipn_vars = ();
		foreach my $variable (split(/&/, $ipn_query))
		{
			my ($name, $value) = split(/=/, $variable);
			$value =~ tr/+/ /;
			$value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
			$ipn_vars{$name} = $value;
		}

		# check the $ipn_vars{payment_status} = Completed
		# check that $ipn_vars{txn_id} has not been previously processed
		# check that $ipn_vars{receiver_email} is an email address in your PayPal account
		# process payment

		# This is not visited by the buyer; it's visited by PayPal on the
		# backend, so displaying this data to the client here makes no sense.
		#
		## print to screen the following:
		#
		#print "Content-type: text/html\n\n";
		#print "<html><head><title>Payment Processed</title></head>\n";
		#print "<body>your email address is <b>$ipn_vars{payer_email}</b>\n";
		#print "<br>you paid <b>$ipn_vars{payment_gross}</b>\n";
		#print "<br>you paid for <b>$ipn_vars{item_name} / $ipn_vars{item_number}</b>\n";
		#print "<br>the value of custom was <b>$ipn_vars{custom}</b>\n";
		#print "<br>the status was <b>$res->content</b>\n";
		#print "<br>the note said <b>$ipn_vars{memo}</b>\n";
		#print "<br>the transaction id was <b>$ipn_vars{txn_id}</b>\n";
		#print "<br>the payment status was <b>$ipn_vars{payment_status}</b>\n";
		#print "<br><br><br>Full IPN Response:<br>\n";
		#foreach my $var (sort keys %ipn_vars)
		#{
		#	print "<br><br><b>$var</b>: $ipn_vars{$var}\n";
		#}
		#print "</body></html>\n";


		# Store transaction info to database:
		#
		my $all_ipn_vars = '';
		foreach my $var (sort keys %ipn_vars)
		{
			my $value = $ipn_vars{$var};
			s!\n_SPTR_\n!\n_SPTR-REPLACED_\n!g for ($var,$value);
			$all_ipn_vars .= "$var=$value\n_SPTR_\n";
		}

		my $date = offsettime();
		log_order_processing_error_and_die("non-numeric date for IPN") unless $date =~ /^\d+$/;

		my $date8 = strftime("%Y%m%d",localtime($date));
		log_order_processing_error_and_die("non-numeric date8 for IPN") unless $date8 =~ /^\d+$/;

		my $txn_id = $ipn_vars{txn_id};
		sql_untaint($txn_id);
		log_order_processing_error_and_die("not_sqlsafe(): \$txn_id value '$txn_id'.") if not_sqlsafe($txn_id);

		sql_untaint($all_ipn_vars);
		log_order_processing_error_and_die("not_sqlsafe(): \$all_ipn_vars value '$all_ipn_vars'.") if not_sqlsafe($all_ipn_vars);

		enc_sql_insert("INSERT INTO `$PREF{paypal_ipn_table}` (`date`,`date8`,`txn_id`,`allvars`) VALUES('$date', '$date8', '$txn_id', '$all_ipn_vars')");


				# date comes from PayPal as:
				#	payment_date=12:10:51 Oct 03, 2007 PDT
				#	payment_date=23:58:48 Feb 06, 2008 PST 
				#
				my($hour,$min,$sec,$month,$day,$year) = ($ipn_vars{payment_date} =~ /(\d\d):(\d\d):(\d\d)\s*(\w+)\s*(\d\d?),\s*(\d\d\d\d)/);
				$day = "0$day" if length($day) == 1;
				my $monthnum = $PREF{monthnum}{lc($month)};
				log_order_processing_error_and_die(qq`invalid monthnum "$monthnum"; is the \$PREF{monthnum} hash populated?`) unless $monthnum =~ /^\d+$/;
				my $paypal_date = timelocal($sec,$min,$hour,$day,($monthnum - 1),$year);
				log_order_processing_error_and_die("non-numeric ETime from PayPal IPN date") unless $paypal_date =~ /^\d+$/;

				my $paypal_date8 = $year . $monthnum . $day;
				log_order_processing_error_and_die("non-numeric date8 from PayPal IPN date") unless $paypal_date8 =~ /^\d+$/;

				my $transaction_cost = $ipn_vars{"mc_gross"};
				log_order_processing_error_and_die("invalid \$transaction_cost value '$transaction_cost'.") unless $transaction_cost =~ /^\d+(\.\d{2})?$/;

				my $item_number = $ipn_vars{item_number};
				sql_untaint($item_number);
				log_order_processing_error_and_die("not_sqlsafe(): \$item_number value '$item_number'.") if not_sqlsafe($item_number);

				my $item_name = $ipn_vars{item_name};
				sql_untaint($item_name);
				log_order_processing_error_and_die("not_sqlsafe(): \$item_name value '$item_name'.") if not_sqlsafe($item_name);

				my $userid = $ipn_vars{option_selection1};
				log_order_processing_error_and_die("non-numeric userid from IPN data") unless $userid =~ /^\d+$/;

				my $quantity = $ipn_vars{"quantity"};
				log_order_processing_error_and_die("non-numeric quantity from PayPal IPN") unless $quantity =~ /^\d+$/;

				my $buyer_email = $ipn_vars{payer_email};
				sql_untaint($buyer_email);
				log_order_processing_error_and_die("not_sqlsafe(): \$buyer_email value '$buyer_email'.") if not_sqlsafe($buyer_email);

				my $buyer_firstname = $ipn_vars{first_name};
				sql_untaint($buyer_firstname);
				log_order_processing_error_and_die("not_sqlsafe(): \$buyer_firstname value '$buyer_firstname'.") if not_sqlsafe($buyer_firstname);

				my $buyer_lastname = $ipn_vars{last_name};
				sql_untaint($buyer_lastname);
				log_order_processing_error_and_die("not_sqlsafe(): \$buyer_lastname value '$buyer_lastname'.") if not_sqlsafe($buyer_lastname);


				# Determine the type of account that was purchased:
				#
				my $typeno = '';
				my $item_number_valid = 0;
				foreach my $pref (sort keys %PREF)
				{
					if($pref =~ /^paid_account_type_(\d+)_paypal_item_number$/)
					{
						if($item_number eq $PREF{$pref})
						{
							$typeno = $1;
							$item_number_valid = 1;
							last;
						}
					}
				}


				# Verify that a valid item number was purchased:
				#
				log_order_processing_error_and_die("invalid item number '$item_number'.") unless $item_number_valid;


				# Verify that the payment/post data hasn't been tampered with, by
				# making sure the paid amount is correct for the selected account
				# type:
				#
				if($transaction_cost < $PREF{"paid_account_type_${typeno}_cost"})
				{
					log_order_processing_error_and_die(qq`invalid transaction cost '$transaction_cost'; must be at least $PREF{"paid_account_type_${typeno}_cost"} for item number '$item_number'.`);
				}


				# Log the sale in the payments table:
				#
				my $statement =   "INSERT INTO `$PREF{payments_table}` "
						. 		"(`date`, `date8`, `paypal_date`, `paypal_date8`, `item_number`, `item_name`, `quantity`, `transaction_cost`, `txn_id`, `userid`, `buyer_email`, `buyer_firstname`, `buyer_lastname`) "
						. "VALUES('$date', '$date8', '$paypal_date', '$paypal_date8', '$item_number', '$item_name', '$quantity', '$transaction_cost', '$txn_id', '$userid', '$buyer_email', '$buyer_firstname', '$buyer_lastname')";

				enc_sql_insert($statement);


				# Mark the account as paid by adding it to the appropriate group:
				#
				my $groupname = $PREF{"paid_account_type_${typeno}_groupname"};
				my $username = get_user_name($userid);
				add_user_to_group($username, $groupname);


				# Disable the pending_payment flag for the account:
				#
				if(account_is_pending_payment($userid))
				{
					enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_payment` = 0 WHERE `id` = $userid") == 1 or log_order_processing_error_and_die("SQL returned something other than 1 while trying to set pending_payment to 0.");
				}


		print_http_headers();
		exit;
	}
	elsif($res->content eq 'INVALID')
	{
		log_order_processing_error_and_die("IPN Returned INVALID.");
	}
	else
	{
		log_order_processing_error_and_die("unknown IPN error.");
	}
}


sub log_order_processing_debug_message
{
	my $msg = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname}: process ID=$$ \n$caller(): $msg`;

	my $subject = "Store order processing debug message (PID=$$)";

	foreach my $to (split(/\s*,\s*/, $PREF{payment_notification_email_recipients}))
	{
		send_email($to, $PREF{script_email_address}, $subject, $msg, 'text/plain', '');
	}
}


sub log_order_processing_error
{
	my $msg = shift;
	my $payer_email = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;

	my $subject = "Error during store order processing ($payer_email)";

	foreach my $to (split(/\s*,\s*/, $PREF{payment_notification_email_recipients}))
	{
		send_email($to, $PREF{script_email_address}, $subject, $msg, 'text/plain', '');
	}
}


sub log_order_processing_error_and_die
{
	my $msg = shift;
	my $payer_email = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;

	my $subject = "Error during store order processing ($payer_email)";

	foreach my $to (split(/\s*,\s*/, $PREF{payment_notification_email_recipients}))
	{
		send_email($to, $PREF{script_email_address}, $subject, $msg, 'text/plain', '');
	}

	print STDERR "$subject - $msg";

	$msg =~ s!<!&lt;!g;
	$msg =~ s!>!&gt;!g;
	$msg =~ s!\n!<br />\n!g;
	exit_with_error "$subject - $msg";
}


sub interpolate_userbase_variables($)
{
	my $string = shift;
	printd "interpolate_userbase_variables('$string')";
	$string =~ s/%%username%%/$PREF{logged_in_username}/g;
	$string =~ s/%%userid%%/$PREF{logged_in_userid}/g;
	$string =~ s/%PREF{(\w+)}/$PREF{$1}/g;
	$string =~ s/%%(\w+?)%%/enc_sql_select("SELECT `$1` FROM `$PREF{user_table}` WHERE `id` = $PREF{logged_in_userid}")/eg;
	return $string;
}


sub create_filechucker_userdir($)
{
	return unless $PREF{create_filechucker_userdir_on_account_creation} =~ /yes/i;
	my $username = shift;

	my $dir = $PREF{filechucker_userdir_folder};
	my $slash =   $PREF{DOCROOT} !~ m![/\\]$! && $dir !~ m!^[/\\]!   ? '/' : '';
	$dir = $PREF{DOCROOT} . $slash . $dir if $PREF{filechucker_userdir_folder_is_in_docroot};

	$slash =   $dir !~ m![/\\]$! && $username !~ m!^[/\\]!   ? '/' : '';
	$dir = $dir . $slash . $username;

	create_dir_if_DNE($dir,$PREF{writable_dir_perms},'make_parents');
}


# Note: this function's error messages should be written so that they
# don't display the name of the protected pages directory unless the
# visitor is an administrator.
#
sub display_protected_page($)
{
	my $page_to_display = shift;
	enc_urldecode($page_to_display);
	$page_to_display = enc_untaint($page_to_display,'keep_path');
	my ($page_to_display_base, $page_to_display_ext) = ($page_to_display =~ /(.+)\.(.+)/);
	my $page_full = $PREF{protected_pages_directory} . '/' . $page_to_display;

	# Allow pages to be found regardless of file extension or case.
	#
	opendir(my $dirh, $PREF{protected_pages_directory}) or $PREF{admin_is_logged_in} ? die_nice(qq`$PREF{internal_appname}: display_protected_page(): error: could not open directory \$PREF{protected_pages_directory} ("$PREF{protected_pages_directory}"): $!`) : die_nice(qq`$PREF{internal_appname}: display_protected_page(): error: could not open directory \$PREF{protected_pages_directory}: $!`);
	my @protectedpages = grep { -f "$PREF{protected_pages_directory}/$_" && !/^\./ } readdir $dirh;
	closedir $dirh or die_nice(qq`$PREF{internal_appname}: display_protected_page(): error: could not close directory \$PREF{protected_pages_directory}: $!`);
	foreach my $protectedpage (@protectedpages)
	{
		my ($protectedpage_base,$protectedpage_ext) = ($protectedpage =~ /(.+)\.(.+)/);
		if($protectedpage_base   &&   $page_to_display_base   &&   lc($protectedpage_base) eq lc($page_to_display_base))
		{
			$page_full = $PREF{protected_pages_directory} . '/' . $protectedpage_base . '.' . $protectedpage_ext;
			last;
		}
	}

	if(! -e $page_full)
	{
		if($PREF{admin_is_logged_in})
		{
			die_nice(qq`$PREF{internal_appname}: display_protected_page(): error: file does not exist: "$page_full"`);
		}
		else
		{
			die_nice(qq`$PREF{internal_appname}: display_protected_page(): error: file does not exist: "$page_to_display"`);
		}
	}

	my $allowed = 0;
	my $page_content = '';

	open(my $infh, $page_full) or die_nice(qq`$PREF{internal_appname}: display_protected_page(): error: could not open file "$page_to_display" for reading: $!`);
	flock $infh, 1;
	seek $infh, 0, 0;
	while(<$infh>)
	{
		if(/<!-- allowed_usernames=(.*?) -->/)
		{
			my $allowed_users = $1;
			$allowed_users =~ s!\s*,\s*!,!g; # in case they put any spaces around their commas.
			my %allowed_users = map { $_ => 1 } split(/,/, $allowed_users);
			$allowed = 1 if $allowed_users{$PREF{logged_in_username}};
		}
		elsif(/<!-- allowed_groups=(.*?) -->/)
		{
			my $allowed_groups = $1;
			$allowed_groups =~ s!\s*,\s*!,!g; # in case they put any spaces around their commas.
			foreach my $allowed_group (split(/,/, $allowed_groups))
			{
				$allowed = 1 if user_is_member_of_group($PREF{logged_in_userid},$allowed_group);
			}
		}
		else
		{
			$page_content .= $_;
		}
	}
	close($infh) or die_nice(qq`$PREF{internal_appname}: display_protected_page(): error: could not close file "$page_to_display" after reading: $!`);

	if($allowed)
	{
		print_http_headers();
		print $page_content;
	}
	else
	{
		if($PREF{member_is_logged_in})
		{
			exit_with_needprivs();
		}
		else
		{
			my $msg = $TEXT{Please_login_first_};
			enc_urlencode($msg);
			my $go = "$PREF{login_url}?phasemsg=$msg&whence=" . $ENV{REQUEST_URI};
			enc_redirect($go);
		}
	}
}


sub check_login()
{
	sleep $PREF{num_seconds_to_sleep_on_failed_login} unless $PREF{member_is_logged_in};
	my $group_memberships = '';
	my (@custom_fields, @custom_field_values) = ();

	if($PREF{member_is_logged_in})
	{
		my $groups = get_groups_hash($PREF{logged_in_userid});
		foreach my $group (sort keys %$groups)
		{
			$group_memberships .= $group . ',' if $$groups{$group}{is_member};
		}
		$group_memberships =~ s/,+$//;

		@custom_fields = get_custom_userbase_field_names($PREF{user_table});
		foreach my $customfield (@custom_fields)
		{
			my $value = enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}'");
			push @custom_field_values, $value;
		}
	}

	my $output = "admin=$PREF{admin_is_logged_in}:::::member=$PREF{member_is_logged_in}:::::username=$PREF{logged_in_username}:::::userid=$PREF{logged_in_userid}:::::group_memberships=${group_memberships}:::::realname=$PREF{logged_in_realname}:::::email=$PREF{logged_in_email}:::::";

	my $i = 0;
	foreach my $field (@custom_fields)
	{
		$output .= "${field}=$custom_field_values[$i]:::::";
		$i++;
	}

	$output .= "\n";

	if($qs =~ /print=false/)
	{
		return $output;
	}
	else
	{
		print_http_headers();
		print $output;
	}
}


sub do_web_config
{
	exit_with_error("This feature is disabled.") unless $PREF{enable_web_config} =~ /yes/i;


}


sub show_logins
{
	my $tableprefname	= 'logins_table';
	my $viewerprefname	= 'logins';
	my $allowed_to_view	= user_is_allowed_to('view_logins_log');
	my $allowed_to_create	= 0;
	my $allowed_to_edit	= user_is_allowed_to('edit_logins_log');
	my $allowed_to_delete	= user_is_allowed_to('delete_logins_log_records');


	$PREF{"${viewerprefname}_viewer_extra_columns"}{username}	= { position => 2, value => '' };
	$PREF{"${viewerprefname}_viewer_extra_columns"}{date}		= { position => 4, value => '' };

	$PREF{"${viewerprefname}_viewer_value_transforms"}{username}	= qq`%%variable%% = get_user_name(%%user_id%%) || '(deleted)';`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{date}	= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;


	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


sub show_failed_logins
{
	exit_with_error(qq`Disabled for trial version.`);
}


sub show_password_activity
{
	my $tableprefname	= 'password_activity_table';
	my $viewerprefname	= 'password_activity';
	my $allowed_to_view	= user_is_allowed_to('view_password_activity_log');
	my $allowed_to_create	= 0;
	my $allowed_to_edit	= user_is_allowed_to('edit_password_activity_log');
	my $allowed_to_delete	= user_is_allowed_to('delete_password_activity_log_records');


	$PREF{"${viewerprefname}_viewer_extra_columns"}{username}	= { position => 3, value => '' };
	$PREF{"${viewerprefname}_viewer_extra_columns"}{updater}	= { position => 8, value => '' };
	$PREF{"${viewerprefname}_viewer_extra_columns"}{date}		= { position => 6, value => '' };

	$PREF{"${viewerprefname}_viewer_title_transforms"}{updater}	= 'Updated by';
	$PREF{"${viewerprefname}_viewer_title_transforms"}{ip_address}	= "Updater's IP";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{hostname}	= "Updater's hostname";
	$PREF{"${viewerprefname}_viewer_title_transforms"}{browser}	= "Updater's browser";

	$PREF{"${viewerprefname}_viewer_value_transforms"}{username}	= qq`%%variable%% = get_user_name(%%user_id%%) || '(deleted)';`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{updater}	= qq`%%variable%% = %%user_who_did_update%% ? get_user_name(%%user_who_did_update%%) : "$TEXT{password_updater_special_cases}";`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{date}	= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;
	$PREF{"${viewerprefname}_viewer_value_transforms"}{salt}	= qq`%%variable%% =~ s/</&lt;/g; %%variable%% =~ s/>/&gt;/g;`;


	# Nothing below here should need to be edited in most cases:
	#
	# Call get_database_data() before starting any output in case we were POSTed
	# to and therefore we need to redirect instead of printing output.
	#
	my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
	start_html_output($PREF{"${viewerprefname}_viewer_title"});
	print $output;
	finish_html_output();
}


##############################################################################
### Shared-UB: ###############################################################
##############################################################################


sub load_external_prefs
{
	my ($script_basename) = ($ENV{SCRIPT_NAME} =~ m!.*?[/\\]?([^/\\]+)\.[^/\\\.]+!);
	my ($script_dirname) = ($ENV{SCRIPT_NAME} =~ m!^(.+)/.*?$!);
	my $prefs_basename = $_[0] eq 'use_internal_filename' ? $PREF{internal_filename} : $script_basename;

	my @prefs_files = (	"encodable_shared_prefs___overrideable",
				"${prefs_basename}_shared_prefs___overrideable",
				"${prefs_basename}_prefs_new",
				"${prefs_basename}_prefs",
				"${prefs_basename}_prefs_extra",
				"encodable_shared_prefs___nonoverrideable",
				"${prefs_basename}_shared_prefs___nonoverrideable",
	);

	my $critical_prefs_loaded = 0;
	foreach my $prefs_file (@prefs_files)
	{
		for($prefs_file,
			"$PREF{DOCROOT}/cgi-bin/$prefs_file",		"$PREF{DOCROOT}/../cgi-bin/$prefs_file",
			"$PREF{DOCROOT}/cgi/$prefs_file",		"$PREF{DOCROOT}/../cgi/$prefs_file",
			"$PREF{DOCROOT}$script_dirname/$prefs_file",	"$PREF{DOCROOT}/..$script_dirname/$prefs_file",

			# Also try the parent dir, mainly because it's a likely place for any shared prefs files:
			"$PREF{DOCROOT}$script_dirname/../$prefs_file",	"$PREF{DOCROOT}/..$script_dirname/../$prefs_file", "../$prefs_file"
		)
		{
			if(my $file = -e "${_}.cgi" ? "${_}.cgi" : -e "${_}.pl" ? "${_}.pl" : '')
			{
				my $prefs_contents = ();
				open(IN,"<$file") or die_nice("couldn't open prefs file '$file': $!");
				flock IN, 1;
				seek IN, 0, 0;
				while(<IN>) { $prefs_contents .= $_; }
				close IN or die_nice("couldn't close prefs file '$file': $!");
				$prefs_contents =~ /(.*)/s;
				$prefs_contents = $1; # cheap untaint since this is our own config file.
				eval $prefs_contents; die_nice("Error processing your prefs file ('$file'): $@") if $@;
				$critical_prefs_loaded = 1 unless $file =~ /_shared_prefs_/;
				last;
			}
		}
	}

	if(!$critical_prefs_loaded)
	{
		if($_[0] ne 'use_internal_filename')
		{
			# First pass failed, so try again but use $PREF{internal_filename} as the prefs base.
			load_external_prefs('use_internal_filename');
		}
		else
		{
			# Second pass failed too; nothing else we can do.
			die_nice("Error: couldn't find any prefs file to load.  You must put your $PREF{prefs_basename}_prefs.cgi file on the server with the $PREF{prefs_basename}.cgi file.");
		}
	}
}


sub load_userbase_prefs
{
	if($PREF{integrate_with_userbase} =~ /yes/i   &&   $PREF{internal_appname} !~ /^userbase$/i)
	{
		# Try to load UserBase prefs from userbase_prefs.cgi to avoid
		# having to specify common prefs twice.

		my %ub_pref_names = (
			database_hostname				=> 1,
			database_name					=> 1,
			database_username				=> 1,
			database_password				=> 1,
			dbi_connection_string				=> 1,

			site_session_cookie				=> 1,
			#login_url					=> 1,

			user_table					=> 1,
			group_table					=> 1,
			custom_field_table				=> 1,

			max_username_length				=> 1,
			max_groupname_length				=> 1,
			max_hashedpw_length				=> 1,

			allow_spaces_in_usernames			=> 1,
			allow_atsigns_in_usernames			=> 1,
			allow_dots_in_usernames				=> 1,
			allow_dashes_in_usernames			=> 1,

			allow_spaces_in_groupnames			=> 1,
			allow_atsigns_in_groupnames			=> 1,
			allow_dots_in_groupnames			=> 1,
			allow_dashes_in_groupnames			=> 1,

			idle_timeout					=> 1,
			num_days_rememberme_cookie_lasts		=> 1,
			enable_ip_address_restriction			=> 1,
			force_ip_address_restriction			=> 1,
			enable_forced_password_change			=> 1,
			admins_can_be_forced_to_change_their_own_pws	=> 1,

			subgroup_groupname_suffix			=> 1,
			groups_that_can_manage_subgroup_users		=> 1,
		);

		my $prefs_basename = $PREF{userbase_prefs_file_basename};
		my ($script_dirname) = ($ENV{SCRIPT_NAME} =~ m!^(.+)/.*?$!);
		my @prefs_files = ("${prefs_basename}_prefs_new.cgi", "${prefs_basename}_prefs_new.pl", "${prefs_basename}_prefs.cgi", "${prefs_basename}_prefs.pl", "${prefs_basename}_prefs_extra.cgi", "${prefs_basename}_prefs_extra.pl");
		push (@prefs_files, $PREF{userbase_prefs_file}) if $PREF{userbase_prefs_file}; # so we can specify it manually, including full path, if necessary.
		push (@prefs_files, $PREF{userbase_prefs_file_extra}) if $PREF{userbase_prefs_file_extra};
		my $prefs_loaded = 0;
		foreach my $prefs_file (@prefs_files)
		{
			for($prefs_file,
				"$PREF{DOCROOT}/cgi-bin/$prefs_file",		"$PREF{DOCROOT}/../cgi-bin/$prefs_file",
				"$PREF{DOCROOT}/cgi/$prefs_file",		"$PREF{DOCROOT}/../cgi/$prefs_file",
				"$PREF{DOCROOT}$script_dirname/$prefs_file",	"$PREF{DOCROOT}/..$script_dirname/$prefs_file"
			)
			{
				if(-e $_)
				{
					my $file = $_;
					open(IN,"<$file") or die_nice("couldn't open prefs file '$file': $!");
					flock IN, 1;
					seek IN, 0, 0;
					while(<IN>)
					{
						if(/^\$PREF{(\w+)}\s*=\s*/)
						{
							my $pref = $1;
							if($ub_pref_names{$pref})
							{
								eval $_; die_nice("Error processing your UserBase prefs file ('$file'): $@ <br /><br />\n\nYou should get UserBase running first, then return here.") if $@;
							}
						}
						elsif(/^\$TEXT{(\w+)}\s*=\s*/)
						{
							eval $_; die_nice("Error processing your UserBase prefs file ('$file'): $@ <br /><br />\n\nYou should get UserBase running first, then return here.") if $@;
						}
					}
					close IN or die_nice("couldn't close prefs file '$file': $!");
					$prefs_loaded = 1;
					last;
				}
			}
		}
		die_nice("Error: couldn't find any UserBase prefs file to load.  You must put your UserBase prefs file on the server with this script file.  This script will look in its own folder and the cgi-bin folder by default.  You can also add a new line to this script's prefs file setting \$PREF{userbase_prefs_file_extra} to the full filename (including path) of your UserBase prefs file.") unless $prefs_loaded;
	}
}


sub load_other_prefs_files
{
	my @other_prefs_files = ();
	foreach my $num (sort keys %{$PREF{other_prefs_files}})
	{
		my $name = $PREF{other_prefs_files}{$num}{shortcut_name};
		if($qs =~ /(?:^|&)prefs=$name(?:&|$)/)
		{
			my $file = $PREF{other_prefs_files}{$num}{shortcut_target};
			if($PREF{other_prefs_files_are_in_docroot} =~ /yes/i)
			{
				$file = "$PREF{DOCROOT}/$file";
				condense_slashes('leave_leading_UNC', $file);
			}
			die_nice("prefs file '$file' does not exist.") unless -e $file;
			push @other_prefs_files, $file;
		}
	}
	if($PREF{enable_other_prefs_files_with_filename_on_URL} =~ /yes/i)
	{
		while($qs =~ /(?:^|&)prefsfile=(.+?)(?:&|$)/g)
		{
			my $file = $1;
			if($PREF{other_prefs_filenames_from_URL_can_contain_paths} =~ /yes/i)	{ $file = enc_untaint($file, 'keep_path');	}
			else									{ $file = enc_untaint($file);			}
			if($PREF{other_prefs_files_are_in_docroot} =~ /yes/i)
			{
				$file = "$PREF{DOCROOT}/$file";
				condense_slashes('leave_leading_UNC', $file);
			}
			die_nice("prefs file '$file' does not exist.") unless -e $file;
			push @other_prefs_files, $file;
		}
	}
	foreach my $prefs_file (@other_prefs_files)
	{
		my $prefs_contents = ();
		open(IN,"<$prefs_file") or die_nice("couldn't open prefs file '$prefs_file': $!");
		flock IN, 1;
		seek IN, 0, 0;
		while(<IN>) { $prefs_contents .= $_; }
		close IN or die_nice("couldn't close prefs file '$prefs_file': $!");
		$prefs_contents =~ /(.*)/s;
		$prefs_contents = $1; # cheap untaint since this is our own config file.
		eval $prefs_contents; die_nice("Error processing your prefs file: $@") if $@;
	}
}


sub set_default_prefs_for_all_apps()
{
	# Prefs that are needed by all apps, and that are (at least by default) set
	# to the same values in all apps.  And we don't need any "unless exists"
	# tests here because this sub is called before loading external prefs.

	$PREF{list_of_sql_safe_characters} = qq`ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789 !#%^&*()_=+ ~ []{}| ;:'" ,.<>/? \`\@\$\r\n\t\\-`; # dash, if present, must be last.

	$PREF{max_tablename_length}			= 40;

	$PREF{site_session_cookie}			= 'site_session';
	$PREF{non_userbase_login_cookie}		= 'enc_non_ub_login';

	$PREF{public_group_name}			= 'public';
	$PREF{member_group_name}			= 'member';
	$PREF{admin_group_name}				= 'admin';

	$PREF{writable_dir_perms}			= 0777;
	$PREF{writable_file_perms}			= 0666;

	$PREF{here}					= $ENV{SCRIPT_NAME};
	$PREF{here_login}				= $ENV{SCRIPT_NAME};
}


sub load_webconfig_prefs
{

}


sub get_cookies()
{
	my %cookies = fetch CGI::Cookie;
	return %cookies;
}


sub get_cookie($)
{
	my $which = shift;
	my %jar = get_cookies();
	my $value = '';

	if(exists $jar{$which})
	{
		$value = $jar{$which}->value;
	}
	elsif($which eq $PREF{site_session_cookie})
	{
		if($qs =~ /(?:^|&)ubsessioncode=(\w+)(?:&|$)/)
		{
			my $code = $1;

			# Accepting the session code from the URL should only be allowed as a last resort.
			# On decent servers this shouldn't be necessary because we can call UserBase
			# from PHP using virtual() and/or exec() both of which pass the cookies.  Even
			# on sub-par servers where we have to use include() with the full http:// URL,
			# we can reduce the security risk by requiring the remote IP to match the server
			# IP, i.e. ONLY allow the include(http://...) method to work: don't accept URL-
			# based session codes from any other IP.  As a last resort on totally sucky
			# servers where PHP is crippled and $ENV{SERVER_ADDR} DNE or is variable or
			# otherwise useless, proceed only by setting a PREF that indicates what a bad
			# idea it is.

			if($ENV{REMOTE_ADDR} eq $ENV{SERVER_ADDR})
			{
				$value = $code;
			}
			elsif($PREF{my_server_sucks_so_use_less_secure_mode} =~ /yes/i)
			{
				sleep $PREF{sleeptime_for_less_secure_mode} || 3;
				$value = $code;
			}
		}
	}

	return $value;
}


sub set_cookie($$$)
{
	my $name = shift;
	my $value = shift;
	my $expiry = shift;
	my $cookie = undef;

	# This if/else is necessary because setting "expires" to "" isn't
	# the same as not setting it.  Setting it to "" is the same as 
	# setting it to zero, which expires the cookie immediately
	# (i.e., deletes it).  But explicitly *not* setting the expiry
	# causes the cookie to persist until the end of the session.
	if($expiry eq "")
	{
		$cookie = new CGI::Cookie(	-name    => $name,
						-value   => $value,
						-path    => '/');
	}
	else
	{
		$cookie = new CGI::Cookie(	-name    => $name,
						-value   => $value,
						-expires => $expiry,
						-path    => '/');
	}

	if($PREF{output_started})
	{
		print "<p>$PREF{internal_appname} warning: cannot set cookie '$name' => '$value' because the page output has already been started (perhaps debug is enabled?).</p>\n";
	}
	elsif($PREF{we_are_virtual})
	{
		print_http_headers();
		print "<p>$PREF{internal_appname} warning: cannot set cookie '$name' => '$value' because we are virtual.</p>\n";
	}
	else
	{
		print_p3p_header();
		print "Set-Cookie: $cookie\n";
	}
}


sub get_qs_var
{
	return enc_urldecode_return(   ($qs =~ /(?:^|&)$_[0]=([^&]*)/)[0]   );
}


sub expand_custom_vars_in_prefs
{
	my $hashref = shift;
	my $include_undefined = shift; $include_undefined = 0 unless $include_undefined eq 'include_undefined';

	# Execute this a few times without undefineds first, so that nested values can be
	# properly expanded (i.e. one setting contains %PREF{foo}, but $PREF{foo} itself
	# contains %PREF{bar}, etc).

	my $num_iterations = 5;
	for(my $i = 1; $i <= $num_iterations; $i++)
	{
		my $include_undefined_real = $include_undefined && $i == $num_iterations ? 1 : 0;

		foreach my $key (keys %$hashref)
		{
			if(ref($$hashref{$key}) eq 'HASH') # for prefs that are themselves hashes, i.e. $PREF{foo}{01} as in $PREF{foo}{01}{bar}.
			{
				expand_custom_vars_in_prefs($$hashref{$key});
			}
			else
			{
				# from now on, use %%varname%% instead of $$varname$$, so that it doesn't
				# matter whether it gets put in double-quotes.

				next unless $$hashref{$key} && $$hashref{$key} =~ /(\$\$|%%|%PREF{|%TEXT{|%URL{|%COOKIE{|%SQL{|%ENV{|%DATE{)/;
				next if $PREF{"${key}___skip_init_var_expansion"} =~ /yes/i;

				# old way:
				$$hashref{$key} =~ s/\$\$server_name\$\$/$ENV{'SERVER_NAME'}/g;
				$$hashref{$key} =~ s/\$\$httphost_withport\$\$/$ENV{'HTTP_HOST'}/g;
				$$hashref{$key} =~ s/\$\$name_of_site\$\$/$$hashref{'name_of_site'}/g;

				# new way:
				$$hashref{$key} =~ s/%%server_name%%/$ENV{SERVER_NAME}/g;
				$$hashref{$key} =~ s/%%http_host%%/$ENV{HTTP_HOST}/g;
				$$hashref{$key} =~ s/%%name_of_site%%/$$hashref{name_of_site}/g;

				#interpolate_vars_from_URL_and_cookies($include_undefined, $$hashref{$key});
				do_standard_template_vars_processing($include_undefined, $$hashref{$key});
			}
		}
	}
}


sub store_keyed_message
{
	my $new_message = shift;
	$new_message =~ s/\n/::ENCNL::/gs;

	my $one_day = 60*60*24*1;
	my $one_week = 60*60*24*7;
	my $current_time = offsettime();
	$PREF{max_age_for_keyed_messages} = $one_day unless $PREF{max_age_for_keyed_messages} =~ /^\d+/;

	my $key = md5_hex($new_message . $current_time . $$ . $ENV{REMOTE_PORT} . $ENV{REMOTE_ADDR} . $ENV{HTTP_USER_AGENT});
	my $uid = $PREF{logged_in_userid} =~ /^-?\d+$/ ? $PREF{logged_in_userid} : 0;

	my $mfile = add_initial_cwd_prefix($PREF{datadir} . '/' . "_$PREF{internal_appname}_keyed_messages.cgi");
	create_file_if_DNE($mfile,$PREF{writable_file_perms});
	my @messages = ();
	open(MFILE,"+<$mfile") or die_nice("could not open file '$mfile' for R/W: $!\n");
	flock MFILE, 2;
	seek MFILE, 0, 0;
	while(<MFILE>)
	{
		if(/^(\d+):/)
		{
			my ($time) = ($1);
			push (@messages,$_) if($time > ($current_time - $PREF{max_age_for_keyed_messages}));
		}
		elsif(/^[\s\n]*$/)
		{
			push (@messages, $_);
		}
	}
	seek MFILE, 0, 0;
	print MFILE @messages;
	print MFILE "${current_time}:${key}:${uid}:$ENV{REMOTE_ADDR}:$new_message\n\n\n"; # 3 newlines so the raw log is somewhat readable.
	truncate MFILE, tell MFILE;
	close MFILE or die_nice("could not close file '$mfile' after R/W: $!\n");

	return $key;
}


sub get_keyed_message
{
	my $key = shift;
	my $message = '';

	my $mfile = add_initial_cwd_prefix($PREF{datadir} . '/' . "_$PREF{internal_appname}_keyed_messages.cgi");
	create_file_if_DNE($mfile,$PREF{writable_file_perms});
	open(MFILE,"<$mfile") or die_nice("could not open file '$mfile' for reading: $!\n");
	flock MFILE, 1;
	seek MFILE, 0, 0;
	while(<MFILE>)
	{
		if(/^\d+:${key}:(-?\d+):([\d\.]+):(.*)/)
		{
			my ($uid_on_message,$ip_on_message,$msg) = ($1,$2,$3);
			if($PREF{admin_is_logged_in})
			{
				$message = $msg;
			}
			elsif($PREF{member_is_logged_in} && $PREF{logged_in_userid} eq $uid_on_message)
			{
				$message = $msg;
			}
			elsif($ENV{REMOTE_ADDR} eq $ip_on_message   &&   $uid_on_message =~ /^(0|-1)$/) # only allow IP-based auth if the owner is public.
			{
				$message = $msg;
			}
			else
			{
				$message = qq`Error: access denied based on userid and/or IP address.`;
			}
			last;
		}
	}
	close MFILE or die_nice("could not close file '$mfile' after reading: $!\n");

	$message =~ s/::ENCNL::/\n/gs;
	return $message || qq`Message expired.`;
}


# Never call chdir directly; always call enc_chdir instead:
sub enc_chdir($)
{
	my $dir = shift;
	$PREF{new_cwd} = $dir;
	chdir $dir or die_nice qq`Couldn't chdir to directory "$dir": $!\n`;
}


# This is necessary for cases where we've chdir()ed somewhere other than the
# $PREF{initial_cwd}, after which we want to use $PREF{datadir}, which by
# default is not in DOCROOT and contains no path -- it's relative to the
# initial working directory.
#
sub add_initial_cwd_prefix($)
{
	my $item = shift;
	if($PREF{new_cwd} ne $PREF{initial_cwd})
	{
		$item = $PREF{initial_cwd} . '/' . $item;
		condense_slashes('leave_leading_UNC', $item);
	}
	# return the input unchanged if we're still in the initial_cwd.
	return $item;
}


# pass filename to create and optionally the mode to chmod it to.
# the mode must consist of 1-4 octal digits and must NOT be quoted.
# see "perldoc -f chmod" and "man chmod".
sub create_file_if_DNE
{
	my $file = shift;
	my $mode = shift;

	return if -T $file;
	open(NEW,">$file") or die "$0: couldn't create new file $file: $!\n";
	close NEW or die "$0: couldn't close $file after creating it: $!\n";
	if($mode)
	{
		chmod($mode,$file) or die "$0: couldn't chmod file \"$file\" with mode \"$mode\": $!\n";
	}
}


sub create_dir_if_DNE
{
	my $dir = shift;
	my $mode = shift;
	my $make_parents_if_necessary = shift; $make_parents_if_necessary = $make_parents_if_necessary eq 'make_parents';
	my $ignore_errors = shift; $ignore_errors = $ignore_errors eq 'ignore_errors';

	return if -d $dir;

	$dir =~ s!\\!/!g;
	if($make_parents_if_necessary)
	{
		my $progressively_longer_path = '';
		my $i = 0;
		foreach my $individual_path_element(split(/\//, $dir))
		{
			$i++;
			if($i == 1)
			{
				if($dir =~ m!^(\w:/)!) # Winders.
				{
					$progressively_longer_path = $1;
					next;
				}
				elsif(!$individual_path_element) # this means $dir starts with a slash.
				{
					$progressively_longer_path = '/';
					next;
				}
			}

			$progressively_longer_path .= $individual_path_element;
			unless(-d $progressively_longer_path)
			{
				mkdir($progressively_longer_path,$PREF{writable_dir_perms}) or $ignore_errors || die_nice("couldn't create path-portion '$progressively_longer_path' as part of dir '$dir': $!");
				if($mode)
				{
					chmod($mode,$progressively_longer_path) or $ignore_errors || die_nice("couldn't chmod path-portion '$progressively_longer_path' as part of dir '$dir' with mode '$mode': $!");
				}
			}
			$progressively_longer_path .= '/';
		}
	}
	else
	{
		mkdir($dir,$PREF{writable_dir_perms}) or $ignore_errors || die_nice("couldn't create dir $dir: $!");
		if($mode)
		{
			chmod($mode,$dir) or $ignore_errors || die_nice("couldn't chmod dir \"$dir\" with mode \"$mode\": $!");
		}
	}

	$ignore_errors || die_nice qq`dir does not exist after creation: '$dir'` unless -d $dir;
}


sub mirror_dir_tree_and_contents($$)
{
	my ($src,$dst) = @_;
	for(@_) { die_nice qq`error: does not exist: '$_'` unless -e $_; die_nice qq`error: not a directory: '$_'` unless -d $_; }
	my ($files, $subfolders) = get_items($src);

	# start with the shortest pathname to ensure we create parents first.
	#
	foreach my $srcfolder (sort { length($a) <=> length($b) } @$subfolders)
	{
		my $mode = sprintf "%04o", (   (stat($srcfolder))[2] & 07777   );
		my $dstfolder = $dst . ($srcfolder =~ /^$src(.+)/)[0];
		mkdir($dstfolder, oct($mode)) or die_nice qq`Couldn't mkdir '$dstfolder' with mode '$mode': $!`;
		chmod(oct($mode), $dstfolder) or die_nice qq`Couldn't chmod dir '$dstfolder' with mode '$mode': $!`;
	}

	foreach my $srcfile (@$files)
	{
		my $mode = sprintf "%04o", (   (stat($srcfile))[2] & 07777   );
		my $dstfile = $dst . ($srcfile =~ /^$src(.+)/)[0];
		copy($srcfile, $dstfile) or die_nice qq`Couldn't copy source file '$srcfile' to destination file '$dstfile': $!`;
		chmod(oct($mode), $dstfile) or die_nice qq`Couldn't chmod file '$dstfile' with mode '$mode': $!`;
	}
}


# Note: we use "die" rather than "die_nice" throughout the send_email function,
# because most of the code is within eval{} blocks, so that we can catch the
# dies and then decide at the end what to do with them.
#
sub send_email
{
	my ($to, $from, $subj, $msg, $mimetype, $die_on_error, $attachment_hashref, $dont_fork) = @_;
	$mimetype = $mimetype =~ /html/i ? 'text/html' : 'text/plain';

	$die_on_error = $die_on_error eq 'die_on_email_error' ? 1 : 0;
	$dont_fork = $dont_fork eq 'dont_fork' ? 1 : 0;
	my $do_fork = !$die_on_error; # if we want to die on error, we can't fork, or the die() will go unreported.
	$do_fork = 0 if $^O =~ /MSWin32/; # Windows' fork-fu is weak.
	$do_fork = 0 if $dont_fork;

	my ($mail_sent_successfully, $error_msg) = 0;

        # fork here because sending mail can be slow (and can block) sometimes.
	# Note: if we don't set $do_fork, perl won't even evaluate the &&'s second
	# half, so the fork won't happen, and the else{} will.
	my $forkpid = ();
        if($do_fork   &&   ($forkpid = fork))
        {
                # parent
        }
        else 
        {
                # child

		use POSIX;

		if($do_fork)
		{
			defined $forkpid or die_nice "$PREF{internal_appname}: fork error in send_email(): $@\n";

			POSIX::setsid() unless $^O =~ /MSWin32/;
			close STDOUT;
			close STDIN;
		}

		my @enc_headers = ();
		unless($PREF{include_encodable_email_headers} =~ /no/i)
		{
			my $sentdate = strftime("%a%b%d,%Y,%I:%M%p",localtime(time + $PREF{time_offset}));

			my $remoteAddr = $ENV{REMOTE_ADDR};
			my $remoteHost = $ENV{REMOTE_HOST};
			if(!($remoteHost)) { $remoteHost = $remoteAddr; }
			if($remoteHost eq $remoteAddr)
			{
				use Socket;
				$remoteHost = gethostbyaddr(inet_aton($remoteAddr), AF_INET);
			}
			if(!($remoteHost)) { $remoteHost = $remoteAddr; }

			push @enc_headers, qq`X-Originator-IP: $remoteAddr`;
			push @enc_headers, qq`X-Originator-Host: $remoteHost`;
			push @enc_headers, qq`X-Originator-UA: $ENV{HTTP_USER_AGENT}`;
			push @enc_headers, qq`X-Encodable-Sitename: $ENV{HTTP_HOST}`;
			push @enc_headers, qq`X-Encodable-Header: website-visitor`;
			push @enc_headers, qq`X-Encodable-Sent: $sentdate`;
		}

		my $msgid = '<' . time . '.' . md5_hex($to . $from . $subj . $msg . $$ . $ENV{REMOTE_PORT}) . '@' . $ENV{HTTP_HOST} . '>';

		my $smtp_error = '';
		if($PREF{smtp_server})
		{
			# Wrap this in an eval{} in case MIME::Lite is missing.
			# Then we can have the option of setting $PREF{'disable_all_email'}
			# so that the site still functions, sans email.
			eval
			{
				require MIME::Lite;

				my $type = ();
				if($mimetype)
				{
					$type = $mimetype;
				}
				else
				{
					#my $type = $attachment_hashref ? 'multipart/mixed' : 'text/plain';
					$type = $attachment_hashref ? 'multipart/mixed' : 'text/plain; charset=ISO-8859-1; format=flowed';
				}

				my $mime_msg = MIME::Lite->new(To => $to, From => $from, Subject => $subj, Type => $type, Data => $msg);
				die "$PREF{internal_appname}: error creating MIME body: $!\n" unless($mime_msg);

				if($PREF{generate_message_id_internally} =~ /yes/i)
				{
					$mime_msg->add('Message-ID' => $msgid);
				}

				for(@enc_headers)
				{
					my ($name, $value) = split(/: /);
					$mime_msg->add($name => $value);
				}

				if($attachment_hashref)
				{
					foreach my $key (keys %$attachment_hashref)
					{
						my $mimetype			= $$attachment_hashref{$key}{mimetype}; # like 'application/x-gzip'
						my $filename			= $$attachment_hashref{$key}{filename};
						my $recommended_filename	= $$attachment_hashref{$key}{recommended_filename};

						$recommended_filename =~ s!^.*(\\|/)!!; # strip off any preceeding path

						# Attach the test file
						$mime_msg->attach(
							Type => $mimetype,
							Path => $filename,
							Filename => $recommended_filename,
							Disposition => 'attachment'
						) or die "$PREF{internal_appname}: error attaching file to email: $!\n";
					}
				}


				$PREF{smtp_server} = enc_untaint($PREF{smtp_server});
				if($PREF{smtp_auth_username} =~ /\S/ && $PREF{smtp_auth_password} =~ /\S/)
				{
					eval { MIME::Lite->send('smtp', $PREF{smtp_server}, Timeout=>30, AuthUser=>$PREF{smtp_auth_username}, AuthPass=>$PREF{smtp_auth_password}, Port=>$PREF{smtp_port}); };
				}
				else
				{
					eval { MIME::Lite->send('smtp', $PREF{smtp_server}, Timeout=>30, Port=>$PREF{smtp_port}); };
				}
				die "$PREF{internal_appname}: MIME::Lite->send failed: $@\n" if $@;

				eval { $mime_msg->send; };
				if($@)
				{
					die "$PREF{internal_appname}: \$mime_msg->send failed: $@\n";
				}
				else
				{
					$mail_sent_successfully = 1;
				}


				if($attachment_hashref)
				{
					foreach my $key (keys %$attachment_hashref)
					{
						unlink(  $$attachment_hashref{$key}{filename}  )   if   $$attachment_hashref{$key}{'delete-after-sending'} eq 'yes';
					}
				}
			};

			$smtp_error = $@;
		}

		my $sendmail_error = '';
		if($PREF{path_to_sendmail}   &&   !$mail_sent_successfully)
		{
			if($smtp_error) { warn "$PREF{internal_appname}: send_email(): SMTP failed, so falling back to sendmail.  SMTP error was: $smtp_error\n"; }

			eval
			{
				$PREF{path_to_sendmail} = enc_untaint($PREF{path_to_sendmail}, 'keep_path');

				open(SENDMAIL, "|$PREF{path_to_sendmail} -oi -t") or die "$PREF{internal_appname}: Can't fork for sendmail: $!\n";

				if($attachment_hashref)
				{
					print SENDMAIL	  qq`MIME-Version: 1.0`
							. qq`\nFrom: $from`
							. qq`\nTo: $to`
							. qq`\nSubject: $subj`
							. ($PREF{generate_message_id_internally} =~ /yes/i ? "\nMessage-Id: $msgid" : '')
							. (@enc_headers ? "\n" . (join "\n", @enc_headers) : '')
							. qq`\nContent-Type: multipart/mixed; boundary=encindboundarystring`
							. qq`\n`
							. qq`\n--encindboundarystring`
							. qq`\nContent-Type: ` . ($mimetype ? $mimetype : 'text/plain')
							. qq`\n`
							. qq`\n$msg`;

					foreach my $key (keys %$attachment_hashref)
					{
						my $mimetype			= $$attachment_hashref{$key}{mimetype}; # like 'application/x-gzip'
						$mimetype			= 'application/octet-stream' unless $mimetype;
						my $filename			= $$attachment_hashref{$key}{filename};
						my $recommended_filename	= $$attachment_hashref{$key}{recommended_filename};

						$recommended_filename =~ s!^.*(\\|/)!!; # strip off any preceeding path

						my $atch = `uuencode $filename $filename`;	# UUencode it so we can send it as an attachment

						print SENDMAIL	  qq`\n____________________`
								. qq`\nAttachment: $filename:`
								. qq`\n`
								. qq`\n--encindboundarystring`
								. qq`\nContent-Type: $mimetype; name="$filename"`
								. qq`\nContent-Transfer-Encoding: x-uuencode`
								. qq`\nContent-Disposition: attachment; filename="$recommended_filename"`
								. qq`\n`
								. qq`\n$atch`
								. qq`\n`
								. qq`\n--encindboundarystring`;
					}

					print SENDMAIL	  qq`\n--encindboundarystring--\n`
				}
				else # no attachment.
				{
					print SENDMAIL	  qq`From: $from`
							. qq`\nTo: $to`
							. qq`\nSubject: $subj`
							. ($PREF{generate_message_id_internally} =~ /yes/i ? "\nMessage-Id: $msgid" : '')
							. (@enc_headers ? "\n" . (join "\n", @enc_headers) : '')
							. qq`\nContent-Type: $mimetype`
							. qq`\n`
							. qq`\n$msg`;
				}

				close(SENDMAIL) or $PREF{die_on_sendmail_close_error} =~ /yes/i
						? die		"$PREF{internal_appname}: sendmail didn't close nicely: $!\n"
						: warn		"$PREF{internal_appname}: sendmail didn't close nicely: $!\n";
			};

			if($@)	{ $sendmail_error = $@;		}
			else	{ $mail_sent_successfully = 1;	}
		}

		my $blat_error = '';
		if($PREF{path_to_blat}   &&   $PREF{smtp_server}   &&   !$mail_sent_successfully)
		{
			printd "in blat loop...\n";
			if($sendmail_error) { warn "$PREF{internal_appname}: send_email(): sendmail failed, so trying blat.  sendmail error was: $sendmail_error\n"; }

			my $blat_output = '';
			eval
			{
				#$PREF{path_to_blat} = enc_untaint($PREF{path_to_blat}, 'keep_path');

				my $subj_for_blat = $subj;
				my $msg_for_blat = $msg;
				s!"!\\"!gs for ($subj_for_blat, $msg_for_blat);

				my $u	= "-u $PREF{smtp_auth_username}"	if $PREF{smtp_auth_username};
				my $pw	= "-pw $PREF{smtp_auth_password}"	if $PREF{smtp_auth_password};

				my ($debug,$x) = ('','');
				#$debug = "-debug";
				#$x = qq`-x "X-Custom-header: some header value..."`;

				$blat_output = `$PREF{path_to_blat} - -to $to -f $from -subject "$subj_for_blat" -body "$msg_for_blat" -server $PREF{smtp_server}:$PREF{smtp_port} $u $pw $debug $x`;

				printd "blat output: $blat_output\n";
			};

			if($@)	{ $blat_error = "$@.  Blat output was: $blat_output"; }
			else	{ $mail_sent_successfully = 1; }
		}

		unless($mail_sent_successfully)
		{
			if($smtp_error)		{ $error_msg .= "$PREF{internal_appname}: couldn't send email: error in send_email() while trying to use MIME::Lite with SMTP server '$PREF{smtp_server}'. Error was: '$smtp_error' <br /><br />\n\n"; }
			if($sendmail_error)	{ $error_msg .= "$PREF{internal_appname}: couldn't send email: error in send_email() while trying to use sendmail with path '$PREF{path_to_sendmail}'. Error was: '$sendmail_error' <br /><br />\n\n"; }
			if($blat_error)		{ $error_msg .= "$PREF{internal_appname}: couldn't send email: error in send_email() while trying to use blat with path '$PREF{path_to_blat}'. Error was: '$blat_error' <br /><br />\n\n"; }

			if(!$error_msg)		{ $error_msg .= "$PREF{internal_appname}: couldn't send email: error in send_email(): perhaps you need to adjust \$PREF{smtp_server} (currently '$PREF{smtp_server}') or \$PREF{path_to_sendmail} (currently '$PREF{path_to_sendmail}'). <br /><br />\n\n"; }

			$error_msg .= qq` [[ message details: to='$to', from='$from', subject='$subj' ]] <br /><br />\n\n`;

			if($die_on_error)	{ die_nice	$error_msg;	}
			else			{ warn		$error_msg;	}
		}

		if($do_fork)
		{
			exit; # exit the child process.
		}
	}

	return ($mail_sent_successfully, $error_msg);
}


sub enc_untaint
{
	my $item = shift || '';
	my $original_item = $item;
	my $keep_path = shift || '';
	#printd "enc_untaint($item)\n";

	# Regardless of whether we're keeping the path, dots surrounded by slashes are never allowed.
	#
	#$item =~ s!(^|/|\\)\.+(/|\\|$)!$1!g;
	$item =~ s!\\!/!g; # Need to remove MS garbage beforehand, otherwise an input like .\\StupidCGI.tmp will break this.
	while($item =~ m!((?:^|/|\\)\.+(?:/|\\|$))!)
	{
		$item =~ s!$1!/!;
	}

	#printd "removed slashdots: $item\n";

	if(  $item =~ m!(/|\\)!  &&  !$keep_path)
	{
		$item =~ s!^.*[/\\]+([^/\\]+)!$1!; # remove any path from the front.
		#printd "removed path from front: $item\n";
		$item =~ s!^([^/\\]+)[/\\]+!$1!; # ...and the back.
	}

	$item =~ s![`\*\?\|<>]!!g; # remove some other potentially-unsafe stuff.

	my $leading_UNC_slashes = '';
	if($item =~ m!^//!  &&  $keep_path)
	{
		$leading_UNC_slashes = '//';
		$item =~ s!^/+!!;
	}
	$item =~ s![/\\]{2,}!/!g; # condense any multiples.
	$item = $leading_UNC_slashes . $item; # add back any UNC slashes.

	($item) = ($item =~ /(.*)/); # untaint.

	# In case anything slips through, die as a security precaution.
	#
	die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m![/\\]! && !$keep_path;
	die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m!(?:^|/|\\)\.+(?:/|\\|$)!;
	die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m!^\.+$!;
	die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m!^\s*$!;

	#printd "untainted: $item\n\n";
	return $item;
}


sub enc_urlencode
{
	for(@_) { s/([^\w()'*~!.-])/sprintf '%%%02x', ord $1/eg if $_; };
}


sub enc_urldecode
{
	# assuming the input really was URL-encoded, then any plus-signs that were originally there
	# are now in their hex form, so any plus-signs STILL there were converted from spaces by the
	# browser.  so they must be converted back BEFORE restoring any original plus-signs from the
	# hex codes.
	convert_plus_signs_back_to_spaces_in_var_from_GET_method(@_);
	for(@_) { s/%([a-fA-F\d]{2})/chr hex $1/eg  if $_; }
}


sub enc_urlencode_return { my $string = shift; enc_urlencode($string); return $string; }
sub enc_urldecode_return { my $string = shift; enc_urldecode($string); return $string; }


sub convert_plus_signs_back_to_spaces_in_var_from_GET_method
{
	for(@_) { s/\+/ /g  if $_; }
}


sub enc_redirect
{
	my $destination = shift;

	if($destination =~ /^referr?er$/i)
	{
		$destination = $ENV{HTTP_REFERER} ? $ENV{HTTP_REFERER} : $PREF{redirection_backup_address};
	}

	unless($destination =~ m!^https?://!)
	{
		$destination = $PREF{protoprefix} . $ENV{HTTP_HOST} . $destination;
	}

	if($PREF{output_started})
	{
		if($PREF{use_javascript_redirect_when_necessary} !~ /no/i)
		{
			print qq`\n<script type="text/javascript">location.href="$destination";</script>\n`;
		}
		else
		{
			print qq`<p>$PREF{internal_appname} warning: cannot redirect because output has already started (perhaps debug is enabled?).&nbsp; <a href="$destination">Click here to continue</a>.</p>\n`;
		}
	}
	elsif($PREF{we_are_virtual})
	{
		if($PREF{use_javascript_redirect_when_necessary} !~ /no/i)
		{
			print_http_headers();
			print qq`\n<script type="text/javascript">location.href="$destination";</script>\n`;
		}
		else
		{
			warn "$0: enc_redirect(): cannot redirect because we are virtual.\n";
			print_http_headers();
			print qq`<p>$PREF{internal_appname} warning: cannot redirect because we are virtual.&nbsp; <a href="$destination">Click here to continue</a>.</p>\n`;
		}
	}
	else
	{
		if($ENV{SERVER_SOFTWARE} =~ /microsoft-iis/i || $PREF{always_use_meta_for_redirects} =~ /yes/i)
		{
			# A bug in IIS v5 (and lower, probably) makes cookie-setting fail
			# when combined with a header-based redirect:
			#
			#	"BUG: Set-Cookie Is Ignored in CGI When Combined With Location"
			#	http://support.microsoft.com/kb/q176113/
			#
			# So use a meta-redirect instead.
			#
			print "Content-type: text/html\n\n";
			print qq`<html><head><meta http-equiv="refresh" content="0;url=$destination"></head><body></body></html>\n`;
		}
		else
		{
			print "Location: $destination\n\n";
		}
	}

	exit;
}


sub kmsg_redirect
{
	# Any $PREF{extra_debug} will be lost on redirect unless we store it with the keyed message.
	enc_redirect(   ($PREF{here_static} || $PREF{here}) . "?kmsg=" . store_keyed_message($_[0] . get_extra_debug_output()) . $PREF{default_url_vars}   );
}


sub enc_redirect_to_ref
{
	# try to redirect to HTTP_REFERER, falling back to the URL
	# specified by ?whence=foo, then to any passed-in URL, and
	# finally to $PREF{here}.

	my $go = shift;
	if($ENV{HTTP_REFERER})
	{
		$go = $ENV{HTTP_REFERER};
	}
	elsif($qs =~ /(?:^|&)whence=(.+)/)
	{
		$go = $1;
		enc_urldecode($go);
	}
	$go = $PREF{here} if !$go;
	enc_redirect($go);
}


sub get_extra_debug_output
{
	if(	$PREF{extra_debug_always}
		||
		user_is_allowed_to('view_extra_debug_output')
		||
		($PREF{extra_debug_usernames_list} && $PREF{logged_in_username} &&   ($PREF{extra_debug_usernames_list} =~ /(^|,)\s*$PREF{logged_in_username}\s*(,|$)/))
		||
		($PREF{extra_debug_ips_list} &&   ($PREF{extra_debug_ips_list} =~ /(^|,)\s*$PREF{ip}\s*(,|$)/))
	)
	{
		my $style = $PREF{extra_debug_css} || qq`margin: 20px; padding: 10px; border: 1px solid #999; background: #ddd; color: #333; text-align: left;`;
		$PREF{extra_debug} =~ s/</&lt;/g;
		$PREF{extra_debug} =~ s/>/&gt;/g;
		$PREF{extra_debug} =~ s!\n! <br />\n!g;
		return qq`<div style="$style">$PREF{extra_debug}</div>\n`;
	}
}


sub condense_slashes
{
	s!\\!/!g;
	my $leave_leading_UNC = 0;
	for(@_)
	{
		if(/^leave_leading_UNC$/)
		{
			$leave_leading_UNC = 1;
			next;
		}
		if($leave_leading_UNC)
		{
			my $leading_UNC_slashes = '';
			if(m!^//!)
			{
				$leading_UNC_slashes = '//';
				s!^/+!!;
			}
			s!/{2,}!/!g; # condense any multiples.
			$_ = $leading_UNC_slashes . $_; # add back any UNC slashes.
		}
		else
		{
			s!/{2,}!/!g;
		}
	}
}


sub slashify	{   fooify('/', @_); }
sub deslashify	{ defooify('/', @_); }
sub commaify	{   fooify(',', @_); }
sub decommaify	{ defooify(',', @_); }
sub spaceify	{   fooify(' ', @_); }
sub despaceify	{ defooify(' ', @_); }


sub fooify
{
	# add leading and trailing foos and condense duplicates.
	my $foo = shift;
	$_ = $foo . $_ . $foo for @_;
	s!$foo{2,}!$foo!g for @_;
}


sub defooify
{
	# remove leading and trailing foos and condense duplicates.
	my $foo = shift;
	s!$foo{2,}!$foo!g for @_;
	s!^$foo!!g for @_;
	s!$foo$!!g for @_;
}


sub die_unless_numeric
{
	die_nice("error: non-numeric value '$_[0]' for $_[1]. [called from: " . (caller 1)[3]  . "]\n") unless $_[0] =~ /^\d+$/;
}


sub die_nice
{
	my $msg = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;
	exit_with_error($msg);
}


sub enc_warn
{
	# because some (lame) servers choke on warn() and/or on printing to STDERR,
	# in which case we can just null this sub.

	my $msg = shift;
	my $caller = (caller 1)[3];
	$caller =~ s/^main:://;
	$msg = qq`$PREF{internal_appname}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;
	warn $msg;
}


sub print_http_headers
{
	return if $PREF{output_started} || $PREF{xml_output_started};

	$PREF{output_started} = 1;

	# Don't print the P3P header from here normally, because we'll pick it up automatically
	# from the site's main .htaccess file.  The only time a script needs to explicitly
	# include it is when setting cookies (and possibly when delivering JS code which is
	# used to set cookies?).
	# 
	#print_p3p_header();

	my $noprint = shift;
	my $headers = '';
	$headers .= "Cache-Control: no-store, no-cache\n";
	$headers .= "Connection: close\n"; # workaround for a Safari bug that causes uploads to fail about 50% of the time.
	$headers .= "Content-type: text/html\n\n";
	$noprint ? return $headers : print $headers;
}


sub print_p3p_header
{
	# If you need to set third-party cookies, you'll need to use the P3P
	# privacy policy system, or else IE will reject the cookies.  The system
	# consists of a /w3c folder on your website containing a p3p.xml file
	# and a policy.html file, and then having your server send a P3P header,
	# both in the main .htaccess file and anytime a script needs to output
	# headers.  The value should be something like this:
	#
	#	$PREF{p3p_header} = qq`P3P: CP="ALL DSP COR NID", policyref="/w3c/p3p.xml"`;
	#
	# Or, you can leave off the policyref:
	#
	#	$PREF{p3p_header} = qq`P3P: CP="ALL DSP COR NID"`;
	#
	# You may want to use a service like http://p3pedit.com/ to create your
	# XML and privacy files.  And you can use www.w3.org/P3P/validator.html
	# to validate your setup.

	return if $PREF{p3p_header_printed};

	$PREF{p3p_header_printed} = 1;
	my $noprint = shift;
	my $headers = '';
	$headers .= "$PREF{p3p_header}\n" if $PREF{p3p_header};
	$noprint ? return $headers : print $headers;
}


sub offsettime
{
	return time + $PREF{time_offset};
}


sub sql_untaint
{
	s/"/&quot;/g for @_;
	s/'/&#39;/g for @_;
	s/`/&#96;/g for @_;
	s/\\/&#92;/g for @_;
}


sub sql_un_untaint
{
	s/&quot;/"/g for @_;
	s/&#39;/'/g for @_;
	s/&#96;/`/g for @_;
	s/&#92;/\\/g for @_;
}


sub enc_hash
{
	return $PREF{use_md5_for_hashes} =~ /yes/i ? md5_hex(@_) : sha1_hex(@_);
}


sub not_sqlsafe
{
	#print STDERR "not_sqlsafe: got: $_[0]\n";

	# Escape any dashes or closing brackets, as per perlre:
	#
	# 	If you want either "-" or "]" itself to be a member of a class,
	#	put it at the start of the list (possibly after a "^"), or escape
	#	it with a backslash.
	#
	my $list_of_sql_safe_characters = $PREF{list_of_sql_safe_characters};
	$list_of_sql_safe_characters =~ s/\]/\\]/g;
	$list_of_sql_safe_characters =~ s/-/\\-/g;

	return $_[0] =~ /[^$list_of_sql_safe_characters]/;
}


sub die_unless_sqlsafe
{
	#print STDERR "die_unless_sqlsafe: got: $_[0]\n";

	# Escape any dashes or closing brackets, as per perlre:
	#
	# 	If you want either "-" or "]" itself to be a member of a class,
	#	put it at the start of the list (possibly after a "^"), or escape
	#	it with a backslash.
	#
	my $list_of_sql_safe_characters = $PREF{list_of_sql_safe_characters};
	$list_of_sql_safe_characters =~ s/\]/\\]/g;
	$list_of_sql_safe_characters =~ s/-/\\-/g;

	for(@_)
	{
		if(/[^$list_of_sql_safe_characters]/)
		{
			exit_with_error(qq`Not SQL-safe: called from ` . (caller 1)[3] . qq`: the following value is not SQL-safe: $_`);
		}
	}
}


sub replace_nonsqlsafe_chars_with
{
	my $replacement = shift;

	# Escape any dashes or closing brackets, as per perlre:
	#
	# 	If you want either "-" or "]" itself to be a member of a class,
	#	put it at the start of the list (possibly after a "^"), or escape
	#	it with a backslash.
	#
	my $list_of_sql_safe_characters = $PREF{list_of_sql_safe_characters};
	$list_of_sql_safe_characters =~ s/\]/\\]/g;
	$list_of_sql_safe_characters =~ s/-/\\-/g;

	for(@_)
	{
		if(/[^$list_of_sql_safe_characters]/)
		{
			enc_warn "sanitizing the following non-SQL-safe value: $_\n";
			s/[^$list_of_sql_safe_characters]/$replacement/g;
		}
	}
}


sub oddeven
{
	$_[0] = 0 unless $_[0] && $_[0] =~ /^\d+$/;
	$_[0]++;
	return $_[1] && $_[1] eq 'reset' ? 'odd' : $_[0] % 2 == 0 ? 'even' : 'odd';
}


sub enc_sql_select($)
{
	verify_db_connection();
	my $statement = shift;
	my $sth = $PREF{dbh}->prepare($statement);
	$sth->execute() or die_nice("called from " . (caller 1)[3]  . ": error while executing SQL select statement [[$statement]]: $DBI::errstr\n");
	return $sth->fetchrow;
}


sub enc_sql_select_multi($)
{
	verify_db_connection();
	my $statement = shift;
	my $sth = $PREF{dbh}->prepare($statement);
	$sth->execute() or die_nice("called from " . (caller 1)[3]  . ": error while executing SQL select statement [[$statement]]: $DBI::errstr\n");
	my $i = 1;
	my %hash = ();
	my $rowhashref = '';
	while($rowhashref = $sth->fetchrow_hashref)
	{
		foreach my $field (keys %$rowhashref)
		{
			$hash{$i}{$field} = $$rowhashref{$field};
		}
		$i++;
	}
	return \%hash;
}


sub enc_sql_update($)
{
	verify_db_connection();
	my $statement = shift;
	my $sth = $PREF{dbh}->prepare($statement);
	my $numrows = $sth->execute() or die_nice("called from " . (caller 1)[3]  . ": error while executing SQL update statement [[$statement]]: $DBI::errstr\n");
	return $numrows;
}


sub enc_sql_insert($)
{
	verify_db_connection();
	my $statement = shift;
	my $sth = $PREF{dbh}->prepare($statement);
	$sth->execute() or die_nice("called from " . (caller 1)[3]  . ": error while executing SQL insert statement: $DBI::errstr.  Statement was: [[ $statement ]]\n");
}


sub enc_sql_delete($)
{
	verify_db_connection();
	my $statement = shift;
	my $sth = $PREF{dbh}->prepare($statement);
	my $retval = $sth->execute();
	die_nice("called from " . (caller 1)[3]  . ": error while executing SQL delete statement: $DBI::errstr.  Statement was: [[ $statement ]]\n") if $retval =~ /^(0|0E0)$/; # execute() returns '0E0' if no rows were affected by the statement.
}


sub enc_sys_call
{
	# TODO: this doesn't always work.

	my $cmd = shift;
	my ($msg,$success) = ();

	if(my $timeout = $PREF{sys_call_timeout})
	{
		eval
		{

		local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
		alarm $timeout;

		# Note: don't change this without changing the matching block below.
		system($cmd);
		if ($? == -1)		{ $success = 0; $msg = "error: failed to execute: $!"; }
		elsif ($? & 127)	{ $success = 0; $msg = sprintf "error: child died with signal %d, %s coredump", ($? & 127),  ($? & 128) ? 'with' : 'without'; }
		else			{ $success = 1; $msg = sprintf "child exited with value %d", $? >> 8; }

		};

		if($@)
		{
			if($@ eq "alarm\n")
			{
				# timed out.
				$success = 0; $msg = "error: timeout while executing: $!";
			}
			else
			{
				# propagate unexpected errors.
				$success = 0; $msg = "unexpected error while executing: $@";
			}
		}
		else
		{
			# didn't time out.
		}
	}
	else
	{
		# Note: don't change this without changing the matching block above.
		system($cmd);
		if ($? == -1)		{ $success = 0; $msg = "error: failed to execute: $!"; }
		elsif ($? & 127)	{ $success = 0; $msg = sprintf "error: child died with signal %d, %s coredump", ($? & 127),  ($? & 128) ? 'with' : 'without'; }
		else			{ $success = 1; $msg = sprintf "child exited with value %d", $? >> 8; }
	}

	$msg = "enc_sys_call(): command was [[ $cmd ]]; result was [[ $msg ]];";
	printd "$msg\n";

	$PREF{sys_call_timeout} = 0; # always reset this so it's disabled by default, and the caller can choose to set it before calling us if necessary.
	return ($success, $msg);
}


sub exit_with_success { exit_with___generic($PREF{success_message_template}, @_); } # Success messages that the end-user is supposed to see.
sub exit_with_notice { exit_with___generic($PREF{notice_message_template}, @_); } # Non-error messages that the end-user is supposed to see.
sub exit_with_error { exit_with___generic($PREF{error_message_template}, @_); } # Errors that the end-user is supposed to see.
sub exit_with_output { exit_with___generic('', @_); } # For any output; no template will be used.


sub exit_with___generic
{
	my $template = shift;
	my $message = join '', @_;
	#print STDERR $message;
	$template =~ s/%%message%%/$message/g;
	$message = $template =~ /\Q$message\E/ ? $template : $message; # in case prefs haven't been loaded yet.
	if(!$PREF{we_are_virtual} && $PREF{here} ne $ENV{SCRIPT_NAME} && $ENV{REQUEST_METHOD} =~ /post/i)
	{
		# 20081213: added method=post requirement; otherwise, if $PREF{here} is set to something other than
		# $ENV{SCRIPT_NAME}, then visiting the script directly will trigger this, which isn't what we want.
		# TODO: should method=post be the ONLY requirement for this if()?

		# Any $PREF{extra_debug} will be lost on redirect unless we store it with the keyed message.
		enc_redirect(   "$PREF{here}?kmsg=" . store_keyed_message($message . get_extra_debug_output())   );
	}
	else
	{
		start_html_output('');
		print $message;
		finish_html_output();
	}
	exit;
}


sub exit_with_kmsg
{
	start_html_output('');
	print get_keyed_message($_[0]);
	finish_html_output();
	exit;
}


sub exit_with_needlogin
{
	start_html_output('');
	$PREF{needlogin_message} =~ s/%%login_url%%/$PREF{login_url}/g;
	print $PREF{needlogin_message};
	finish_html_output();
	exit;
}


sub exit_with_needprivs
{
	my $login_url = '';
	if(userbase_available() || $PREF{integrate_with_existing_login_system} =~ /yes/i)
	{
		$login_url = $PREF{login_url};
	}
	else
	{
		$login_url = "$PREF{here_login}?action=" . ($PREF{internal_appname} =~ /visitorlog/i ? 'vllogin' : 'login');
	}
	$login_url .= ($login_url =~ /\?/ ? '&' : '?') . ($PREF{default_url_vars} ? "$PREF{default_url_vars}&" : "") . "whence=$PREF{REQ_URI_SANS_QS}" . ($qs ? "?$qs" : '');
	$login_url = "$PREF{protoprefix}$ENV{HTTP_HOST}$login_url" unless $login_url =~ /^https?:/;

	my $auto_redirect = qq`<script type="text/javascript">location.href="$login_url";</script>\n`;

	$PREF{needprivs_message} =~ s/%%login_url%%/$login_url/g;
	$PREF{needprivs_message} =~ s/%%js_auto_redirect%%/$PREF{member_is_logged_in} ? '' : $auto_redirect/eg;
	$PREF{needprivs_message} =~ s/%%%if-notloggedin%%%(.+?)%%%end-notloggedin%%%/$PREF{member_is_logged_in} ? '' : $1/egs;

	start_html_output('Authentication Required');
	print $PREF{needprivs_message};
	finish_html_output();
	exit;
}


sub printd
{
	my $msg = shift;
	chomp $msg;
	if($PREF{debug} || $PREF{force_debug} =~ /yes/i || $debuglog)
	{
		warn "$PREF{internal_appname}-debug: " . (offsettime()) . ": $msg\n";
		print $debuglog "$PREF{internal_appname}-debug: " . (offsettime()) . ": $msg\n" if $debuglog;
	}
	if($PREF{debug})
	{
		print_http_headers();
		print "<!-- $PREF{internal_appname}-debug: " . (offsettime()) . ": $msg -->\n";
	}
}


# Some SQL implementations support other nonsense in the table names; we'll restrict to a sensible set of characters.
#
sub tablename_is_valid				{ return ($_[0] =~ /^\w+$/	&&						length($_[0]) < $PREF{max_tablename_length});		} # FC, UB, VL
sub check_tablename_for_sql_safeness		{ die_nice("Invalid tablename: '$_[0]'") unless tablename_is_valid($_[0]); 								} # FC, UB, VL


sub get_db_connection
{
	eval { require DBI; }; die_nice qq`error while trying to load the DBI module.&nbsp; You probably need to <a href="http://encodable.com/perl_modules/" target="_blank">install the Perl module</a> for it.&nbsp; The error message was: <br /><br />\n\n $0: $@\n` if $@;
	if(!$PREF{dbh}   ||   $_[0] eq 'force')
	{
		my $dbname = $PREF{database_name};
		$dbname .= ":$PREF{database_hostname}" if $PREF{database_hostname};
		$PREF{dbi_connection_string} =~ s!%%dbname%%!$dbname!g;

		$PREF{dbh} = DBI->connect($PREF{dbi_connection_string}, $PREF{database_username}, $PREF{database_password})
				or exit_with_error("Error: $DBI::errstr <br /><br />\n\nPlease verify your settings for the following preferences: \$PREF{database_hostname}, \$PREF{database_name}, \$PREF{database_username}, \$PREF{database_password}.");

		# 20090425: there's a bug somewhere in the Perl MySQL stack which causes the
		# database connection to be silently dropped in some cases, resulting in the
		# Perl script simply dying (segfaulting?) when attempting to use the connection.
		# This happens even though mysql_auto_reconnect is enabled; disabling that
		# causes the script to die with the "MySQL server has gone away" error, instead
		# of dying silently.  Furthermore, with mysql_auto_reconnect enabled, the Perl
		# script will also segfault if you call $dbh->ping() after the connection has
		# been lost, making it totally worthless for its intended purpose.  The root
		# cause of this issue may be the following DBD-mysql bug:
		#
		#	http://rt.cpan.org/Public/Bug/Display.html?id=37027
		#
		# That bug report hasn't been updated since October of 2008, and the bug still
		# exists as of April 2009, so as a workaround, we'll disable mysql_auto_reconnect
		# and then always do a $dbh->ping() before every database communication.
		#
		$PREF{dbh}->{mysql_auto_reconnect} = 0;
	}
}


sub verify_db_connection
{
	get_db_connection('force') unless $PREF{dbh} && $PREF{dbh}->ping;
}


sub db_column_exists($$)
{
	my $column_to_find = shift;
	my $table_name = shift;

	check_tablename_for_sql_safeness($table_name);

	my ($column_name, $temp) = ('','');
	my $sth = $PREF{dbh}->prepare("SHOW COLUMNS FROM `$table_name`;");
	$sth->execute() or die_nice "$0: Error: db_column_exists(): $DBI::errstr\n";
	$sth->bind_columns(\$column_name, \$temp, \$temp, \$temp, \$temp, \$temp);
	while($sth->fetchrow_arrayref)
	{
		#print STDERR "column_name='$column_name', column_to_find='$column_to_find'\n";

		#return 1 if $column_name eq $column_to_find;
		#
		# MySQL returns a "Duplicate column name" error if you try to create a column
		# named (for example) "Color" when there's already one named "color":
		#
		return 1 if lc($column_name) eq lc($column_to_find);
	}
	return 0;
}


sub db_table_exists($)
{
	my ($table_to_check, $table, $table_exists) = (shift, '', 0);
	my $sth = $PREF{dbh}->prepare(qq`show tables;`);
	$sth->execute();
	$sth->bind_columns(\$table);
	while($sth->fetchrow_arrayref)
	{
		if($table eq $table_to_check)
		{
			$table_exists = 1;
			last;
		}
	}
	return $table_exists;
}


sub get_db_colnames($)
{
	my $table = shift;
	check_tablename_for_sql_safeness($table);
	my $colnames = '';
	my $column_name = '';
	my $temp = '';
	my $sth = $PREF{dbh}->prepare("SHOW COLUMNS FROM `$table`;");
	$sth->execute() or die_nice "$0: Error: db_column_exists(): $DBI::errstr\n";
	$sth->bind_columns(\$column_name, \$temp, \$temp, \$temp, \$temp, \$temp);
	while($sth->fetchrow_arrayref)
	{
		$colnames .= $column_name . ',';
	}
	$colnames =~ s/,$//;
	return $colnames;
}


sub get_ip_and_host
{
	my $ip = $ENV{REMOTE_ADDR};
	my $host = $ENV{REMOTE_HOST};

	if((!$host) || ($host !~ /\w\.\w/)) { $host = $ip; }
	if($host eq $ip)
	{
		use Socket;
		$host = gethostbyaddr(inet_aton($ip), AF_INET);
	}
	if((!$host) || ($host !~ /\w\.\w/)) { $host = $ip; }

	return ($ip, $host);
}


sub populate_month_conversion_hashes
{
	$PREF{monthnum}{jan}='01';
	$PREF{monthnum}{feb}='02';
	$PREF{monthnum}{mar}='03';
	$PREF{monthnum}{apr}='04';
	$PREF{monthnum}{may}='05';
	$PREF{monthnum}{jun}='06';
	$PREF{monthnum}{jul}='07';
	$PREF{monthnum}{aug}='08';
	$PREF{monthnum}{sep}='09';
	$PREF{monthnum}{oct}='10';
	$PREF{monthnum}{nov}='11';
	$PREF{monthnum}{dec}='12';

	$PREF{monthnum}{january}='01';
	$PREF{monthnum}{february}='02';
	$PREF{monthnum}{march}='03';
	$PREF{monthnum}{april}='04';
	$PREF{monthnum}{may}='05';
	$PREF{monthnum}{june}='06';
	$PREF{monthnum}{july}='07';
	$PREF{monthnum}{august}='08';
	$PREF{monthnum}{september}='09';
	$PREF{monthnum}{october}='10';
	$PREF{monthnum}{november}='11';
	$PREF{monthnum}{december}='12';

	$PREF{monthname}{"01"} = 'Jan';
	$PREF{monthname}{"02"} = 'Feb';
	$PREF{monthname}{"03"} = 'Mar';
	$PREF{monthname}{"04"} = 'Apr';
	$PREF{monthname}{"05"} = 'May';
	$PREF{monthname}{"06"} = 'Jun';
	$PREF{monthname}{"07"} = 'Jul';
	$PREF{monthname}{"08"} = 'Aug';
	$PREF{monthname}{"09"} = 'Sep';
	$PREF{monthname}{"10"} = 'Oct';
	$PREF{monthname}{"11"} = 'Nov';
	$PREF{monthname}{"12"} = 'Dec';
}


sub save_php_var_to_cache($$)
{
	my $new_var = shift;
	my $new_value = shift;
	my $new_date = offsettime();
	my $new_sessid = get_cookie($PREF{php_session_cookie_name});
	return unless $new_sessid; # if there's no sessionid, we have no way to index into the cache file.
	for($new_var, $new_value, $new_date, $new_sessid)
	{
		s/:::::/ENCFIVECOLONS/g;
		s/\n/ENCNEWLINE/g;
	}
	my ($session_found, $var_found) = ();

	create_file_if_DNE($PREF{php_session_cache_file},$PREF{writable_file_perms});
	my @new_contents = ();
	open(CACHEFH,"+<$PREF{php_session_cache_file}") or die_nice("$PREF{internal_appname}: save_php_var_to_cache('$new_var', '$new_value'): couldn't open cache file '$PREF{php_session_cache_file}' for R/W: $!\n");
	my $iofh = \*CACHEFH;
	flock $iofh, 2;
	seek $iofh, 0, 0;
	while(<$iofh>)
	{
		if(/^date=(\d+?):::::sessid=(\w+?):::::.+/)
		{
			chomp;
			my ($date, $sessid) = ($1, $2);
			if($new_date - $date < $PREF{php_session_cache_ttl})
			{
				if($sessid ne $new_sessid)
				{
					# If this record doesn't belong to the current user, don't bother processing it.
					push (@new_contents, "$_\n");
				}
				else
				{
					$session_found = 1;
					my $new_line = "date=${date}:::::sessid=${sessid}:::::";
					foreach my $var (split(/:::::/))
					{
						my ($name,$value) = ($var =~ /(\w+)=(.*)/);
						next if $name =~ /^(date|sessid)$/i;
						if($name eq $new_var)	{ $new_line .= "$name=${new_value}:::::"; $var_found = 1; }
						else			{ $new_line .= "$name=${value}:::::"; }
					}
					$new_line .= "$new_var=${new_value}:::::" if !$var_found;
					push (@new_contents, "$new_line\n");
				}
			}
		}
	}
	push (@new_contents, "date=${new_date}:::::sessid=${new_sessid}:::::$new_var=${new_value}:::::\n") if !$session_found;
	seek $iofh, 0, 0;
	print $iofh @new_contents;
	truncate $iofh, tell $iofh;
	close $iofh or die_nice("$PREF{internal_appname}: save_php_var_to_cache('$new_var', '$new_value'): couldn't close cache file '$PREF{php_session_cache_file}' after R/W: $!\n");
}


sub get_php_var_from_cache($)
{
	my $new_var = shift;
	my $new_value = '';
	my $new_date = offsettime();
	my $new_sessid = get_cookie($PREF{php_session_cookie_name});
	return unless $new_sessid; # if there's no sessionid, we have no way to index into the cache file.
	for($new_var, $new_value, $new_date, $new_sessid)
	{
		s/:::::/ENCFIVECOLONS/g;
		s/\n/ENCNEWLINE/g;
	}

	create_file_if_DNE($PREF{php_session_cache_file},$PREF{writable_file_perms});
	open(CACHEFH,"<$PREF{php_session_cache_file}") or die_nice("$PREF{internal_appname}: get_php_var_from_cache('$new_var'): couldn't open cache file '$PREF{php_session_cache_file}' for reading: $!\n");
	my $infh = \*CACHEFH;
	flock $infh, 1;
	seek $infh, 0, 0;
	while(<$infh>)
	{
		if(/^date=(\d+?):::::sessid=(\w+?):::::.+/)
		{
			my ($date, $sessid) = ($1, $2);
			if($new_date - $date < $PREF{php_session_cache_ttl}   &&   $sessid eq $new_sessid)
			{
				if(/(?:^|:::::)$new_var=(.*?)(?::::::|$)/) { $new_value = $1; }
			}
		}
	}
	close $infh or die_nice("$PREF{internal_appname}: get_php_var_from_cache('$new_var'): couldn't close cache file '$PREF{php_session_cache_file}' after reading: $!\n");
	return $new_value;
}


sub do_email_test
{
	my $to		= $PREF{email_test_recipient};
	my $from	= $PREF{email_test_sender};
	my $subj	= 'test message - ' . time;
	my $format	= $PREF{mailtest_email_format} || $PREF{global_email_format};
	my $die		= 'die_on_email_error';

	my $authname	= $PREF{smtp_auth_username} ? 'not null' : 'null';
	my $authpass	= $PREF{smtp_auth_password} ? 'not null' : 'null';

	eval { require MIME::Lite; };
	my $mimelite_available = $@ ? "it's not" : "it is";

	my $sendmail_available = -e $PREF{path_to_sendmail} ? "it does" : "it doesn't";

	my $msg		= qq`this is only a test.
email settings:
\$PREF{smtp_server}		='$PREF{smtp_server}'
\$PREF{path_to_sendmail}	='$PREF{path_to_sendmail}'
\$PREF{smtp_auth_username}	is $authname.
\$PREF{smtp_auth_password}	is $authpass.
`;

	send_email($to, $from, $subj, $msg, $format, $die);

	exit_with_notice(qq`Sent test message from "$from" to "$to"; no immediate error occurred. <br /><br />\n\nIf the MIME::Lite Perl module is installed ($mimelite_available) and if \$PREF{smtp_server} is not null (it's "$PREF{smtp_server}"), then we tried to send the email using SMTP. <br /><br />\n\nIf your sendmail executable exists ($sendmail_available) (specified by \$PREF{path_to_sendmail}, currently "$PREF{path_to_sendmail}"), then we tried to send the email using sendmail, too.`);
}


sub add_text_to_file($$$)
{
	# Note: this function doesn't automatically insert any newlines; it
	# only inserts precisely what it receives in the $text parameter.

	my ($text, $file, $position) = @_;
	open(my $iofh, "+<$file") or die_nice "$PREF{internal_appname}: add_text_to_file(): couldn't open file '$file' for R/W: $!\n";
	flock $iofh, 2;

	if($position eq 'start')
	{
		seek $iofh, 0, 0;
		my @contents = <$iofh>;
		seek $iofh, 0, 0;
		print $iofh $text;
		print $iofh @contents;
	}
	else
	{
		seek $iofh, 0, 2;
		print $iofh $text;
	}

	truncate $iofh, tell $iofh;
	close $iofh or die_nice "$PREF{internal_appname}: add_text_to_file(): couldn't close file '$file' after R/W: $!\n";
}


sub get_database_data
{
	$PREF{on_page} = 'default';
	my ($tableprefname,$viewerprefname,$allowed_to_view,$allowed_to_create,$allowed_to_edit,$allowed_to_delete) = @_;
	my $dbtable = $PREF{$tableprefname} || $tableprefname; # "$tableprefname" can be the name of the pref OR of the table.
	my $createmode = 0;
	my $editmode = 0;
	my $row_id_to_edit = 0;

	exit_with_needprivs() unless $allowed_to_view;

	if((my $ref = $ENV{HTTP_REFERER}) && $qs !~ /(?:^|&)dbvwrwhence=.+/)
	{
		$ref =~ s!\?!_encrplcdqm_!g;
		$ref =~ s!&!_encrplcdamp_!g;
		$ref =~ s!^https?://!!;
		$ref =~ s!^$ENV{HTTP_HOST}!!;
		$ref .= '_dbvwrwhncend_';
		$qs .= "&dbvwrwhence=$ref";
		$ENV{REQUEST_URI} .= $ENV{REQUEST_URI} =~ /\?/ ? "&dbvwrwhence=$ref" : "?dbvwrwhence=$ref"
	}
	if($qs =~ /(?:^|&)dbvwrwhence=(.+)_dbvwrwhncend_/)
	{
		$PREF{dbvwrwhence} = $1;
		$PREF{dbvwrwhence} =~ s!_encrplcdqm_!?!g;
		$PREF{dbvwrwhence} =~ s!_encrplcdamp_!&!g;
	}

	my $hiddencols		= $PREF{"${viewerprefname}_viewer_hidden_columns"};
	my $disabledcols	= $PREF{"${viewerprefname}_viewer_disabled_columns"};
	my $display_length	= $PREF{"${viewerprefname}_viewer_max_display_length"};
	my $pagetitle		= $PREF{"${viewerprefname}_viewer_title"};
	my $template		= $PREF{"${viewerprefname}_viewer_template"} || die_nice qq`Error: no template; ${viewerprefname}_viewer_template is null.`;
	my $itemsperpage	= $PREF{"${viewerprefname}_viewer_itemsperpage"} || 10;
	my $extra_columns	= \%{$PREF{"${viewerprefname}_viewer_extra_columns"}};
	my $title_transforms	= \%{$PREF{"${viewerprefname}_viewer_title_transforms"}};
	my $value_transforms	= \%{$PREF{"${viewerprefname}_viewer_value_transforms"}};
	my %custom_titles	= ();

	# extra_columns have a position within the displayed table, and a value, although
	# the value will often be null because it'll instead be set by a transform.  set
	# their position to >1000 in order to put them at the end of the table.
	#
	# title_transforms just change the header text for the specified column.
	#
	# value_transforms use "%%variable%%" to refer to the name/value of their own column, and
	# can also use %%foo%%, where foo is the name of any other column in the same table.

	my ($range_start,$range_end) = get_pagination_range($itemsperpage);
	my $sql_range_start = $range_start - 1; # because SQL's LIMIT is zero-based.

	if($allowed_to_create)
	{
		$createmode = 1 if get_qs_var('createmode') eq 'true';
	}

	if($allowed_to_edit)
	{
		# Nothing in here should need editing.
		if(get_qs_var('editmode') eq 'true'   &&   get_qs_var('editid') =~ /^(\d+)$/)
		{
			$editmode = 1;
			$row_id_to_edit = $1;
		}
		elsif(!$createmode)
		{
			$$extra_columns{edit} = { position => 1 };
			$$value_transforms{edit} = qq`%%variable%% = '<a href="$PREF{REQ_URI_SANS_QS}?$qs&editmode=true&amp;editid=%%id%%&amp;format=vert">$TEXT{Edit}</a>';`;
		}
	}

	die_unless_sqlsafe($dbtable);
	die_unless_numeric($row_id_to_edit, '$row_id_to_edit');
	my $live_data_fingerprint = md5_hex($ENV{HTTP_HOST} . $ENV{HTTP_USER_AGENT} . join('',enc_sql_select("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit")));

	my $restriction = '';
	my $num_cols = 0;

	my $db_colnames = get_db_colnames($dbtable);
	$num_cols += ($db_colnames =~ tr/,//) + 1;

	# If any extra (i.e. not straight from the DB) columns were specified,
	# get or assign their positions:
	#
	my %extra_column_names = ();
	foreach my $colname (keys %$extra_columns)
	{
		my $requested_pos = $$extra_columns{$colname}{position};
		if(!$requested_pos || ($requested_pos < 1000))
		{
			my $pos = $$extra_columns{$colname}{position} =~ /^(\d+)$/ ? $1 : $num_cols;
			$pos++ while exists $extra_column_names{$pos};
			$extra_column_names{$pos} = $colname;
			$num_cols++;
		}
	}

	# Create the combined @column_list from the actual DB columns and
	# the extra columns with their specified positions:
	#
	my $j = 0;
	my @column_list = ();
	for(my $i = 1; $i <= $num_cols; $i++)
	{
		if($extra_column_names{$i})	{ push @column_list, $extra_column_names{$i};	}
		else				{ push @column_list, (split(/,/, $db_colnames))[$j++];	}
	}

	# Now go through the extra columns again, for any that requested to
	# be at the end of the table (by specifying a position >1000):
	#
	foreach my $colname (keys %$extra_columns)
	{
		my $requested_pos = $$extra_columns{$colname}{position};
		if($requested_pos >= 1000)
		{
			push @column_list, $colname;
			$num_cols++;
		}
	}

	my $column_list = join ',', @column_list;

	my $vertical = $qs =~ /format=vert/ || ($PREF{"${viewerprefname}_viewer_default_mode"} =~ /vertical/i && $qs !~ /format=horiz/);
	$vertical = 0 if $PREF{"${viewerprefname}_viewer_forced_mode"} =~ /horiz/i;
	$vertical = 1 if $PREF{"${viewerprefname}_viewer_forced_mode"} =~ /vert/i;
	my %columns = map { $_ => 1 } split(/,/, $column_list);
	my %hidden_columns = map { $_ => 1 } split(/\s*,\s*/, $hiddencols);
	my %disabled_columns = map { $_ => 1 } split(/\s*,\s*/, $disabledcols);
	my %hidden_cells = ();

	my %uncreatable_columns = map { $_ => 1 } split(/\s*,\s*/, $PREF{"${viewerprefname}_viewer_uncreatable_columns"});
	my %uneditable_columns = map { $_ => 1 } split(/\s*,\s*/, $PREF{"${viewerprefname}_viewer_uneditable_columns"});
	my %autoset_columns = %{$PREF{"${viewerprefname}_creation_autoset_columns"}} if $PREF{"${viewerprefname}_creation_autoset_columns"};
	$uneditable_columns{id} = $uncreatable_columns{id} = 1;

	$PREF{"${viewerprefname}_viewer_item_name"} = $PREF{"${viewerprefname}_viewer_item_name"} || 'record';
	$PREF{"${viewerprefname}_viewer_item_name_plural"} = $PREF{"${viewerprefname}_viewer_item_name_plural"} || $PREF{"${viewerprefname}_viewer_item_name"}.'s';
	s!%%itemname%%!$PREF{"${viewerprefname}_viewer_item_name"}!g for ($TEXT{database_create_button}, $TEXT{database_create_button_2}, $TEXT{database_delete_successful}, $TEXT{database_deleter_title}, $TEXT{database_deleter_checkbox}, $TEXT{database_deleter_button});


	# Set any viewer/editor options that apply to all modes (view/create/edit):
	#
	foreach my $column (split(/,/, $column_list))
	{
		my $fieldtype_already_set = 0;
		if(my ($fieldtype,$label,$listitems,$defaultvalue) = field_structure_managed_by_us($column))
		{
			$custom_titles{$column} = $label if $label;
			$PREF{"${viewerprefname}_creation_default_value"}{lc($column)} = $defaultvalue if $defaultvalue;
			if($fieldtype eq 'dropdown')
			{
				$listitems =~ s!\n!\|\|\|!g; # our field structure manager uses newline as separator; this function uses "|||".
				$PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)} = $listitems;
				$fieldtype_already_set = 1;
			}
			elsif($fieldtype eq 'checkbox')
			{
				$PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)} = 1;
				$fieldtype_already_set = 1;
			}
			elsif($fieldtype eq 'radio')
			{
				$listitems =~ s!\n!\|\|\|!g; # our field structure manager uses newline as separator; this function uses "|||".
				$PREF{"${viewerprefname}_viewer_column_is_radio_buttons"}{lc($column)} = $listitems;
				$fieldtype_already_set = 1;
			}
			elsif($fieldtype eq 'freeformmulti')
			{
				$PREF{"${viewerprefname}_viewer_force_textarea"}{lc($column)} = 1;
				$fieldtype_already_set = 1;
			}
		}
		if(datatype_is_bool($dbtable,$column) && !$fieldtype_already_set)
		{
			$PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)} = 1;
			$fieldtype_already_set = 1;
		}
	}


	# Note: early return.
	if($ENV{REQUEST_METHOD} =~ /post/i)
	{
		my $return_url = param('enc_post_return_url') || $PREF{REQ_URI_SANS_QS};

		if($editmode)
		{
			exit_with_needprivs() unless $allowed_to_edit;

			my $data_fingerprint_before_editing = param('enc_form_dfp');
			exit_with_error(qq`Error: data fingerprint mismatch; the data changed while you were editing it.&nbsp; Go back, reload the page, and try again.`) unless $live_data_fingerprint eq $data_fingerprint_before_editing;

			# We're only dealing with a single row here, but we'll use _multi to get the named fields into a hash.
			my $existingdata = enc_sql_select_multi("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit");

			if($qs =~ /editdelete=true/)
			{
				exit_with_needprivs() unless $allowed_to_delete;

				foreach my $col (keys %{$$existingdata{1}})
				{
					exit_with_error("Error: this record cannot be deleted.") if exists $PREF{"${viewerprefname}_viewer_undeletable_rows"}{lc($col)}{   $$existingdata{1}{$col}   };
				}

				if(param('confirmdeleterecord') =~ /on/i)
				{
					my $values = enc_sql_select_multi("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit LIMIT 1");
					enc_sql_delete("DELETE FROM `$dbtable` WHERE `id` = $row_id_to_edit LIMIT 1");

					if(exists $PREF{"${viewerprefname}_deletion_oncomplete_code"})
					{
						my $code = $PREF{"${viewerprefname}_deletion_oncomplete_code"};
						$code =~ s/%%(\w+)%%/$$values{1}{$1}/g;
						eval $code;
					}

					$qs =~ s!format=(horiz|vert)!!g if $qs =~ /format=horiz/i && $qs =~ /format=vert/i; # if both are present, remove both.
					$qs =~ s!format=vert!!; # we always add 1 format=vert on the way to this page, so we should always remove 1 on the way back out.
					$qs =~ s!editdelete=true!!g;
					$qs =~ s!editmode=true!!g;
					$qs =~ s!editid=\d+!!g;
					defooify('&',$qs);
					enc_redirect($return_url . ($qs ? "?$qs" : ''));
				}
				else
				{
					$qs =~ s!editdelete=true!!g;
					defooify('&',$qs);
					enc_redirect($return_url . ($qs ? "?$qs" : ''));
				}
			}
			else
			{
				foreach my $column (keys %{$$existingdata{1}})
				{
					next if $disabled_columns{$column} || $column =~ /^enchddn_/i || $$existingdata{1}{enchddn_uneditable_cols_in_this_row} =~ /$column/i;
					next if $uneditable_columns{lc($column)};
					next if exists $PREF{"${viewerprefname}_viewer_uneditable_values"}{lc($column)}{   $$existingdata{1}{$column}   };

					my $value = param("encdb_$column");
					$value =~ s!\r\n!\n!g;

					if(my $code = $PREF{"${viewerprefname}_POST_value_transforms"}{lc($column)})
					{
						my %values = { $column => '' };
						transform_value_according_to_code($value, \%values, $code, $column, 2, undef);
						$value = $values{$column};
					}
					elsif($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)})
					{
						$value = param("encdb_" . $column) =~ /on/i ? 1 : 0;
					}

					replace_nonsqlsafe_chars_with($PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column}, $value) if exists $PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column};
					verify_new_database_value($dbtable,$viewerprefname,$column,$value,$row_id_to_edit);

					sql_untaint($value,$column);
					die_unless_sqlsafe($value,$column);

					unless($value eq $$existingdata{1}{$column})
					{
						$value = $value eq '' ? qq`NULL` : qq`'$value'`;
						my $success = enc_sql_update("UPDATE `$dbtable` SET `$column` = $value WHERE `id` = $row_id_to_edit");
						die_nice("SQL returned '$success' instead of '1' while updating '$column'.") unless $success == 1;
					}
				}
				$qs =~ s!format=horiz!!g if $qs =~ /format=horiz/i && $qs =~ /format=vert/i; # if both are present, remove both.
				$qs =~ s!format=vert!!; # we always add 1 format=vert on the way to this page, so we should always remove 1 on the way back out.
				$qs =~ s!editmode=true!!g;
				$qs =~ s!editid=\d+!!g;
				defooify('&',$qs);
				enc_redirect($return_url . ($qs ? "?$qs" : ''));
			}
		}
		else
		{
			exit_with_needprivs() unless $allowed_to_create;

			my @namelist = my @valuelist = ();

			# Do this twice, because we might need to interpolate a variable value from a
			# late column into an early column, which won't be set the first time through.
			#
			my %values = ();
			my %creation_autoset_columns___done = ();
			my %POST_value_transforms___done = ();
			foreach my $pass (1,2)
			{
				foreach my $column (split(/,/, $db_colnames))
				{
					next if $uncreatable_columns{$column};
					my $value = '';
					if(my $code = $PREF{"${viewerprefname}_creation_autoset_columns"}{lc($column)})
					{
						# TODO: for clarity, should the first param here be '' instead of $value?
						transform_value_according_to_code($value, \%values, $code, $column, $pass, \%creation_autoset_columns___done);
					}
					elsif(my $code = $PREF{"${viewerprefname}_POST_value_transforms"}{lc($column)})
					{
						$value = param("encdb_" . $column);
						transform_value_according_to_code($value, \%values, $code, $column, $pass, \%POST_value_transforms___done);
					}
					elsif($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)})
					{
						$values{$column} = param("encdb_" . $column) =~ /on/i ? 1 : 0;
					}
					else
					{
						$values{$column} = param("encdb_" . $column);
					}
				}
			}

			foreach my $column (keys %values)
			{
				my $value = $values{$column};
				replace_nonsqlsafe_chars_with($PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column}, $value) if exists $PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column};
				verify_new_database_value($dbtable,$viewerprefname,$column,$value,'');
				$values{$column} = $value; # want the sqlsafe version but not the sql_untainted version.
				sql_untaint($value);
				die_unless_sqlsafe($value);
				push @namelist, "`$column`";
				push @valuelist, "'$value'";
			}

			my $statement = "INSERT INTO `$dbtable` (" . (join ',', @namelist) . ") VALUES(" . (join ',', @valuelist) . ")";
			enc_sql_insert($statement);
			my $id = enc_sql_select("SELECT LAST_INSERT_ID() FROM `$dbtable`");
			$values{id} = $id;

			if(my $code = $PREF{"${viewerprefname}_creation_oncomplete_code"})
			{
				$code =~ s/%%(\w+)%%/$values{$1}/g; eval $code;
			}

			if(my $template = $PREF{"${viewerprefname}_creation_complete_page_template"})
			{
				$template =~ s/%%(\w+)%%/$values{$1}/g; kmsg_redirect($template);
			}
			elsif(my $redirect = $PREF{"${viewerprefname}_creation_complete_redirection_url"})
			{
				$redirect =~ s/%%(\w+)%%/$values{$1}/g; enc_redirect($redirect);
			}
			else
			{
				$qs =~ s!format=(horiz|vert)!!g if $qs =~ /format=horiz/i && $qs =~ /format=vert/i; # if both are present, remove both.
				$qs =~ s!format=vert!!; # we always add 1 format=vert on the way to this page, so we should always remove 1 on the way back out.
				$qs =~ s!createmode=true!!g;
				defooify('&', $qs);
				enc_redirect($return_url . ($qs ? "?$qs" : ''));
			}
		}
	}




	my ($toggles,$headers,%headers,$firstcol) = ('','',undef,'');
	foreach my $column (split(/,/, $column_list))
	{
		next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
		next if $uncreatable_columns{$column} && $createmode;
		next if $$extra_columns{$column} && $createmode;

		$firstcol = $column unless $firstcol;
		my $name = my $title = $column;
		if($$title_transforms{$column})		{ $title = $$title_transforms{$column};											}
		elsif($custom_titles{$column})		{ $title = $custom_titles{$column};											}
		else					{ $title =~ s/^(\w)/\u$1/; $title =~ s/_/ /g unless $PREF{dont_convert_underscores_to_spaces_in_db_titles} =~ /yes/i;	}
		my $strike = qq`style="text-decoration: line-through;"` if $hidden_columns{$name};
		$toggles .= qq`<a href="#" onclick="toggle_column('$name'); return false" id="link-$name" $strike>$title</a>&nbsp; `;

		$hidden_cells{$name} = qq`style="display: none;"` if $hidden_columns{$name} && !$createmode; # don't hide them in createmode, where the user must be able to see them to enter values for them.

		my $new_qs = $qs;
		#$new_qs =~ s/(^|&)$qs_id(&|$)/$1$2/g;
		$new_qs =~ s/(^|&)sort=\w+?(&|$)/$1$2/g;
		$new_qs =~ s/(^|&)reverse=\d(&|$)/$1$2/g;
		$new_qs =~ s/(^|&)phase=\w+?(&|$)/$1$2/g;
		$new_qs .= "&sort=$name";
		if($qs =~ /(?:^|&)reverse=1(?:&|$)/) { $new_qs .= "&reverse=0"; } else { $new_qs .= "&reverse=1"; }
		defooify('&',$new_qs);
		$new_qs =~ s/&/&amp;/g;

		my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{"${column}_header"} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{"${column}_header"};
		my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{"${column}_header"} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{"${column}_header"};
		#my $link = $self =~ /\?/ ? "$self&$new_qs" : "$self?$new_qs";
		my $link = "$PREF{REQ_URI_SANS_QS}?$new_qs";
		$headers	.= qq`<th class="$name" $hidden_cells{$name} $style_horiz><a href="$link">$title</a></th>`;
		$headers{$name}	 = qq`<td class="$name verthead" $hidden_cells{$name} $style_vert><a href="$link">$title</a></td>`; # for vertical format.
	}

	my $output = '';

	if($createmode)
	{
		$output .= qq`<form method="post" action="$ENV{SCRIPT_NAME}?$qs" style="margin: 0; padding: 0;">\n`;
		$output .= qq`<div id="${dbtable}_table" class="enc_tbl enc_create_tbl">\n<table>\n`;
		$output .= qq`<tr class="headers">$headers</tr>\n` unless $vertical;

		my $i = 0;
		my $numcols = 1;
		my $oddeven = oddeven($i);
		$output .= qq`<tr class="$oddeven">` unless $vertical;
		foreach my $column (split(/,/, $column_list))
		{
			next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
			next if $uncreatable_columns{$column};
			next if $$extra_columns{$column};
			next if $autoset_columns{$column};

			my $value = '';
			if(my $default = $PREF{"${viewerprefname}_creation_default_value"}{lc($column)})
			{
				if($default eq 'preset:date8')		{ $value = strftime("%Y%m%d",localtime(offsettime())); }
				elsif($default eq 'preset:date17')	{ $value = strftime("%Y%m%d-%H:%M:%S",localtime(offsettime())); }
				elsif($default eq 'preset:etime')	{ $value = offsettime(); }
				elsif($default =~ /%URL\{\w+\}/)	{ interpolate_vars_from_URL_and_cookies($default); $value = $default; }
				else					{ $value = $default; }
			}

			#my $readonly = $uneditable_columns{lc($column)};
			my $readonly = '';

			my $readonly__still_submitted = 'readonly="readonly"' if $PREF{"${viewerprefname}_readonly_value__still_submitted"}{lc($column)};


			# Process viewer/editor options:
			#
			if($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)} && !$readonly)
			{
				$value = qq`<input type="checkbox" name="encdb_$column" ` . ($value ? qq`checked="checked"` : '') . qq` />`;
			}
			elsif(exists $PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)} && !$readonly)
			{
				my ($yes,$no) = $PREF{"${viewerprefname}_viewer_column_toggle_values"}{lc($column)} =~ /(.+)\|(.+)/ ? ($1,$2) : ($TEXT{boolean_true_string}, $TEXT{boolean_false_string});
				$value  = qq`<select name="encdb_$column">`
					. qq`<option value="1"` . ($value  ? ' selected="selected"' : '') . qq`>$yes</option>`
					. qq`<option value="0"` . (!$value ? ' selected="selected"' : '') . qq`>$no</option>`
					. qq`</selected>`;
			}
			elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)})
			{
				my $dropdown = qq`<select name="encdb_$column">`;
				my $value_is_in_list = 0;
				foreach my $item (split(/\s*\|\|\|\s*/, $list))
				{
					my $selected = '';
					if($item eq $value)
					{
						$selected = 'selected="selected"';
						$value_is_in_list = 1;
					}
					$dropdown .= qq`<option $selected>$item</option>`;
				}
				$dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
				$dropdown .= qq`</select>`;
				$value = $dropdown;
			}
			elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_radio_buttons"}{lc($column)})
			{
				my $item_i = 1;
				my @buttons = ();
				my $value_is_in_list = 0;
				foreach my $item (split(/\s*\|\|\|\s*/, $list))
				{
					my $checked = '';
					if($item eq $value)
					{
						$checked = 'checked="checked"';
						$value_is_in_list = 1;
					}
					push @buttons, qq`<input type="radio" name="encdb_$column" id="encdb_radio_${column}_${item_i}" value="$item" $checked /><label for="encdb_radio_${column}_${item_i}">$item</label>`;
					$item_i++;
				}
				my $separator = $PREF{"db_viewer_radiobutton_separator___$column"} || $PREF{db_viewer_radiobutton_separator___global} || '<br />';
				$value = join $separator, @buttons;
			}
			elsif($PREF{"${viewerprefname}_creation_dropdown_from_SQL"}{lc($column)} && ($PREF{"${viewerprefname}_creation_dropdown_from_SQL"}{lc($column)} =~ /^SELECT (\w+),(\w+) FROM /))
			{
				my $query = $PREF{"${viewerprefname}_creation_dropdown_from_SQL"}{lc($column)};

				# The value of this query pref must start with: SELECT foo,bar FROM [...].
				# The first column will be the submitted value and the second the displayed value.

				my ($col1,$col2) = ($1,$2);
				my $dropdown = qq`<select name="encdb_$column">`;
				my $value_is_in_list = 0;
				my $results = enc_sql_select_multi($query);
				foreach my $k (sort { $a <=> $b } keys %$results)
				{
					my $submitted_value = $$results{$k}{$col1};
					my $displayed_value = $$results{$k}{$col2};
					my $selected = '';
					if($submitted_value eq $value)
					{
						$selected = 'selected="selected"';
						$value_is_in_list = 1;
					}
					$dropdown .= qq`<option value="$submitted_value" $selected>$displayed_value</option>`;
				}
				$dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
				$dropdown .= qq`</select>`;
				$value = $dropdown;
			}
			else
			{
				my $textlength = 'longtext';
				my $force_textarea = $PREF{"${viewerprefname}_viewer_force_textarea"}{lc($column)};

				$value = $readonly
					? qq`<div class="readonly">$value</div>`
					: (length($value) > 50 || $force_textarea)
					? qq`<textarea name="encdb_$column" class="text $textlength" $readonly__still_submitted>$value</textarea>`
					: qq`<input type="text" name="encdb_$column" class="text" value="$value" $readonly__still_submitted />`;
			}

			my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{$column} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{$column};
			my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{$column} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{$column};
			my $style = $vertical ? $style_vert : $style_horiz;
			my $vertclass = 'vertcell' if $vertical;
			$output .= qq`<tr class="$oddeven vertrow">` if $vertical;
			$output .= $headers{$column} if $vertical;
			$output .= qq`<td class="$column $vertclass" $hidden_cells{$column} $style>$value</td>`;
			$output .= qq`</tr>\n` if $vertical;
			$numcols++;
		}
		$output .= qq`</tr>\n` unless $vertical;

		$output .= qq`<tr class="` . oddeven($i) . qq`">`;
		$output .= qq`<td colspan="$numcols" class="button"><input type="submit" class="button" value="$TEXT{database_create_button_2}" /></td>`;
		$output .= qq`</tr>\n`;

		$output .= qq`</table>\n</div>\n`;
		$output .= qq`<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />\n`;
		$output .= qq`</form>\n`;
	}
	else
	{
		my $editclass = $editmode ? 'enc_edit_tbl' : '';
		$output .= qq`<form method="post" action="$ENV{SCRIPT_NAME}?$qs" style="margin: 0; padding: 0;">\n` if $editmode;
		$output .= qq`<div id="columntoggles">Show/hide:&nbsp; $toggles</div>\n` unless $PREF{"${viewerprefname}_viewer_hide_column_toggles"} =~ /yes/i;
		$output .= qq`<div id="${dbtable}_table" class="enc_tbl $editclass">\n<table>\n` unless $vertical;
		$output .= qq`<tr class="headers">$headers</tr>\n` unless $vertical;

		# 20090429: changed the query from this:
		#
		#	SELECT * FROM `$dbtable` LIMIT $sql_range_start, $range_end
		#
		# ...to this:
		#
		#	SELECT * FROM `$dbtable` $DESC LIMIT $sql_range_start, $range_end
		#
		# ...where $DESC = $reverse ? 'ORDER BY `id` DESC' : ''.
		# This is so that, when sorting in reverse with multiple pages of records (with
		# for example 25 records per page), page #1 shows the *last* 25 records, rather
		# than the first 25 but in reverse order.  But, shouldn't we be using $sortkey,
		# as in the original now-commented-out query, rather than hard-coding it to `id`?

		my $sortkey = $qs =~ /(?:^|&)sort=(\w+?)(?:&|$)/ ? $1 : exists $columns{id} ? 'id' : $firstcol;
		my $reverse = $qs =~ /(?:^|&)reverse=1(?:&|$)/ ? 1 : 0; # toggle the 1s and 0s to reverse by default or not.
		my $DESC = $reverse ? 'ORDER BY `id` DESC' : '';
		enc_urldecode($sortkey);
		die_unless_sqlsafe($sortkey);
		#my $rows = enc_sql_select_multi("SELECT * FROM `$dbtable` ORDER BY `$sortkey` LIMIT $sql_range_start, $range_end");
		my $rows = enc_sql_select_multi("SELECT * FROM `$dbtable` $DESC LIMIT $sql_range_start, $range_end");

		# Do a first pass so we can perform value_transforms, so the values are
		# set and then we can do the sorting properly in the second pass.
		#
		foreach my $row (keys %$rows)
		{
			# Actually, do this first pass twice, because we might need to interpolate
			# a variable value from a late column into an early column, which won't be
			# set the first time through.
			#
			my %already_transformed = ();
			foreach my $pass (1,2)
			{
				foreach my $column (split(/,/, $column_list))
				{
					#next if $disabled_columns{$column}; # actually, don't skip disabled cols here; we want their values to be available for transforms for other cols.
					my $value = exists $$extra_columns{$column} ? $$extra_columns{$column}{value} : $$rows{$row}{$column};
					$$rows{$row}{"${column}___raw"} = $value if $pass==1;
					if(my $code = $$value_transforms{$column})
					{
						transform_value_according_to_code($value, \%{$$rows{$row}}, $code, $column, $pass, \%already_transformed);
					}
					else
					{
						$$rows{$row}{$column} = $value;
					}
				}
			}
		}

		my $there_was_some_output = 0;
		my $numcols = 0;
		my $i = 1;
		foreach my $row (sort
		{
			  $$rows{$a}{$sortkey} =~ /^\d*$/ && $$rows{$b}{$sortkey} =~ /^\d*$/ && $reverse	? lc($$rows{$b}{$sortkey}) <=> lc($$rows{$a}{$sortkey})
			: $$rows{$a}{$sortkey} =~ /^\d*$/ && $$rows{$b}{$sortkey} =~ /^\d*$/			? lc($$rows{$a}{$sortkey}) <=> lc($$rows{$b}{$sortkey})
			: $reverse										? lc($$rows{$b}{$sortkey}) cmp lc($$rows{$a}{$sortkey})
			: 											  lc($$rows{$a}{$sortkey}) cmp lc($$rows{$b}{$sortkey})
		}
		keys %$rows)
		{
			my $failed_to_match_url_spec = my $row_is_hidden_via_value_regex = 0;
			foreach my $column (split(/,/, $column_list))
			{
				if($qs =~ /(?:^|&)$column=([^&]*)(?:&|$)/i)
				{
					my $url_specified_value = $1;
					enc_urldecode($url_specified_value);
					$failed_to_match_url_spec = 1 if $$rows{$row}{$column} ne $url_specified_value;
				}
				if(exists $PREF{"${viewerprefname}_viewer_hidden_values_regex"}{lc($column)} && $qs !~ /showhiddenrows=true/)
				{
					my $regex = $PREF{"${viewerprefname}_viewer_hidden_values_regex"}{lc($column)};
					$row_is_hidden_via_value_regex ||= $regex && $$rows{$row}{$column} =~ /($regex)/i;
				}
			}
			next if $failed_to_match_url_spec || $row_is_hidden_via_value_regex;

			next if $editmode && $$rows{$row}{id} != $row_id_to_edit;

			$numcols = 0;
			my $oddeven = oddeven($i);
			$output .= qq`<div id="${dbtable}_table" class="enc_tbl $editclass">\n<table>\n` if $vertical;
			$output .= qq`<tr class="$oddeven">` unless $vertical;
			foreach my $column (split(/,/, $column_list))
			{
				next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
				my $value = '';

				if($editmode)
				{
					$value = $$rows{$row}{"${column}___raw"};
					my $transformed_value = $$rows{$row}{$column};

					# If *any* of the columns in this row are specified in _viewer_undeletable_rows,
					# then the whole row must be undeletable, so disable the $allowed_to_delete bit.
					#
					$allowed_to_delete = 0 if exists $PREF{"${viewerprefname}_viewer_undeletable_rows"}{lc($column)}{$value};
					#
					# Or if the table has an "enchddn_undeletable" column, and it's enabled for this
					# row, then disable the $allowed_to_delete bit.
					#
					$allowed_to_delete = 0 if $$rows{$row}{enchddn_undeletable};

					my $uneditable_value = exists $PREF{"${viewerprefname}_viewer_uneditable_values"}{lc($column)}{$value};
					my $readonly = $$extra_columns{lc($column)} || $uneditable_columns{lc($column)} || $uneditable_value;
					$readonly = 1 if $value ne $transformed_value && exists $PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{lc($column)};
					$readonly = 1 if exists $$rows{$row}{enchddn_uneditable_cols_in_this_row} && $$rows{$row}{enchddn_uneditable_cols_in_this_row} =~ /$column/i;

					if($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)} && !$readonly)
					{
						$value = qq`<input type="checkbox" name="encdb_$column" ` . ($value ? qq`checked="checked"` : '') . qq` />`;
					}
					elsif(exists $PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)} && !$readonly)
					{
						my ($yes,$no) = $PREF{"${viewerprefname}_viewer_column_toggle_values"}{lc($column)} =~ /(.+)\|(.+)/ ? ($1,$2) : ($TEXT{boolean_true_string}, $TEXT{boolean_false_string});
						if($transformed_value =~ /^[01]?$/)
						{
							$value  = qq`<select name="encdb_$column">`
								. qq`<option value="1"` . ($value  ? ' selected="selected"' : '') . qq`>$yes</option>`
								. qq`<option value="0"` . (!$value ? ' selected="selected"' : '') . qq`>$no</option>`
								. qq`</selected>`;
						}
						else
						{
							# So we can use a transform to set the displayed value to 'N/A' (for example)
							# if necessary, for cases where the column shouldn't apply at all based on
							# other column values for this row.
							#
							$value = $transformed_value;
						}
					}
					elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)})
					{
						my $dropdown = qq`<select name="encdb_$column">`;
						my $value_is_in_list = 0;
						foreach my $item (split(/\s*\|\|\|\s*/, $list))
						{
							my $selected = '';
							if($item eq $value)
							{
								$selected = 'selected="selected"';
								$value_is_in_list = 1;
							}
							$dropdown .= qq`<option $selected>$item</option>`;
						}
						$dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
						$dropdown .= qq`</select>`;
						$value = $dropdown;
					}
					elsif(my $list = $PREF{"${viewerprefname}_viewer_column_is_radio_buttons"}{lc($column)})
					{
						my $item_i = 1;
						my @buttons = ();
						my $value_is_in_list = 0;
						foreach my $item (split(/\s*\|\|\|\s*/, $list))
						{
							my $checked = '';
							if($item eq $value)
							{
								$checked = 'checked="checked"';
								$value_is_in_list = 1;
							}
							push @buttons, qq`<input type="radio" name="encdb_$column" id="encdb_radio_${column}_${item_i}" value="$item" $checked /><label for="encdb_radio_${column}_${item_i}">$item</label>`;
							$item_i++;
						}
						my $separator = $PREF{"db_viewer_radiobutton_separator___$column"} || $PREF{db_viewer_radiobutton_separator___global} || '<br />';
						$value = join $separator, @buttons;
					}
					else
					{
						$value = $transformed_value if $readonly; # display the transformed value, instead of the raw value, if it's not editable.

						$value =~ s!"!&quot;!g unless $readonly;
						my $textlength = length($value) < 50 ? 'shorttext' : length($value) < 200 ? 'mediumtext' : 'longtext';
						my $force_textarea = $PREF{"${viewerprefname}_viewer_force_textarea"}{lc($column)};

						if(!$value && exists $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)})
						{
							$value = $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)};
						}

						$value = $readonly
							? qq`<div class="readonly">$value</div>`
							: (length($value) > 50 || $force_textarea)
							? qq`<textarea name="encdb_$column" class="text $textlength">$value</textarea>`
							: qq`<input type="text" name="encdb_$column" class="text" value="$value" />`;
					}
				}
				else
				{
					$value = $$rows{$row}{$column};

					# Value processing:
					#
					if($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)})
					{
						$value = $value ? $TEXT{boolean_true_string} : $TEXT{boolean_false_string};
					}
					elsif($PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)})
					{
						my ($yes,$no) = $PREF{"${viewerprefname}_viewer_column_toggle_values"}{lc($column)} =~ /(.+)\|(.+)/ ? ($1,$2) : ($TEXT{boolean_true_string}, $TEXT{boolean_false_string});
						$value = $value == 1 ? $yes : $value =~ /^0?$/ ? $no : $value;
					}

					# Value correction/cleanup:
					#
					if(length($value) > $display_length && $value !~ m!</?\w+>!) # don't shorten values containing HTML, b/c it'll break the code.
					{
						my $abbreviated_value = $value;
						$abbreviated_value =~ s/^(.{$display_length}).*/$1.../;
						$value =~ s/"/\\"/g;
						$value = qq`<span title="$value">$abbreviated_value</span>`;
					}
					if(!$value && exists $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)})
					{
						$value = $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)};
					}
					if($PREF{"${viewerprefname}_viewer_show_HTML_as_code"}{lc($column)})
					{
						$value =~ s/</&lt;/g;
						$value =~ s/>/&gt;/g;
					}
					$value =~ s!\n!<br />\n!g;
				}

				my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{$column} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{$column};
				my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{$column} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{$column};
				my $style = $vertical ? $style_vert : $style_horiz;
				my $vertclass = 'vertcell' if $vertical;
				$output .= qq`<tr class="$oddeven vertrow">` if $vertical;
				$output .= $headers{$column} if $vertical;
				$output .= qq`<td class="$column $vertclass" $hidden_cells{$column} $style>$value</td>`;
				$output .= qq`</tr>\n` if $vertical;
				$there_was_some_output = 1;
				$numcols++;
			}

			if($vertical)
			{
				if($editmode)
				{
					$output .= qq`<tr class="` . oddeven($i) . qq`">`;
					$output .= qq`<td colspan="$numcols" class="button"><input type="hidden" name="enc_form_dfp" value="$live_data_fingerprint" /><input type="submit" class="button" value="$TEXT{database_save_button}" /></td>`;
					$output .= qq`</tr>\n`;
				}
				elsif($allowed_to_create)
				{
					$output .= qq`<tr class="` . oddeven($i) . qq`">`;
					$output .= qq`<td colspan="$numcols" class="addnew"><a href="$PREF{REQ_URI_SANS_QS}?$qs&amp;createmode=true&amp;format=vert">$TEXT{database_create_button}</a></td>`;
					$output .= qq`</tr>\n`;
				}
			}

			$output .= qq`</tr>\n` unless $vertical;
			$output .= qq`</table>\n</div>\n` if $vertical;
		}

		if(!$vertical)
		{
			if($editmode)
			{
				$output .= qq`<tr class="` . oddeven($i) . qq`">`;
				$output .= qq`<td colspan="$numcols" class="button"><input type="hidden" name="enc_form_dfp" value="$live_data_fingerprint" /><input type="submit" class="button" value="$TEXT{database_save_button}" /></td>`;
				$output .= qq`</tr>\n`;
				$there_was_some_output = 1;
			}
			elsif($allowed_to_create)
			{
				$output .= qq`<tr class="` . oddeven($i) . qq`">`;
				$output .= qq`<td colspan="$numcols" class="addnew"><a href="$PREF{REQ_URI_SANS_QS}?$qs&amp;createmode=true&amp;format=vert">$TEXT{database_create_button}</a></td>`;
				$output .= qq`</tr>\n`;
				$there_was_some_output = 1;
			}
		}

		unless($there_was_some_output)
		{
			my $numcols = 0;
			foreach my $column (split(/,/, $column_list))
			{
				next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
				$numcols++;
			}

			$output .= qq`<div id="${dbtable}_table" class="enc_tbl">\n<table>\n` if $vertical;
			$output .= qq`<tr class="` . oddeven($i) . qq`">`;
			$output .= qq`<td colspan="$numcols">$TEXT{no_output_from_database}</td>`;
			$output .= qq`</tr>\n`;
			$output .= qq`</table>\n</div>\n` if $vertical;
		}

		$output .= qq`</table>\n</div>\n` unless $vertical;
		$output .= qq`<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />\n` if $editmode;
		$output .= qq`</form>\n` if $editmode;


		if($editmode && $allowed_to_delete)
		{
			$output .= qq`
					<form id="database_deleter" method="post" action="$ENV{SCRIPT_NAME}?$qs&amp;editdelete=true"><div class="enc_tbl"><table>
					<tr class="headers"><th>$TEXT{database_deleter_title}</th></tr>
					<tr class="` . oddeven($i) . qq`"><td><input type="checkbox" class="checkbox" name="confirmdeleterecord" id="confirmdeleterecord" /><label for="confirmdeleterecord">$TEXT{database_deleter_checkbox}</label></td></tr>
					<tr class="` . oddeven($i) . qq`"><td class="button"><input type="hidden" name="enc_form_dfp" value="$live_data_fingerprint" /><input type="submit" class="button" value="$TEXT{database_deleter_button}" /></td></tr>
					</table></div>
					<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />
					</form>
			`;
		}


		$output .= qq`

		<script type="text/javascript">

		function toggle_column(theclass)
		{
			var rows = document.getElementById('${dbtable}_table').getElementsByTagName('tr');

			var cells = new Array;
			for(i = 0; i < rows.length; i++)
			{
				var headers = rows[i].getElementsByTagName('th');
				for(j = 0; j < headers.length; j++)
				{
					//if(headers[j].className == theclass)
					//	cells.push(headers[j]);

					var re = new RegExp('(^| )' + theclass + '( |\$)', "i");
					if(headers[j].className.match(re))
						cells.push(headers[j]);
				}

				var nonheaders = rows[i].getElementsByTagName('td');
				for(j = 0; j < nonheaders.length; j++)
				{
					//if(nonheaders[j].className == theclass)
					//	cells.push(nonheaders[j]);

					var re = new RegExp('(^| )' + theclass + '( |\$)', "i");
					if(nonheaders[j].className.match(re))
						cells.push(nonheaders[j]);
				}
			}
			for(i = 0; i < cells.length; i++)
			{
				if(cells[i].style.display == 'none')
				{
					cells[i].style.display = navigator.userAgent.indexOf("MSIE") ==  -1 ? 'table-cell' : 'block'; // IE doesn't support table-cell...
					document.getElementById("link-" + theclass).style.textDecoration = '';
				}
				else
				{
					cells[i].style.display = 'none';
					document.getElementById("link-" + theclass).style.textDecoration = 'line-through';
				}
			}
		}

		</script>

		`;
	}


	$template =~ s!%%output%%!$output!;

	my $uri = $ENV{REQUEST_URI};
	$uri =~ s/(\?|&)format=(horiz|vert)/$1/gi;
	defooify('&', $uri);
	my $horizlink	= $uri . ($uri =~ /\?/ ? '&' : '?') . qq`format=horiz`;
	my $vertlink	= $uri . ($uri =~ /\?/ ? '&' : '?') . qq`format=vert`;
	$template =~ s!%%horizlink:text=([^%]+)%%!$vertical ? qq`<a href="$horizlink">$1</a>` : $1!eg;
	$template =~ s!%%vertlink:text=([^%]+)%%!$vertical ? $1 : qq`<a href="$vertlink">$1</a>`!eg;

	$uri = $ENV{REQUEST_URI};
	$uri =~ s!editdelete=true!!g;
	$uri =~ s!(edit|create)mode=true!!g;
	$uri =~ s!editid=\d+!!g;
	clean_database_url($uri);
	defooify('&',$uri);
	defooify('\?',$uri);
	$template =~ s!%%viewalllink:text=([^%]+)%%!<a href="$uri">$1</a>!g;
	$template =~ s!%%%if-viewall%%%(.*?)%%%end-viewall%%%!$editmode || $createmode ? $1 : ''!egs;
	$template =~ s!%%whencelink:text=([^%]+)%%!$PREF{dbvwrwhence} ? qq`<a href="$PREF{dbvwrwhence}">$1</a>` : ''!eg;
	$template =~ s!%%%if-whence%%%(.*?)%%%end-whence%%%!$PREF{dbvwrwhence} ? $1 : ''!egs;

	my $numitems = enc_sql_select("SELECT COUNT(*) FROM `$dbtable`");
	my $pagelinks = get_pagination_links_mark2($range_start, $range_end, $numitems, $itemsperpage);
	$template =~ s!%%%if-pagelinks%%%(.*?)%%%end-pagelinks%%%!$pagelinks ? $1 : ''!egs;
	$template =~ s!%%pagelinks%%!$pagelinks!g;
	$template =~ s!%%itemname_plural%%!$PREF{"${viewerprefname}_viewer_item_name_plural"}!g;

	return $template;
}


sub datatype_is_bool($$)
{
	my ($table,$column) = @_;
	my $datatype = get_field_datatype($table,$column);
	return $datatype =~ /^(bool|tinyint\(1\))/i;
}


sub get_field_datatype($$)
{
	my ($table,$column) = @_;
	sql_untaint($table,$column);
	die_unless_sqlsafe($table,$column);

	# This fails on some older MySQL versions, which apparently don't allow the WHERE clause
	# on the SHOW COLUMNS query.  So we'll have to return all columns and manually search them.
	#my $coltypetest = enc_sql_select_multi("SHOW COLUMNS FROM `$table` WHERE `field` = '$column'");
	#return $$coltypetest{1}{Type} || $$coltypetest{1}{type};

	my $coltypetest = enc_sql_select_multi("SHOW COLUMNS FROM `$table`");
	foreach my $j (keys %$coltypetest)
	{
		return ($$coltypetest{$j}{Type} || $$coltypetest{$j}{type}) if ($$coltypetest{$j}{Field} =~ /^$column$/i || $$coltypetest{$j}{field} =~ /^$column$/i);
	}
}


sub clean_database_url
{
	$_[0] =~ s!format=(horiz|vert)!!g if $_[0] =~ /format=horiz/ && $_[0] =~ /format=vert/; # if both are present, remove all.
	for('horiz','vert')
	{
		if($_[0] =~ /format=$_/) { $_[0] =~ s!format=$_!!g; $_[0] .= "&format=$_"; } # condense multiple occurrences of the same one.
	}
	$_[0] =~ s!\?&+!?!g;
}


sub verify_new_database_value($$$$$)
{
	# Notes:
	#
	#	_viewer_unique_values and _viewer_unique_values_ignorecase require that
	# 	the table has a column called "id" which is unique and not null.
	#

	my ($dbtable,$viewerprefname,$column,$value,$rowid) = @_;
	sql_untaint($value,$column);
	die_unless_sqlsafe($value,$column);

	if(exists $PREF{"${viewerprefname}_viewer_unique_values"}{lc($column)})
	{
		if($rowid =~ /^\d+$/) # edit mode.
		{
			if(enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE `$column` = '$value' AND `id` != $rowid"))
			{
				exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
			}
		}
		else # add-new-record mode.
		{
			if(enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE `$column` = '$value'"))
			{
				exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
			}
		}
	}

	if(exists $PREF{"${viewerprefname}_viewer_unique_values_ignorecase"}{lc($column)})
	{
		if($rowid =~ /^\d+$/) # edit mode.
		{
			if(enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE LOWER(`$column`) = LOWER('$value') AND `id` != $rowid"))
			{
				exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
			}
		}
		else # add-new-record mode.
		{
			if(enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE LOWER(`$column`) = LOWER('$value')"))
			{
				exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
			}
		}
	}

	if(my $code = $PREF{"${viewerprefname}_viewer_value_verifications"}{lc($column)})
	{
		if($code =~ /^preset:(.+)/)
		{
			foreach my $preset (split(/\s*,\s*/, $1))
			{
				my $error = '';
				   if(($preset eq 'nonnull')	&& (!$value && ($value !~ /^0$/)))	{ $error = $TEXT{Error_input_null}; }
				elsif(($preset eq 'alnum')	&& ($value !~ /^[[:alnum:]]*$/))	{ $error = $TEXT{Error_input_not_alnum}; }
				elsif(($preset eq 'numeric')	&& ($value !~ /^\d*$/))			{ $error = $TEXT{Error_input_not_numeric}; }
				#print STDERR "column=$column, value=$value, preset=$preset, error=$error\n";

				if($error) { $error =~ s/%%encfieldname%%/$column/g; exit_with_error($error); }
			}
		}
		else
		{
			$code =~ s/%%variable%%/\$value/g;
			$code =~ s/%%encfieldname%%/$column/g;
			eval $code; # modified $value directly.
			exit_with_error($1) if $value =~ /die_from_eval:(.*)/;
		}
	}
}


sub transform_value_according_to_code
{
	my $value		= shift;
	my $values		= shift; # hashref
	my $code		= shift;
	my $column		= shift;
	my $pass		= shift;
	my $already_transformed = shift; # hashref.

	if($code =~ /^preset:(.+)/)
	{
		foreach my $preset (split(/\s*,\s*/, $1))
		{
			   if($preset eq 'make_lowercase')	{ $value = lc($value); }
			elsif($preset eq 'make_uppercase')	{ $value = uc($value); }
			elsif($preset eq 'remove_nonalnum')	{ $value =~ s![^[:alnum:]]!!g; }
			elsif($preset eq 'date8')		{ $value = strftime("%Y%m%d",localtime(offsettime())); }
			elsif($preset eq 'date17')		{ $value = strftime("%Y%m%d-%H:%M:%S",localtime(offsettime())); }
			elsif($preset eq 'etime')		{ $value = offsettime(); }
			#print STDERR "column=$column, value=$value, preset=$preset\n";
		}
		$$values{$column} = $value;
	}
	else
	{
		$code =~ s/%%variable%%/\$value/g;
		$code =~ s/%%(\w+)%%/exists $$values{$1} || $pass==2 ? $$values{$1} : $&/eg;
		if($code !~ /%%\w+%%/ || $pass==2)
		{
			if(!$$already_transformed{$column})
			{
				$$already_transformed{$column} = 1;
				eval $code; # modifies $value directly.
				$$values{$column} = $value;
			}
		}
	}
}


sub get_pagination_range($)
{
	my $items_per_page = shift;
	my $page_num = $qs =~ /(?:^|&)page=(\d+)(?:&|$)/ ? $1 : 1;
	my $range_end = $page_num * $items_per_page;
	my $range_start = $range_end - $items_per_page + 1;
	return ($range_start,$range_end);
}


sub get_pagination_links_mark2
{
	# first 4 args are mandatory; rest are optional.
	my ($range_start, $range_end, $num_items, $items_per_page,
		$itemname_singular,
		$itemname_plural,
		$pagename_singular,
		$pagename_plural,
		$template,
		$num_pagelinks
	) = @_;

	$template ||= qq`
		<div class="pagelinks">

		%%%ifelse-frstlink%%% <a href="%%frstlink%%">&lt;&lt;</a> %%%else%%% &lt;&lt; %%%endelse-frstlink%%%
		%%%ifelse-prevlink%%% <a href="%%prevlink%%">&lt;</a>     %%%else%%% &lt;     %%%endelse-prevlink%%%

		%%%template:linklist%%%
			%%%ifelse-currentpage%%%
				<span class="current">%%pagenum%%</span>
			%%%else%%%
				<a href="%%link%%">%%pagenum%%</a>
			%%%endelse-currentpage%%%
		%%%end-template:linklist%%%

		%%%ifelse-nextlink%%% <a href="%%nextlink%%">&gt;</a>     %%%else%%% &gt;     %%%endelse-nextlink%%%
		%%%ifelse-lastlink%%% <a href="%%lastlink%%">&gt;&gt;</a> %%%else%%% &gt;&gt; %%%endelse-lastlink%%%

		<div style="margin-top: 10px;">(%%num_items%% %%itemname%% on %%num_pages%% %%pagename%%)</div>
		</div>
	`;

	$itemname_singular	||= $TEXT{item};
	$itemname_plural	||= $TEXT{items};
	$pagename_singular	||= $TEXT{page};
	$pagename_plural	||= $TEXT{pages};
	$num_pagelinks		||= 8;

	my ($link_template) = ($template =~ m!%%%template:linklist%%%(.+?)%%%end-template:linklist%%%!gs);
	my $link_template_output = '';
	my %pagelinks = ();

	if($range_start != 1   ||   $num_items > $range_end)
	{
		my $uri = $ENV{REQUEST_URI};

		# Remove any existing phase/resultmsg, and page number, from the
		# URI, because we don't want to include those on each new page.
		#
		$uri =~ s/(\?|&)page=(\d+)/$1/g;
		$uri =~ s/(\?|&)phase=(\w+)/$1/g;
		$uri =~ s/(\?|&)rsltmsg=(\w+)/$1/g;

		$uri .= '?' unless $uri =~ /\?/;
		$uri .= '&' if $uri =~ /\?.+/ && $uri !~ /&$/;
		$uri =~ s/&{2,}/&/g;
		$uri =~ s/\?&/?/g;

		my $current_page = 1;
		my $num_pages = int($num_items/$items_per_page);
		$num_pages++ if $num_pages < ($num_items/$items_per_page);
		for(my $j = 1; $j <= $num_pages; $j++)
		{
			my $is_currentpage = ($ENV{REQUEST_URI} =~ /page=$j/ || ($ENV{REQUEST_URI} !~ /page=\d+/ && $j==1));
			$current_page = $j if $is_currentpage;

			my $link_template_local = $link_template;
			$link_template_local =~ s!%%pagenum%%!$j!g;
			$link_template_local =~ s!%%link%%!${uri}page=$j!g;
			$link_template_local =~ s!%%%ifelse-currentpage%%%(.*?)%%%else%%%(.*?)%%%endelse-currentpage%%%!$is_currentpage ? $1 : $2!egs;
			$pagelinks{$j} = $link_template_local;
		}

		foreach my $page (sort { $a <=> $b } keys %pagelinks)
		{
			$link_template_output .= $pagelinks{$page} if (($page - int($num_pagelinks/2 + .5)) <= $current_page) && ($current_page <= ($page + int($num_pagelinks/2 + .5)));
		}

		my $prevlink = $current_page > 1 ? $current_page - 1 : 1;
		my $nextlink = $current_page < $num_pages ? $current_page + 1 : $num_pages;
		$template =~ s!%%prevlink%%!${uri}page=$prevlink!g;
		$template =~ s!%%nextlink%%!${uri}page=$nextlink!g;
		$template =~ s!%%%ifelse-prevlink%%%(.*?)%%%else%%%(.*?)%%%endelse-prevlink%%%!$current_page ne 1 ? $1 : $2!egs;
		$template =~ s!%%%ifelse-nextlink%%%(.*?)%%%else%%%(.*?)%%%endelse-nextlink%%%!$current_page ne $num_pages ? $1 : $2!egs;

		$template =~ s!%%frstlink%%!${uri}page=1!g;
		$template =~ s!%%lastlink%%!${uri}page=$num_pages!g;
		$template =~ s!%%%ifelse-frstlink%%%(.*?)%%%else%%%(.*?)%%%endelse-frstlink%%%!$current_page ne 1 ? $1 : $2!egs;
		$template =~ s!%%%ifelse-lastlink%%%(.*?)%%%else%%%(.*?)%%%endelse-lastlink%%%!$current_page ne $num_pages ? $1 : $2!egs;

		$template =~ s!%%%template:linklist%%%(.+?)%%%end-template:linklist%%%!$link_template_output!gs;
		$template =~ s!%%num_items%%!$num_items!g;
		$template =~ s!%%num_pages%%!$num_pages!g;
		$template =~ s!%%itemname%%!$num_items == 1 ? $itemname_singular : $itemname_plural!eg if $itemname_singular && $itemname_plural;
		$template =~ s!%%pagename%%!$num_pages == 1 ? $pagename_singular : $pagename_plural!eg if $pagename_singular && $pagename_plural;

		return $template;
	}
	else
	{
		return '';
	}
}


sub field_structure_managed_by_us
{
	my $field = shift;
	foreach my $table (keys %{$PREF{tables_listing_fields_whose_structure_we_manage}})
	{
		sql_untaint($field,$table);
		die_unless_sqlsafe($field,$table);
		if(my ($fieldtype,$label,$listitems,$defaultvalue) = enc_sql_select("SELECT `fieldtype`,`fieldlabel`,`listitems`,`defaultvalue` FROM `$table` WHERE `fieldname` = '$field'"))
		{
			if($fieldtype =~ /^(freeformsingle|freeformmulti|dropdown|checkbox|radio)$/)
			{
				return ($fieldtype,$label,$listitems,$defaultvalue);
			}
			else
			{
				return ();
			}
		}
	}
}


sub is_valid_email_address
{
	return $_[0] =~ /^[\w\.\+-]+\@[\w\.-]+\.\w+$/;
}


sub interpolate_vars_from_URL_and_cookies
{
	my $include_undefined = 0;
	my $sql_sanitize = 0;

	my %url_vars = ();
	for(split(/&/, $qs))
	{
		my ($var,$value) = split(/=/);
		enc_urldecode($value);
		$url_vars{$var} = $value;
	}

	my %cookies = ();
	my %jar = get_cookies();
	foreach my $ck (keys %jar)
	{
		$cookies{$ck} = $jar{$ck}->value;
	}

	for(@_)
	{
		$include_undefined = $_ if $_ eq 'include_undefined';
		$sql_sanitize = $_ if $_ eq 'sql_sanitize';

		next unless m!(%URL{|%COOKIE{)!;

		if($sql_sanitize)
		{
			my %done = ();
			while(m!%URL\{([^\{\}]+)\}!g)
			{
				my $varname = $1;
				if(exists $url_vars{$varname}   &&   !$done{$varname})
				{
					sql_untaint($url_vars{$varname});
					replace_nonsqlsafe_chars_with('_', $url_vars{$varname});
					die_unless_sqlsafe($url_vars{$varname});
					$done{$varname} = 1;
				}
			}

			%done = ();
			while(m!%COOKIE\{([^\{\}]+)\}!g)
			{
				my $varname = $1;
				if(exists $cookies{$varname}   &&   !$done{$varname})
				{
					sql_untaint($cookies{$varname});
					replace_nonsqlsafe_chars_with('_', $cookies{$varname});
					die_unless_sqlsafe($cookies{$varname});
					$done{$varname} = 1;
				}
			}
		}

		s!%URL\{([^\{\}]+)\}!exists $url_vars{$1} || $include_undefined ? $url_vars{$1} : $&!eg;
		s!%COOKIE\{(.+?)\}!exists $cookies{$1} || $include_undefined ? $cookies{$1} : $&!eg;
	}
}


sub interpolate_vars_from_prefs
{
	my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0;	# 1st arg may be 'include_undefined' but does not have to be.
	for(@_)
	{
		s/%PREF{(\w+)}/exists $PREF{$1} || $include_undefined ? $PREF{$1} : $&/eg;
		s/%TEXT{(\w+)}/exists $TEXT{$1} || $include_undefined ? $TEXT{$1} : $&/eg;
	}
}


sub interpolate_vars_from_env
{
	my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0;	# 1st arg may be 'include_undefined' but does not have to be.
	for(@_)
	{
		s/%ENV{(\w+)}/exists $ENV{$1} || $include_undefined ? $ENV{$1} : $&/eg;
	}
}


sub interpolate_vars_from_sql
{
	my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0;	# 1st arg may be 'include_undefined' but does not have to be.
	for(@_)
	{
		while(m!(%SQL\{\{(.+?)\}\})!g)
		{
			my ($wholething,$sql_statement) = ($1,$2);
			get_db_connection() unless $PREF{dbh};
			interpolate_vars_from_URL_and_cookies($include_undefined, 'sql_sanitize', $sql_statement);
			my $output = enc_sql_select($sql_statement);
			s!\Q$wholething\E!$output!g;
		}
	}
}


sub interpolate_vars_from_date
{
	my $etime = $_[0] =~ /^etime=(\d+)$/ ? shift : offsettime();
	$etime =~ s/[^\d]//g;
	s!%DATE{(.+?)}!strftime($1,localtime($etime))!eg for @_;
}


sub do_standard_template_conditionals_processing
{
	for(@_)
	{
		s!%%%if-admin_is_logged_in%%%(.*?)%%%end-admin_is_logged_in%%%!$PREF{admin_is_logged_in} ? $1 : ''!egs;
		s!%%%if-admin_not_logged_in%%%(.*?)%%%end-admin_not_logged_in%%%!$PREF{admin_is_logged_in} ? '' : $1!egs;
		s!%%%if-member_is_logged_in%%%(.*?)%%%end-member_is_logged_in%%%!$PREF{member_is_logged_in} ? $1 : ''!egs;
		s!%%%if-member_not_logged_in%%%(.*?)%%%end-member_not_logged_in%%%!$PREF{member_is_logged_in} ? '' : $1!egs;

		s!%%%if-member_of_group_([^%]+)%%%(.*?)%%%end-member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? $2 : ''!egs;
		s!%%%if-not_member_of_group_([^%]+)%%%(.*?)%%%end-not_member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? '' : $2!egs;

		s!%%%ifelse-member_of_group_([^%]+)%%%(.*?)%%%else%%%(.*?)%%%endelse-member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? $2 : $3!egs;
		s!%%%ifelse-not_member_of_group_([^%]+)%%%(.*?)%%%else%%%(.*?)%%%endelse-not_member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? $3 : $2!egs;

		s!%%%if-allowed_to_(\w+)%%%(.*?)%%%end-allowed_to_\1%%%!user_is_allowed_to($1) ? $2 : ''!egs;
	}
}


sub do_standard_template_vars_processing
{
	interpolate_vars_from_sql(@_); # do this one first, so we can SQL-sanitize any nested URL/cookie variables and interpolate them manually, rather than letting the following functions do the regular interpolation with no SQL-sanitization.
	interpolate_vars_from_env(@_);
	interpolate_vars_from_prefs(@_);
	interpolate_vars_from_URL_and_cookies(@_);
	interpolate_vars_from_date(@_);
}


sub do_standard_template_leftover_nulling
{
	# Go in order from most specific to least specific.  For example, %%%set...%%%
	# is near the end, because it can contain spaces, so we need to make the
	# regex a little looser to match it.  And we explicitly match %%\w+%% even
	# though we later have a more generic %%[^%\s]+?%% because removing the
	# simple all-alphanumeric vars first makes it more straightforward to match
	# the more varied possibilities later.

	for(@_)
	{
		s!%%%if-(\S+)%%%.+?%%%end-\1%%%!!gs;
		s!%%%ifelse-(\S+)%%%.*?%%%else%%%.*?%%%endelse-\1%%%!!gs;
		s!%%%calculate:([^%]+)%%%.+?%%%end-calculate%%%!!gs;
		s!%%%customcode(:[^%]+)?%%%.+?%%%end-customcode%%%!!gs;
		s!%%\w+%%!!g;
		#s!%%[^%\s]+?%%!!g;
		s!%%%set[^%]+?%%%!!g;
	}
}


sub do_standard_template_oddeven_processing # make this your last template-processing action, so any %%oddeven%%s present will definitely be present in the output.
{
	for(@_)
	{
		my $i = 0; while(/%%oddeven%%/g) { s!%%oddeven%%!oddeven($i)!e; }
	}
}


# This sub is designed to skip any interpolations that are currently null and/or
# whose values have other raw template variables within them.  This allows the
# template's various operations and variables to be nested in arbitrarily deep
# and complex ways.  Because of this, the sub iterates multiple times, since
# items that were skipped on earlier passes will be able to be processed on
# later passes.
#
sub do_custom_template_processing
{
	my $templatevars = shift; # hashref.
	for(my $i=0; $i<8; $i++)
	{
		for(@_)
		{
			s!%%%if-([^%]+)==([^%]+)%%%(.*?)%%%end-\1==\2%%%!$1 eq $2 ? $3 : ''!egs;

			s!%%%if-is_valid_price_([^%]+)%%%(.*?)%%%end-is_valid_price_\1%%%!item_price_is_valid($1) ? $2 : ''!egs;

			#while(m!\s*%%%set-urlencoded:(\w+)=([^%]*)%%%\s*!g)
			#{
			#	my ($name,$val) = ($1,$2);
			#	enc_urlencode($val);
			#	$$templatevars{$name} = $val;
			#}

			$$templatevars{$1} = $2 while $_ =~ m!\s*%%%set:(\w+)=([^%]*)%%%\s*!g;
			s!%%(\w+?)%%!exists $$templatevars{$1} ? $$templatevars{$1} : $&!eg;
			s!%%(\w+?)_urlencoded%%!exists $$templatevars{$1} ? enc_urlencode_return($$templatevars{$1}) : $&!eg;

			while(m!(%%%calculate:([^%]+)%%%\s*(.+?)\s*%%%end-calculate%%%)!gs)
			{
				#die "code is: '$3', wholething is: '$1'";
				my ($wholething,$options,$code) = ($1,$2,$3);

				next if $code =~ /%%\w+%%/; # skip it if it still has unprocessed variables in it.

				my $output = eval $code;
				exit_with_error($1) if $output =~ /die_from_eval:(.*)/;
				my $outputvarname = '';

				for(split(/\s*,\s*/, $options))
				{
					if(/numdecimals=(\d+)/)
					{
						my $numdec = $1;
						$output =~ s/(\.\d{$numdec})\d+$/$1/;
						$output .= '.' unless $output =~ /\.\d*$/;
						$output .= '0' while length(   ($output =~ /\.(\d*)$/)[0]   ) < $numdec;
					}
					elsif(/varname=(\w+)/)
					{
						$outputvarname = $1;
					}
				}

				s!\Q$wholething\E!%%%set:$outputvarname=$output%%%!s;
			}

			while(m!(%%%customcode(:[^%]+)?%%%\s*(.+?)\s*%%%end-customcode%%%)!gs)
			{
				#die "code is: '$3', wholething is: '$1'";
				my ($wholething,$options,$code) = ($1,$2,$3);

				next if $code =~ /%%\w+%%/; # skip it if it still has unprocessed variables in it.

				my $output = eval $code;

				exit_with_error($1) if $output =~ /die_from_eval:(.*)/;

				s!\Q$wholething\E!!s;
			}

			if(exists $$templatevars{eitemcode} && exists $$templatevars{eitemname} && exists $$templatevars{eitemdesc} && exists $$templatevars{eitemopts} && exists $$templatevars{eitemcost})
			{
				$$templatevars{eitemfingerprint} = get_cart_item_fingerprint(
										$$templatevars{eitemcode},
										$$templatevars{eitemname},
										$$templatevars{eitemdesc},
										$$templatevars{eitemopts},
										$$templatevars{eitemcost}
				);
			}
		}
	}
}


# Create a fingerprint before and after adding the item to the cart, to
# prevent modification of any of the values (particularly the price).
#
sub get_cart_item_fingerprint($$$$$)
{
	return enc_hash(
			$PREF{database_name} . $PREF{database_username} . $PREF{database_password} . 
			$_[0] . $_[1] . $_[2] . $_[3] . $_[4] . 
			$ENV{DOCUMENT_ROOT} . $ENV{PATH} . $ENV{SCRIPT_FILENAME}
	);
}


sub format_xml_nicely
{
	my $input_xml = shift;
	my $output_xml = '';
	my $depth = 0;
	my $prev_line_was_opener = 0;
	while($input_xml =~ /(<[^<>]+>)/g)
	{
		my $line = $1;
		#print STDERR "Line is: '$line'\n";
		my $opener = 0;
		if($line =~ m!^<\?xml!i)
		{
			$output_xml .= "$line\n";
			next;
		}
		elsif($line =~ m!^<[^<]+/>$!)
		{
			$depth++ if $prev_line_was_opener;
		}
		elsif($line =~ m!^</[^<]+>$!)
		{
			$depth--;
			$opener = 0;
			#$line .= '-';
		}
		elsif($line =~ m!^<[^<]+>$!)
		{
			$depth++;
			$opener = 1;
			#$line .= '+';
		}

		$output_xml .= '  ' x ($depth - 1);
		$output_xml .= "$line\n";

		$prev_line_was_opener = $opener;
	}
	return $output_xml;
}


sub verify_server_environment()
{
	my ($SCRIPT_var_count, $SERVER_var_count) = (0, 0);
	my @all_vars = ();
	foreach my $var (sort keys %ENV)
	{
		$SCRIPT_var_count++ if $var =~ /^SCRIPT_/;
		$SERVER_var_count++ if $var =~ /^SERVER_/;
		push @all_vars, "$var: $ENV{$var}";
	}
	unless($SCRIPT_var_count > 0 && $SERVER_var_count > 0)
	{
		die qq`Error: it seems I've been executed on a command line, but that won't work, since I'm a web application and must be executed within a server environment.\n`; # . qq`\nAll vars: ` . (join "\n", @all_vars) . qq`\n\n`;
	}
}


sub fix_server_environment()
{
	# Fix the %ENV if necessary.
	#
	if(!$ENV{REQUEST_URI}) # IIS is crap.
	{
		$ENV{REQUEST_URI} = $ENV{PATH_INFO};
		$ENV{REQUEST_URI} .= '?' . $qs if $qs;
	}

	# Fix for broken Network Solutions servers:
	$ENV{SCRIPT_NAME} = $1 if $ENV{SCRIPT_NAME} =~ m!~\d+\.\d+/(/cgi-bin/.+)!;

	$PREF{DOCROOT} = $ENV{DOCUMENT_ROOT} unless exists $PREF{DOCROOT};
	if(!$PREF{DOCROOT})
	{
		($PREF{DOCROOT}) = ($ENV{SCRIPT_FILENAME} =~ m!^(.+)$ENV{SCRIPT_NAME}$!i);
		if(!$PREF{DOCROOT})
		{
			# try to fix IIS garbage.
			my $path_translated = $ENV{PATH_TRANSLATED};
			my $is_unc = $path_translated =~ m!^\\\\!;
			$path_translated =~ s!\\\\!/!g;
			$path_translated =~ s!\\!/!g;
			$path_translated =~ s!^[/\\]+!\\\\! if $is_unc;
			($PREF{DOCROOT}) = ($path_translated =~ m!^(.+)$ENV{PATH_INFO}$!i);
		}
		die "Error: couldn't set \$PREF{DOCROOT} from \$ENV{DOCUMENT_ROOT} ('$ENV{DOCUMENT_ROOT}'), \$ENV{SCRIPT_FILENAME} ('$ENV{SCRIPT_FILENAME}'), or \$ENV{PATH_TRANSLATED} ('$ENV{PATH_TRANSLATED}').\n" unless $PREF{DOCROOT};
	}
	$PREF{DOCROOT} =~ s![/\\]+$!! unless $PREF{DOCROOT} =~ m!^[/\\]+$!; # remove trailing slashes.

	# Fix another Network Solutions bug:
	if($PREF{DOCROOT} =~ m!/usr/services/vux/apache/htdocs!   &&   $ENV{SCRIPT_FILENAME} =~ m!(/data/\d+/\d+/\d+/\d+/\d+/user/\d+)/cgi-bin!)
	{
		$PREF{DOCROOT} = "$1/htdocs";
	}
}


sub do_blacklisting_and_whitelisting()
{
	($PREF{ip}, $PREF{host}) = get_ip_and_host();

	my $blocked = 0;

	my $ip_whitelisting_enabled = 0;
	my $user_matches_ip_whitelist = 0;
	foreach my $rule (sort keys %{$PREF{whitelisted_ip_addresses}})
	{
		if(my $allowed_ip = $PREF{whitelisted_ip_addresses}{$rule})
		{
			$ip_whitelisting_enabled = 1;
			$user_matches_ip_whitelist = 1 if $PREF{ip} =~ /$allowed_ip/;
		}
	}
	$blocked = 1 if $ip_whitelisting_enabled && !$user_matches_ip_whitelist;

	my $host_whitelisting_enabled = 0;
	my $user_matches_host_whitelist = 0;
	foreach my $rule (sort keys %{$PREF{whitelisted_hostnames}})
	{
		if(my $allowed_host = $PREF{whitelisted_hostnames}{$rule})
		{
			$host_whitelisting_enabled = 1;
			$user_matches_host_whitelist = 1 if $PREF{host} =~ /$allowed_host/i;
		}
	}
	$blocked = 1 if $host_whitelisting_enabled && !$user_matches_host_whitelist;

	foreach my $rule (sort keys %{$PREF{blacklisted_ip_addresses}})
	{
		if(my $blocked_ip = $PREF{blacklisted_ip_addresses}{$rule})
		{
			$blocked = 1 if $PREF{ip} =~ /$blocked_ip/;
		}
	}

	foreach my $rule (sort keys %{$PREF{blacklisted_hostnames}})
	{
		if(my $blocked_host = $PREF{blacklisted_hostnames}{$rule})
		{
			$blocked = 1 if $PREF{host} =~ /$blocked_host/;
		}
	}

	exit_with_error($TEXT{failed_black_or_white_list}) if $blocked;
}


sub is_zero # to differentiate values from null.
{
	return $_[0] =~ /^0$/;
}


############################################################################################################################################
### Functions: login.
############################################################################################################################################


sub do_login
{
	if($PREF{internal_appname} eq 'userbase')
	{
		$PREF{admin_is_logged_in} = 0;
		$PREF{member_is_logged_in} = 0;

		# Get the user's inputted username and password:
		my $input_username	= param($PREF{userbase_user_fieldname}) || exit_with_error(qq`$TEXT{empty_username_error}`); $input_username =~ s!^(....).*!$1!;
		my $input_password	= param($PREF{userbase_pass_fieldname}) || exit_with_error(qq`$TEXT{empty_password_error}`); $input_password =~ s!^(....).*!$1!;
		my $ref = param("ref");
		my ($expiry) = ();

		my $restrict_ip = (   ($PREF{enable_ip_address_restriction} =~ /yes/i && param("restrict_ip") =~ /on/i)   ||   ($PREF{force_ip_address_restriction} =~ /yes/i)   ) ? 1 : 0;

		# Get the crypted version of the input password:
		check_username_for_sql_safeness($input_username);
		my $salt = enc_sql_select("SELECT `salt` FROM `$PREF{user_table}` WHERE `username` = '$input_username';");


		# TODO: remove this if/else, and assume that !$salt is an error condition; but
		# not until around mid-2007 to give clients time to get switched over.
		#
		my ($crypted_input_password, $update_this_account_to_new_pw_system) = ();
		if(!$salt) # old version of UB that's pre-salt, so re-create the password hash and update it in the DB.
		{
			$crypted_input_password = md5_hex($input_password);
			$update_this_account_to_new_pw_system = 1;
		}
		else
		{
			$crypted_input_password = salt_and_crypt_password($input_password, $salt);
		}


		my $account_locked = enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `username` = '$input_username';");
		if($account_locked)
		{
			my $lock_expired = ! account_exceeds_failed_login_limit($input_username);
			if($PREF{lock_expires_automatically} =~ /yes/i   &&   $lock_expired)
			{
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = FALSE WHERE `username` = '$input_username';");
				die_nice("Error: do_login(input_username='$input_username'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;
			}
			else
			{
				sleep $PREF{num_seconds_to_sleep_on_failed_login};
				enc_redirect("$PREF{login_url}?phase=eacctlck");
			}
		}


		my $go = '';
		if(account_exists($input_username, $crypted_input_password, 'new_login'))
		{
			if(enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `username` = '$input_username';"))
			{
				enc_redirect("$PREF{login_url}?phase=eacctdis");
			}

			$PREF{member_is_logged_in} = 1; # technically true, but can still be revoked by later tests.
			$PREF{logged_in_userid} = my $userid = get_user_id($input_username);

			if(account_is_pending($PREF{logged_in_userid}))
			{
				enc_redirect("$PREF{login_url}?phase=eacctpnd");
			}

			my $session_id = create_new_session_id($input_username, $crypted_input_password);
			if(my $shared_session_id = check_for_multiple_logins($userid))
			{
				$session_id = $shared_session_id;
			}

			set_cookie($PREF{site_session_cookie}, $session_id, $expiry);

			if($update_this_account_to_new_pw_system)
			{
				my $salt = create_random_salt($PREF{salt_length});
				my $new_crypted_password = salt_and_crypt_password($input_password, $salt);
				my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `password` = '$new_crypted_password', `salt` = '$salt' WHERE `id` = $userid;");
				die_nice("Error: do_login(): SQL returned '$success' instead of '1' while updating pw and creating salt.") unless $success == 1;
				$crypted_input_password = $new_crypted_password;
			}

			unless(enc_sql_select("SELECT `failed_logins` FROM `$PREF{user_table}` WHERE `id` = $userid;") eq '')
			{
				my $statement = "UPDATE `$PREF{user_table}` SET `failed_logins` = NULL WHERE `id` = $userid;";
				my $success = enc_sql_update($statement);
				die_nice("Error: do_login(id='$userid'): SQL returned '$success' instead of '1' while updating failed_logins.  SQL was: [[$statement]]") unless $success == 1;
			}

			log_user_into_db($userid, $session_id, offsettime(), $restrict_ip);
			update_logins_table($userid, $session_id);

			if(force_pw_change($userid))
			{
				$go = $PREF{protoprefix} . $ENV{HTTP_HOST} . $PREF{login_url} . "?action=edituser&id=$userid";
			}
			else
			{
				foreach my $pref (sort keys %PREF)
				{
					if($pref =~ /^on_(.+?)_login_redirect_to$/i   &&   user_is_member_of_group($PREF{logged_in_userid}, $1)   &&   $PREF{$pref})
					{
						$go = $PREF{$pref};
						$go =~ s/%%username%%/$input_username/g;
						last;
					}
				}
			}

			$go = determine_default_login_destination($ref) if !$go;
			enc_redirect($go);
		}

		# Else they tried to log in but failed.
		else
		{
			# Be sure that we do the sleep before the email, so that any
			# potential email errors don't cause us to abort early thereby
			# skipping the sleep and possibly giving away the fact that the
			# login failed.
			#
			sleep $PREF{num_seconds_to_sleep_on_failed_login};

			my $account_locked = account_exceeds_failed_login_limit($input_username, 'increment');
			if($account_locked)
			{
				unless(enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `username` = '$input_username'"))
				{
					my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = TRUE WHERE `username` = '$input_username';");
					die_nice("Error: do_login(input_username='$input_username'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;
				}
			}

			update_failed_logins_table($input_username, $input_password);
			email_failed_logins_to_webmaster($input_username, $input_password);

			if($PREF{on_failed_login_redirect_to})
			{
				$go = $PREF{on_failed_login_redirect_to};

				if($account_locked)
				{
					$go .= $go =~ /\?/ ? '&account_locked=1' : '?account_locked=1';
				}
			}
			else
			{
				if($account_locked)
				{
					$go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?phase=eacctlck";
				}
				else
				{
					$go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?phase=ebadauth";
				}
			}

			enc_redirect($go);
		}
	}
	else
	{
		my $whence = ($qs =~ /(?:^|&)whence=(.+)/)[0];
		if($ENV{REQUEST_METHOD} =~ /post/i)
		{
			exit_with_error("You must enter the password.") if param('password') !~ /\S/;
			my $hashed_password = md5_hex(param('password'));
			my $expiry = param('persist') eq 'on' ? "+$PREF{num_days_login_lasts}d" : '';

			exit_with_error($TEXT{The_password_you_entered_is_incorrect___}) unless ($PREF{all_admin_password_hashes}{$hashed_password}   ||   $PREF{all_member_password_hashes}{$hashed_password});

			set_cookie($PREF{non_userbase_login_cookie}, $hashed_password, $expiry);
			enc_redirect(param('ref') || $whence || $PREF{here});
		}
		else
		{
			if($PREF{all_admin_password_hashes})
			{
				my $action = $PREF{internal_appname} eq 'visitorlog' ? 'action=vllogin' : 'action=login';
				$action .= $PREF{default_url_vars};
				$action .= "&amp;whence=$whence" if $whence;
				start_html_output($PREF{titlebar_title___login});
				print	  qq`<form method="post" action="$ENV{SCRIPT_NAME}?$action">`
					. qq`\n<p>$TEXT{Enter_the_password}</p>\n<input type="password" name="password" maxlength="200" class="default text" /><input type="hidden" name="ref" value="$ENV{HTTP_REFERER}" />`
					. qq`\n<br /><br /><input type="checkbox" name="persist" id="persist" /><label for="persist"> $TEXT{Keep_me_logged_in_for} $PREF{num_days_login_lasts} $TEXT{days}</label>`
					. qq`\n<br /><br /><input type="submit" value="$TEXT{Login}" class="default button submit" />\n</form>\n`;
				print $TEXT{Forgot_password_};
				finish_html_output();
			}
			else
			{
				$TEXT{password_not_set} =~ s!%%newpw_link%%!$PREF{here_login}?newpw!g;
				exit_with_output($TEXT{password_not_set});
			}
		}
	}
}


sub check_if_logged_in()
{
	my %cookies = get_cookies();
	($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_realname}, $PREF{logged_in_email}, $PREF{logged_in_userid}) = (0,0,'','','','');

	if($PREF{integrate_with_existing_login_system} =~ /yes/i   &&   $PREF{integrate_with_userbase} !~ /yes/i)
	{
		if($PREF{enable_username_from_cookie} =~ /yes/i)
		{
			my $username_in_cookie = ();
			if(exists($cookies{$PREF{admin_username_cookie_name}})   &&   ($username_in_cookie = $cookies{$PREF{admin_username_cookie_name}}->value))
			{
				($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_userid}) = (1, 1, $username_in_cookie, -3);
			}
			elsif(exists($cookies{$PREF{member_username_cookie_name}})   &&   ($username_in_cookie = $cookies{$PREF{member_username_cookie_name}}->value))
			{
				($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_userid}) = (0, 1, $username_in_cookie, -2);
			}
		}
		elsif($PREF{enable_username_from_php_session} =~ /yes/i)
		{
			my $username = '';
			my $isadmin = 0;
			if($ENV{PHP_ENC_USERNAME})
			{
				$username = $ENV{PHP_ENC_USERNAME};	save_php_var_to_cache('username',$username);
				$isadmin = $ENV{PHP_ENC_ISADMIN};	save_php_var_to_cache('isadmin',$isadmin);
			}
			else # we were POSTed to?
			{
				$username = get_php_var_from_cache('username');
				$isadmin = get_php_var_from_cache('isadmin');
			}

			if($username)
			{
				$PREF{logged_in_username}	= $username;
				$PREF{member_is_logged_in}	= 1;
				$PREF{admin_is_logged_in}	= $isadmin;
				$PREF{logged_in_userid}		= $PREF{admin_is_logged_in} ? -3 : -2;
			}
		}
		else
		{
			exit_with_error qq`To use \$PREF{integrate_with_existing_login_system}, you must also enable either \$PREF{enable_username_from_cookie} or \$PREF{enable_username_from_php_session}.`;
		}
	}
	elsif($PREF{integrate_with_userbase_method_b} =~ /yes/i   &&   $PREF{path_to_userbase})
	{
		# Won't work on many IIS configurations where executing external commands
		# from within IIS is prevented by user account policy.  But the eval method
		# in the following block works on IIS.
		#
		my $userbase_output = `export QUERY_STRING="action=chklogin" && export SCRIPT_NAME="$PREF{userbase_local_scriptname}" && "$PREF{path_to_userbase}" 2>&1`;

		if($userbase_output !~ /\w+/)
		{
			# Use "package" to create a separate namespace for this block.  This is because we're going to use
			# "eval" as a way to execute another Perl script, but we only want that script's output; we don't
			# want its globals and subroutines being imported into our namespace.  In particular we don't want
			# functions such as start_html_output() "overwriting" our own copy of that function in the main
			# namespace.
			# 
			package CALLTOUBFORLOGINCHECK;

			# Don't die/die_nice anywhere in here; we want to let the next if() check whether $userbase_output
			# is valid and then print a more useful error if not.
			#
			my $file = $PREF{path_to_userbase};
			my $file_contents = ();
			open(IN,"<$file");
			flock IN, 1;
			seek IN, 0, 0;
			while(<IN>) { $file_contents .= $_; }
			close IN;

			$file_contents =~ /(.*)/s;
			$file_contents = $1; # cheap untaint since this is our own file.

			my ($real_qs, $real_sn) = ($ENV{QUERY_STRING}, $ENV{SCRIPT_NAME});
			($ENV{QUERY_STRING}, $ENV{SCRIPT_NAME}) = ("action=chklogin&print=false", $PREF{userbase_local_scriptname});
			$userbase_output = eval $file_contents;
			($ENV{QUERY_STRING}, $ENV{SCRIPT_NAME}) = ($real_qs, $real_sn);
		}

		if($userbase_output =~ /admin=(\d):::::member=(\d):::::username=(.*?):::::userid=(\d*?):::::group_memberships=(.*?):::::realname=(.*?):::::email=(.*?):::::(.*)/s)
		{
			($PREF{admin_is_logged_in},$PREF{member_is_logged_in},$PREF{logged_in_username},$PREF{logged_in_userid},$PREF{logged_in_group_memberships},$PREF{logged_in_realname},$PREF{logged_in_email})
			= ($1,$2,$3,$4,$5,$6,$7);

			$PREF{ub_var_username}	= $PREF{logged_in_username};
			$PREF{ub_var_userid}	= $PREF{logged_in_userid};
			$PREF{ub_var_realname}	= $PREF{logged_in_realname};
			$PREF{ub_var_email}	= $PREF{logged_in_email};

			if(my $other_ub_vars = $8)
			{
				while($other_ub_vars =~ /(.+?)=(.+?):::::/g)
				{
					$PREF{"ub_var_$1"} = $2;
					$PREF{"logged_in_$1"} = $2 unless $PREF{"logged_in_$1"};
				}
			}
		}
		else
		{
			exit_with_error("$PREF{internal_appname}: check_if_logged_in(): integrate_with_userbase_method_b failed: UserBase output was: "
				. ($userbase_output ? 'null' : "[[ $userbase_output ]] ")
				. qq`<br /><br />\n\nMake sure you've got UserBase itself running properly before trying this.`
			);
		}
	}
	elsif(userbase_available())
	{
		if(my $session_id = get_cookie($PREF{site_session_cookie}))
		{
			check_sessionid_for_sql_safeness($session_id);

			my ($username,$realname,$email,$id,$ip) = enc_sql_select("SELECT username,name,email,id,ip FROM `$PREF{user_table}` WHERE `mrsession` = '$session_id';");

			if($username   &&   $id   &&   !account_is_pending($id))
			{
				if(($PREF{enable_ip_address_restriction} =~ /yes/i && $ip) || ($PREF{force_ip_address_restriction} =~ /yes/i))
				{
					return unless $ip eq $ENV{REMOTE_ADDR};
				}
				if(enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = '$id';"))
				{
					enc_redirect("$PREF{login_url}?phase=eacctdis");
				}

				$PREF{logged_in_username} = $username;
				$PREF{logged_in_realname} = $realname;
				$PREF{logged_in_email} = $email; $PREF{logged_in_email} = $PREF{logged_in_username} if ($PREF{logged_in_email} !~ /.+\@.+\..+/ && $PREF{logged_in_username} =~ /.+\@.+\..+/);
				$PREF{logged_in_userid} = $id;
				$PREF{member_is_logged_in} = 1;

				if(is_admin($PREF{logged_in_userid}))
				{
					$PREF{admin_is_logged_in} = 1;
				}

				$PREF{ub_var_username}	= $PREF{logged_in_username};
				$PREF{ub_var_userid}	= $PREF{logged_in_userid};
				$PREF{ub_var_realname}	= $PREF{logged_in_realname};
				$PREF{ub_var_email}	= $PREF{logged_in_email};

				foreach my $customfield (get_custom_userbase_field_names($PREF{user_table}))
				{
					my $value = enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}'");
					$PREF{"ub_var_$customfield"} = $value;
					$PREF{"logged_in_$customfield"} = $value unless $PREF{"logged_in_$customfield"};
				}

				check_and_update_login_session($PREF{logged_in_userid});

				if(force_pw_change($PREF{logged_in_userid}))
				{
					if($PREF{internal_appname} eq 'userbase')
					{
						if($qs !~ /^(logout|logoutall|action=commitedituser)$/)
						{
							print_user_form('edit', $PREF{logged_in_userid});
							exit;
						}
					}
					else
					{
						enc_redirect("$PREF{login_url}?action=edituser&id=$PREF{logged_in_userid}");
					}
				}
			}
		}
	}
	elsif($PREF{all_admin_password_hashes} || $PREF{all_member_password_hashes})
	{
		my $hashed_password_in_cookie = get_cookie($PREF{non_userbase_login_cookie});

		if($hashed_password_in_cookie   &&   $PREF{all_admin_password_hashes}{$hashed_password_in_cookie})
		{
			($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_userid}) = (1, 1, '', -3);
		}
		elsif($hashed_password_in_cookie   &&   $PREF{all_member_password_hashes}{$hashed_password_in_cookie})
		{
			($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_userid}) = (0, 1, '', -2);
		}
		# TODO: explicitly set 0/0/''/-1 for strangers?
	}
}


sub check_and_update_login_session($)
{
	my $userid = shift;
	my $my_session_id = get_cookie($PREF{site_session_cookie});
	my $session_id_in_db = enc_sql_select("SELECT `mrsession` FROM `$PREF{user_table}` WHERE `id` = $userid;");
	my $login_time = enc_sql_select("SELECT `loggedin` FROM `$PREF{user_table}` WHERE `id` = $userid;");

	#if(   ($my_session_id == $session_id_in_db)   &&   ($login_time =~ /[1-9]/   &&   !login_session_expired($login_time))   )
	 if(   ($my_session_id == $session_id_in_db)   &&   (!login_session_expired($login_time))   )
	{
		 update_loggedin_time($userid, $my_session_id, offsettime());
	}
	else
	{
		do_logout() if $PREF{idle_timeout} > 0;
	}
}


sub update_loggedin_time
{
	my ($userid, $my_session_id, $newtime) = @_;

	die_unless_numeric($userid,'userid');
	die_unless_numeric($newtime,'newtime');
	check_sessionid_for_sql_safeness($my_session_id);

	my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `loggedin` = $newtime WHERE `id` = $userid AND `mrsession` = '$my_session_id';");
	die_nice("Error: update_loggedin_time('$userid', '$my_session_id', '$newtime'): SQL returned '$success' instead of '1' while updating loggedin.") unless $success == 1;

	if(db_column_exists('lastactive', $PREF{user_table})) # for backwards compatibility with older versions of apps.
	{
		my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `lastactive` = $newtime WHERE `id` = $userid AND `mrsession` = '$my_session_id';");
		die_nice("Error: update_loggedin_time('$userid', '$my_session_id', '$newtime'): SQL returned '$success' instead of '1' while updating lastactive.") unless $success == 1;
	}
}


sub login_session_expired($)
{
	my $loggedin_time = shift;
	return (

		(   ($PREF{idle_timeout} > 0)   &&   (offsettime() - $loggedin_time > $PREF{idle_timeout})   )

	);
}


sub do_logout
{
	if($PREF{internal_appname} eq 'userbase')
	{
		my $force_logout_all = shift; $force_logout_all = $force_logout_all eq 'all' ? 1 : 0;

		if($PREF{we_are_virtual})
		{
			print_http_headers();
			$PREF{forced_logout_link} =~ s/%%logout_url%%/$ENV{SCRIPT_NAME}?logout/g;
			print $PREF{forced_logout_link};
			exit;
		}
		else
		{
			my $ref = $ENV{HTTP_REFERER};
			if($ref)
			{
				# Remove the "logout" from the referrer, otherwise we'll get stuck
				# in an infinite logout loop with this Location: call.
				$ref =~ s/\?.*log(ged)?out.*//;

				#my $us1 = $PREF{login_url};
				#my $us2 = $ENV{SCRIPT_NAME};
				#if($ref =~ /($us1|$us2)\?.+/)
				#{
				#	# If the page we were on before was a login page with some
				#	# query-string, then don't go there.
				#	$ref = '';
				#}
			}

			my $whence = '';
			if($PREF{member_is_logged_in})
			{
				if($PREF{prevent_multiple_simultaneous_logons_per_username} =~ /yes/i   ||   $force_logout_all)
				{
					log_user_out_of_db($PREF{logged_in_username}, get_cookie($PREF{site_session_cookie}));
				}
				else
				{
					die_unless_numeric($PREF{logged_in_userid}, 'logged_in_userid');
					my $numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}';");
					if($numusers > 1)
					{
						my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `numusers`=GREATEST((`numusers`-1),0) WHERE `id` = '$PREF{logged_in_userid}';");
						die_nice("Error: do_logout(): SQL returned '$success' instead of '1' while decrementing numusers column.") unless $success == 1;
					}
					else
					{
						log_user_out_of_db($PREF{logged_in_username}, get_cookie($PREF{site_session_cookie}));
					}
				}

				set_cookie($PREF{site_session_cookie}, 0, '-1M');

				if($PREF{admin_is_logged_in}   &&   $PREF{on_admin_logout_redirect_to})
				{
					$PREF{on_admin_logout_redirect_to} =~ s/%%username%%/$PREF{logged_in_username}/g;
					enc_redirect($PREF{on_admin_logout_redirect_to});
				}
				elsif($PREF{member_is_logged_in}   &&   !$PREF{admin_is_logged_in}   &&   $PREF{on_member_logout_redirect_to}) # need the !admin because admins are members too.
				{
					$PREF{on_member_logout_redirect_to} =~ s/%%username%%/$PREF{logged_in_username}/g;
					enc_redirect($PREF{on_member_logout_redirect_to});
				}
				else
				{
					# After logging out, return to the page we were on.
					$whence = $ref;
				}
			}
			else
			{
				$whence = $ref;
			}

			$whence =~ s!^https?://$ENV{HTTP_HOST}!!; # some servers don't like extra "http://"s in URLs.
			enc_urlencode($whence);
			$whence = '' if $PREF{server_bug_prohibits_use_of_whence} =~ /yes/i;
			enc_redirect("$PREF{login_url}?action=loggedout&whence=$whence");
		}
	}
	else
	{
		my $go = '';
		if($PREF{integrate_with_userbase} =~ /yes/i   ||   $PREF{integrate_with_userbase_method_b} =~ /yes/i   ||   $PREF{integrate_with_existing_login_system} =~ /yes/i)
		{
			$go = $PREF{logout_url};
		}
		else
		{
			set_cookie($PREF{non_userbase_login_cookie}, 'blank', '-1d');
			my $whence = $ENV{HTTP_REFERER};
			$whence =~ s!^https?://$ENV{HTTP_HOST}!!; # some servers don't like extra "http://"s in URLs.
			$whence =~ s/\?logout$//; # Remove "logout" from the ref so we don't get stuck in an infinite loop.
			$go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{here_login}?action=loggedout&whence=$whence";
		}

		if($PREF{we_are_virtual})
		{
			print_http_headers();
			if($PREF{use_javascript_redirect_when_necessary} !~ /no/i)
			{
				print qq`\n<script type="text/javascript">location.href="$go";</script>\n`;
			}
			else
			{
				$PREF{forced_logout_link} =~ s/%%logout_url%%/$go/g;
				print $PREF{forced_logout_link};
			}
			exit;
		}
		else
		{
			enc_redirect($go);
		}
	}
}


sub show_loggedout_page
{
	my $ref = shift;
	enc_urldecode($ref);
	my $message = $PREF{loggedout_page_template__no_referer};
	if($ref)
	{
		$message = $PREF{loggedout_page_template__with_referer};
		$message =~ s/%%ref%%/$ref/g;
	}
	exit_with_success($message);
}


# This function must do a case-sensitive lookup (i.e., do NOT use LOWER()) because
# FC's userdirs are case-sensitive.  So whatever case is used when a username is
# created is the case that must always be used when logging in with it.
#
sub account_exists($$$)
{
	#printd "account_exists('$_[0]', '$_[1]', '$_[2]')\n";

	my $user = shift;
	my $pass = shift;
	my $third_arg = shift;

	check_username_for_sql_safeness($user);
	check_hashedpw_for_sql_safeness($pass);

	my $count = ();
	if($third_arg eq 'new_login')
	{
		$count = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE `username` = '$user' AND `password` = '$pass'");
	}
	else
	{
		die_unless_numeric($third_arg,'userid');
		$count = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE `username` = '$user' AND `password` = '$pass' AND `id` = $third_arg");
	}

	if($count == 1)		{ return 1; }
	elsif($count > 1)	{ die_nice("$0: account_exists('$user', '$pass', '$third_arg'): error: duplicate records ($count total) for this user!\n"); }
	else			{ return 0; }
}


sub account_is_pending
{
	return 0 if !userbase_available();
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_is_pending()");
	return (account_is_pending_email_verification($userid) || account_is_pending_admin_approval($userid) || account_is_pending_payment($userid));
}


sub account_is_pending_email_verification
{
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_is_pending_email_verification()");
	return enc_sql_select("SELECT `pending_email_verification` FROM `$PREF{user_table}` WHERE `id` = $userid");
}


sub account_has_completed_email_verification
{
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_has_completed_email_verification()");
	return enc_sql_select("SELECT `completed_email_verification` FROM `$PREF{user_table}` WHERE `id` = $userid");
}


sub account_is_pending_admin_approval
{
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_is_pending_admin_approval()");
	return enc_sql_select("SELECT `pending_admin_approval` FROM `$PREF{user_table}` WHERE `id` = $userid");
}


sub account_is_pending_payment
{
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_is_pending_payment()");
	return enc_sql_select("SELECT `pending_payment` FROM `$PREF{user_table}` WHERE `id` = $userid");
}


sub account_has_completed_payment
{
	my $userid = shift;
	die_unless_numeric($userid, "user ID in account_has_completed_payment()");
	return enc_sql_select("SELECT COUNT(*) FROM `$PREF{payments_table}` WHERE `userid` = $userid");
}


sub get_custom_userbase_field_names
{
	my $which_user_table = shift;
	my $include_disabled_fields = shift;

	my (@custom_fields, %custom_fields) = ();
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_table}`"))
	{
		my ($fieldname,$fieldlabel,$enabled) = ();
		my $sth = $PREF{dbh}->prepare("SELECT fieldname,fieldlabel,enabled FROM `$PREF{custom_field_table}` ORDER BY `fieldposition`");
		$sth->execute() or die_nice("$PREF{internal_appname}: Error: get_custom_userbase_field_names(): $DBI::errstr\n");
		$sth->bind_columns(\$fieldname,\$fieldlabel,\$enabled);
		while($sth->fetchrow_arrayref)
		{
			next unless db_column_exists($fieldname, $which_user_table);
			next if (!$enabled   &&   !$include_disabled_fields);
			$custom_fields{$fieldname} = 1;
			push @custom_fields, $fieldname;
		}
	}

	return wantarray ? @custom_fields : \%custom_fields;
}


sub is_admin($)
{
	#printd "is_admin('$_[0]')\n";

	my $userid = shift;
	return 0 unless $userid;

	return 1 if (!userbase_available()   &&   $userid == -3);

	# don't bother checking the validity of $userid here,
	# because user_is_member_of_group() will do it.
	return user_is_member_of_group($userid,$PREF{admin_group_name});
}


sub force_pw_change($)
{
	my $userid = shift;
	my $force_pw_change = 0;

	if(		$PREF{enable_forced_password_change} =~ /yes/i
			&&
			enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$userid';")
			&&
			(
				!is_admin($userid)
				||
				(is_admin($userid) && $PREF{admins_can_be_forced_to_change_their_own_pws} =~ /yes/i)
			)
	)
	{
		$force_pw_change = 1;
	}

	if(password_has_expired())
	{
		$force_pw_change = 1;
	}

	return $force_pw_change;
}


sub password_has_expired
{
	my $expired = 0;
	if($PREF{force_pw_chng_after_this_many_hours} =~ /^\d+$/ && $PREF{force_pw_chng_after_this_many_hours} > 0)
	{
		my $time_now = offsettime();

		die_unless_numeric($PREF{logged_in_userid}, '$PREF{logged_in_userid}');
		my $time_of_last_pw_change = enc_sql_select("SELECT MAX(`timestamp`) FROM `$PREF{password_activity_table}` WHERE `user_id` = $PREF{logged_in_userid}");

		$expired = 1 if ($time_now - $time_of_last_pw_change) > ($PREF{force_pw_chng_after_this_many_hours} * 3600);
	}
	return $expired;
}


sub get_group_id($)
{
	printd "get_group_id($_[0])\n";
	my $group = shift;

	if(userbase_available())
	{
		check_groupname_for_uniqueness($group); # checks for sql safeness too.
		return enc_sql_select("SELECT `id` FROM `$PREF{group_table}` WHERE `group` = '$group'");
	}
	else
	{
		   if($group =~ /^$PREF{public_group_name}$/i)	{ return -1; }
		elsif($group =~ /^$PREF{member_group_name}$/i)	{ return -2; }
		elsif($group =~ /^$PREF{admin_group_name}$/i)	{ return -3; }
		else { die_nice("$PREF{internal_appname}: get_group_id(): invalid group name '$group'.\n"); }
	}
}


sub check_uid_for_uniqueness($)
{
	check_id_for_sql_safeness($_[0]);
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE `id` = $_[0]")   >   1)
	{
		die_nice("$0: error: more than one user record with id=$_[0]!\n");
	}
}


sub check_gid_for_uniqueness($)
{
	return unless userbase_available();
	printd "check_gid_for_uniqueness: '$_[0]'\n";

	check_id_for_sql_safeness($_[0]);
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE `id` = $_[0]")   >   1)
	{
		die_nice("$0: error: more than one group record with id=$_[0]!\n");
	}
}


sub check_username_for_uniqueness($)
{
	#printd "check_username_for_uniqueness: '$_[0]'\n";

	check_username_for_sql_safeness($_[0]);
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$_[0]')")   >   1)
	{
		die_nice("$0: error: more than one user record with username='$_[0]'!\n");
	}
}


sub check_groupname_for_uniqueness
{
	return unless userbase_available();
	printd "check_groupname_for_uniqueness($_[0])\n";

	check_groupname_for_sql_safeness($_[0]);
	if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$_[0]')")   >   1)
	{
		die_nice("$0: error: more than one user record with groupname='$_[0]'!\n");
	}
}


sub user_is_member_of_group
{
	my $userid = shift;
	my $group = shift;
	my $not_checking_loggedin_user = shift;

	if($PREF{integrate_with_userbase_method_b} =~ /yes/i   &&   $PREF{logged_in_group_memberships}   &&   !$not_checking_loggedin_user)
	{
		return $PREF{logged_in_group_memberships} =~ /(^|,)$group(,|$)/;
	}
	if(userbase_available()   &&   ($PREF{member_is_logged_in} || $not_checking_loggedin_user))
	{
		check_groupname_for_sql_safeness($group);
		die_unless_numeric($userid,'userid');

		return 1 if $group =~ /^$PREF{public_group_name}$/i;
		return 1 if $group =~ /^$PREF{member_group_name}$/i && enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE `id` = $userid;");

		return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group') AND `members` REGEXP '(^|,)$userid(,|\$)'");
	}
	else
	{
		return 1 if $group =~ /^$PREF{public_group_name}$/i;
		return 1 if $group =~ /^$PREF{member_group_name}$/i && $userid =~ /^-(2|3)$/;
		return 1 if $group =~ /^$PREF{admin_group_name}$/i && $userid == -3;
	}
}


sub userbase_available
{
	return ($PREF{internal_appname} eq 'userbase'   ||   $PREF{integrate_with_userbase} =~ /yes/i   ||   $PREF{integrate_with_userbase_method_b} =~ /yes/i);
}


sub get_user_id($)
{
	#printd "get_user_id('$_[0]')\n";

	my $username = shift;

	if(userbase_available()   &&   $username)
	{
		die_nice("Error: invalid username '$username'.\n") unless username_is_valid($username);
		check_username_for_uniqueness($username); # checks for sql safeness too.
		return enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username')");
	}
	else
	{
		   if($PREF{admin_is_logged_in})	{ return -3; }
		elsif($PREF{member_is_logged_in})	{ return -2; }
		else					{ return -1; } # stranger.
	}
}


sub get_member_ids_for_group
{
	printd "get_member_ids_for_group($_[0])\n";

	my $group = shift;
	check_groupname_for_sql_safeness($group);

	 # every account is automatically a member of these groups.
	if($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i)
	{
		my $statement = "SELECT `id` FROM `$PREF{user_table}`";
		return $PREF{dbh}->selectall_hashref($statement, 'id');
	}
	else
	{
		my $member_ids = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group')");
		my %member_ids = map { $_ => 1 } split(/,/, $member_ids);
		return \%member_ids;
	}
}


sub get_user_name($)
{
	check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
	return enc_sql_select("SELECT `username` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
}


sub get_group_name($)
{
	my $gid = shift;
	if(userbase_available())
	{
		check_gid_for_uniqueness($gid); # checks for sql safeness too.
		return enc_sql_select("SELECT `group` FROM `$PREF{group_table}` WHERE `id` = $gid");
	}
	else
	{
		   if($gid == -1)	{ return $PREF{public_group_name}; }
		elsif($gid == -2)	{ return $PREF{member_group_name}; }
		elsif($gid == -3)	{ return $PREF{admin_group_name}; }
		else { die_nice("$PREF{internal_appname}: get_group_name(): invalid group ID '$gid'.\n"); }
	}
}


sub hashedpw_is_valid				{ return  $_[0] =~ /^[0-9A-Za-z]+$/					&&	length($_[0]) < $PREF{max_hashedpw_length};	}
sub sessionid_is_valid				{ return  $_[0] =~ /^[0-9A-Za-z]+$/					&&	length($_[0]) < $PREF{max_hashedpw_length};	}


sub username_is_valid
{
	my $space = $PREF{allow_spaces_in_usernames} =~ /yes/i ? ' ' : '';
	my $atsign = $PREF{allow_atsigns_in_usernames} =~ /yes/i ? '@' : '';
	my $dot = $PREF{allow_dots_in_usernames} =~ /yes/i ? '.' : '';
	my $dash = $PREF{allow_dashes_in_usernames} =~ /yes/i ? '-' : '';

	return ($_[0] =~ /^[0-9A-Za-z_$space$atsign$dot$dash]+$/   &&   $_[0] =~ /\w/	&&	length($_[0]) <= (3+1));
}

sub groupname_is_valid
{
	my $space	= ($PREF{allow_spaces_in_usernames} =~ /yes/i	|| $PREF{allow_spaces_in_groupnames} =~ /yes/i)		? ' ' : '';
	my $atsign	= ($PREF{allow_atsigns_in_usernames} =~ /yes/i	|| $PREF{allow_atsigns_in_groupnames} =~ /yes/i)	? '@' : '';
	my $dot		= ($PREF{allow_dots_in_usernames} =~ /yes/i	|| $PREF{allow_dots_in_groupnames} =~ /yes/i)		? '.' : '';
	my $dash	= ($PREF{allow_dashes_in_usernames} =~ /yes/i	|| $PREF{allow_dashes_in_groupnames} =~ /yes/i)		? '-' : '';

	return ($_[0] =~ /^[0-9A-Za-z_$space$atsign$dot$dash]+$/   &&   $_[0] =~ /\w/	&&	length($_[0]) <= $PREF{max_groupname_length});
}

sub check_hashedpw_for_sql_safeness		{ die_nice("Invalid hashed password: '$_[0]'") unless hashedpw_is_valid($_[0]);						}
sub check_username_for_sql_safeness		{ die_nice("Invalid username: '$_[0]'") unless username_is_valid($_[0]);						}
sub check_groupname_for_sql_safeness		{ die_nice(qq`Invalid groupname: '$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless groupname_is_valid($_[0]);	}
sub check_sessionid_for_sql_safeness		{ die_nice("Invalid session ID: '$_[0]'") unless sessionid_is_valid($_[0]);						}
sub check_id_for_sql_safeness			{ die_nice("Invalid ID: '$_[0]'") unless $_[0] =~ /^(\d+|-[123])$/;							}


sub get_groups_hash
{
	printd "get_groups_hash('$_[0]')\n";

	# If you pass in a uid, then the resulting hash will
	# also indicate which groups that user is a member of.
	#

	my $user_id = shift;

	my ($id, $group, $members, %groups) = ();
	if(userbase_available())
	{
		my $sth = $PREF{dbh}->prepare("SELECT `id`, `group`, `members` FROM `$PREF{group_table}`");
		$sth->execute();
		$sth->bind_columns(\$id, \$group, \$members);
		while($sth->fetchrow_arrayref)
		{
			$groups{$group}{name} = $group;
			$groups{$group}{id} = $id;

			my $is_member = ();
			   if($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i)	{ $is_member = 1; }
			elsif($user_id =~ /^\d+$/)							{ $is_member = $members =~ /(^|,)$user_id(,|$)/; }

			$groups{$group}{is_member} = $is_member;
		}
	}
	else
	{
		$groups{$PREF{public_group_name}}{name}		= $PREF{public_group_name};
		$groups{$PREF{public_group_name}}{id}		= -1;
		$groups{$PREF{public_group_name}}{is_member}	= 1; # everyone's a member of the public.

		$groups{$PREF{member_group_name}}{name}		= $PREF{member_group_name};
		$groups{$PREF{member_group_name}}{id}		= -2;
		$groups{$PREF{member_group_name}}{is_member}	= 1 if $user_id =~ /^-(2|3)$/;

		$groups{$PREF{admin_group_name}}{name}		= $PREF{admin_group_name};
		$groups{$PREF{admin_group_name}}{id}		= -3;
		$groups{$PREF{admin_group_name}}{is_member}	= 1 if $user_id =~ /^-3$/;
	}

	return \%groups;
}


# This function must do a case-insensitive lookup (i.e. use LOWER() on both sides)
# so that we never create a username multiple times with different cases.
#
sub username_is_taken
{
	return 0 unless userbase_available();
	my $user = shift;
	check_username_for_sql_safeness($user);
	return enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$user')");
}


sub email_address_is_taken
{
	my $address = shift;
	check_emailaddr_for_sql_safeness($address);
	return enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE LOWER(`email`) = LOWER('$address')");
}


sub salt_and_crypt_password($$)
{
	my $plaintext_password = shift;
	my $salt = shift;
	die "$0: salt_and_crypt_password(): no salt?\n" unless $salt;
	my ($salt1,$salt2) = ($salt =~ /^(.{15})(.{25})$/);
	my $crypted_password = enc_hash($salt1 . $plaintext_password . $salt2);
	return $crypted_password;
}


sub make_password_hash
{
	if($ENV{REQUEST_METHOD} =~ /post/i)
	{
		my $hashed_password = md5_hex(param('password'));
		start_html_output('Here is your hashed password...');
		print	  qq`<p>The hashed version of the password you just entered is:</p><p>$hashed_password</p>`
			. qq`<p>Now open your prefs file and paste this hash into one of the `
			. qq`\n\$PREF{admin_password_hash*} or \$PREF{member_password_hash*} settings.</p>`;
		finish_html_output();
		
	}
	else
	{
		start_html_output('Enter your new password');
		print	  qq`<form method="post" action="$ENV{SCRIPT_NAME}?newpw">`
			. qq`\nEnter your new password:`
			. qq`\n<br /><br /><input type="password" name="password" maxlength="200" class="default text" />`
			. qq`\n<br /><br /><input type="submit" value="create hash" class="default button submit" />`
			. qq`\n</form>`;
		finish_html_output();
	}
}


sub user_is_allowed_to
{
	# TODO: these separate per-app branches can probably be partially or totally reconciled.

	if($PREF{internal_appname} eq 'userbase')
	{
		my $userid_performing_action = scalar(@_) == 1 ? $PREF{logged_in_userid} : shift; # if only 1 arg was passed, it's the action, implying we should automatically use the logged_in_userid.
		my $action = shift;
		my $user_affected_by_action = shift;
		my $userid_affected_by_action = get_user_id($user_affected_by_action);

		if($action eq 'edit_user_info')
		{
			return 1 if (logged_in_user_is_subgroup_manager()   &&   $userid_affected_by_action   &&   logged_in_subgroup_manager_owns_this_user($userid_affected_by_action));
		}

		foreach my $group (split(/\s*,\s*/, $PREF{"groups_not_allowed_to_$action"}))
		{
			return 0 if user_is_member_of_group($userid_performing_action, $group);
		}

		foreach my $group (split(/\s*,\s*/, $PREF{"groups_not_allowed_to_$action"}))
		{
			if($group =~ /^self$/i)
			{
				return 0 if ($PREF{member_is_logged_in}   &&   $userid_performing_action == $userid_affected_by_action);
			}
			else
			{
				return 0 if user_is_member_of_group($userid_performing_action, $group);
			}
		}

		foreach my $group (split(/\s*,\s*/, $PREF{"groups_allowed_to_$action"}))
		{
			if($group =~ /^self$/i)
			{
				return 1 if ($PREF{member_is_logged_in}   &&   $userid_performing_action == $userid_affected_by_action);
			}
			else
			{
				return 1 if user_is_member_of_group($userid_performing_action, $group);
			}
		}

		return 0;
	}
	else
	{
		my $action = shift;
		foreach my $group (split(/\s*,\s*/, $PREF{"groups_not_allowed_to_$action"}))
		{
			return 0 if user_is_member_of_group($PREF{logged_in_userid}, $group);
		}
		foreach my $group (split(/\s*,\s*/, $PREF{"groups_allowed_to_$action"}))
		{
			return 1 if user_is_member_of_group($PREF{logged_in_userid}, $group);
		}
		return 0;
	}
}


sub logged_in_user_is_part_of_a_subgroup()
{
	#foreach my $group (enc_sql_select("SELECT "))
	#{
	#	if($group =~ /.+$PREF{subgroup_groupname_suffix}$/i)
	#	{
	#		return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group') AND `members` REGEXP '(^|,)$PREF{logged_in_userid}(,|\$)'");
	#	}
	#}

	my $subgroup_groupname_suffix = $PREF{subgroup_groupname_suffix};
	sql_untaint($subgroup_groupname_suffix);
	exit_with_error("logged_in_user_is_part_of_a_subgroup() not SQL safe: \$subgroup_groupname_suffix ('$subgroup_groupname_suffix').") if not_sqlsafe($subgroup_groupname_suffix);

	die_unless_numeric($PREF{logged_in_userid}, '$PREF{logged_in_userid}');

	return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE `group` REGEXP '.+$subgroup_groupname_suffix\$' AND `members` REGEXP '(^|,)$PREF{logged_in_userid}(,|\$)'");
}


sub logged_in_user_is_subgroup_manager
{
	foreach my $group (split(/\s*,\s*/, $PREF{groups_that_can_manage_subgroup_users}))
	{
		return 1 if user_is_member_of_group($PREF{logged_in_userid}, $group);
	}
	return 0;
}


sub logged_in_subgroup_manager_owns_this_user($)
{
	my $userid_to_check = shift;
	return user_is_member_of_group($userid_to_check, "$PREF{logged_in_username}$PREF{subgroup_groupname_suffix}");
}


sub exit_with_access_denied
{
	exit_with_needprivs();
}


##############################################################################
### Dispatch-UB: #############################################################
##############################################################################


load_prefs();

   if($qs eq 'logout')							{ do_logout();					}
elsif($qs eq 'logoutall')						{ do_logout('all');				}
elsif($qs =~ /(?:^|&)action=loggedout&whence=(.*)(?:&|$)/)		{ show_loggedout_page($1);			} # note that the whence regex is .* not .*? because the value will likely contain ampersands that we want to keep.

# note: this must happen before most other checks in the dispatch chain, to prevent stuff that doesn't belong in the mini section from showing up there.
elsif($qs =~ /(?:^|&)format=justlink(?:&|$)/)				{ print_login_logout_link_and_exit();		}
elsif($qs =~ /(?:^|&)format=mini(?:&|$)/)				{ $PREF{member_is_logged_in} ? print_main_menu() : prompt_for_login(); }

elsif($qs =~ /(?:^|&)kmsg=(\w+)(?:&|$)/)				{ exit_with_kmsg($1);				}

elsif($qs =~ /createrandomadmin/ && $PREF{allow_random_admin_account_creation} =~ /yes/i) { create_random_admin_account_and_exit();	}

elsif($qs =~ /(?:^|&)action=showusers(?:&|$)/)				{ showusers();					}
elsif($qs =~ /(?:^|&)action=(signup|newaccount)(?:&|$)/)		{ print_user_form('user_signup');		}
elsif($qs =~ /(?:^|&)action=adduser(?:&|$)/)				{ print_user_form('added_by_admin');		}
elsif($qs =~ /(?:^|&)action=edituser(?:&|$)/)				{ print_user_form('edit');			}
elsif($qs =~ /(?:^|&)action=commitadduser(?:&|$)/)			{ process_new_account();			}
elsif($qs =~ /(?:^|&)action=commitedituser(?:&|$)/)			{ edit_user_account();				}
elsif($qs =~ /(?:^|&)action=verify&u=(\d+)&t=(\w+)(?:&|$)/)		{ do_email_verification($1,$2);			}
elsif($qs =~ /(?:^|&)action=approve_or_del&uid=(\d+)(?:&|$)/)		{ approve_or_delete_pending_account($1);	}
elsif($qs =~ /(?:^|&)action=approve_pending_acct&uid=(\d+)(?:&|$)/)	{ approve_or_delete_pending_account_stage2($1,'approve');	}
elsif($qs =~ /(?:^|&)action=delete_pending_acct&uid=(\d+)(?:&|$)/)	{ approve_or_delete_pending_account_stage2($1,'delete');	}
elsif($qs =~ /(?:^|&)action=showlogins(?:&|$)/)				{ show_logins();				}
elsif($qs =~ /(?:^|&)action=showfailedlogins(?:&|$)/)			{ show_failed_logins();				}
elsif($qs =~ /(?:^|&)action=showpwlog(?:&|$)/)				{ show_password_activity();			}

elsif($qs =~ /(?:^|&)action=deletecustomfield&id=(.+?)(?:&|$)/)		{ delete_custom_field($1);			}
elsif($qs =~ /(?:^|&)action=commitdeletecustomfield&id=(.+?)(?:&|$)/)	{ commit_delete_custom_field($1);		}

elsif($qs =~ /(?:^|&)action=commitdeleteuser&id=(.+?)(?:&|$)/)		{ commit_delete_user($1);			}

# old group-management subs: TODO: delete these lines & the called subs:
elsif($qs =~ /(?:^|&)action=showgroups(?:&|$)/)				{ showgroups();					}
elsif($qs =~ /(?:^|&)action=addgroup(?:&|$)/)				{ print_group_form('add');			}
elsif($qs =~ /(?:^|&)action=editgroup&id=(\d+)(?:&|$)/)			{ print_group_form('edit',$1);			}
elsif($qs =~ /(?:^|&)action=commitaddgroup(?:&|$)/)			{ process_new_group();				}
elsif($qs =~ /(?:^|&)action=commiteditgroup(?:&|$)/)			{ edit_group();					}
elsif($qs =~ /(?:^|&)action=deletegroup&id=(.+?)(?:&|$)/)		{ delete_group($1);				}
elsif($qs =~ /(?:^|&)action=commitdeletegroup&id=(.+?)(?:&|$)/)		{ commit_delete_group($1);			}

# new group-management subs:
elsif($qs =~ /(?:^|&)action=groups(?:&|$)/)				{ show_groups_table();				}

elsif($qs =~ /(?:^|&)action=validate(?:&|$)/)				{ do_login();					}
elsif($qs =~ /(?:^|&)action=chklogin(?:&|$)/)				{ check_login();				}
#elsif($qs =~ /(?:^|&)action=chpw(?:&|$)/)				{ chpw();					}
#elsif($qs =~ /(?:^|&)action=chpw2(?:&|$)/)				{ chpw2();					}

elsif($qs =~ /(?:^|&)action=addcustomfield(?:&|$)/)			{ add_or_edit_custom_fields('add');		}
elsif($qs =~ /(?:^|&)action=editcustomfield(?:&|$)/)			{ add_or_edit_custom_fields('edit');		}
elsif($qs =~ /(?:^|&)action=import(?:&|$)/)				{ import_users();				}

elsif($qs =~ /(?:^|&)action=pwreset1(?:&|$)/)				{ print_pwreset_page();				}
elsif($qs =~ /(?:^|&)action=pwreset2(?:&|$)/)				{ send_pwreset_email();				}
elsif($qs =~ /(?:^|&)action=pwreset3(?:&|$)/)				{ process_pwreset();				}

elsif($qs =~ /(?:^|&)action=test(?:&|$)/)				{ test_function();				}

elsif($qs =~ /(?:^|&)rslt=\d+(?:&|$)/)					{ show_results_page();				}
elsif($qs =~ /(?:^|&)phase=([es].+?)(?:&|$)/)				{ show_message($1);				}

elsif($qs =~ /(?:^|&)action=startpayment&type=(\d+)&uid=(\d+)(?:&|$)/)	{ print_payment_form($1,$2);			}
elsif($qs =~ /(?:^|&)action=confirmpayment(?:&|$)/)			{ print_payment_confirmation_page();		}

elsif($qs =~ /(?:^|&)action=editmainmenu(?:&|$)/)			{ edit_main_menu();				}

elsif($qs =~ /(?:^|&)(?:protectedpage|ppge)=(.+)(?:&|$)/)		{ display_protected_page($1);			}

elsif($qs =~ /do_email_test/ && $PREF{enable_email_test} =~ /yes/i)	{ do_email_test();				}

elsif($qs =~ /^webconfig$/ || $qs =~ /action=webconfig/)		{ do_web_config();				}

elsif($qs =~ /(?:^|&)action=showipndata(?:&|$)/)			{ show_ipn_data();				}
elsif(!$qs && $ENV{REQUEST_METHOD} =~ /post/i)				{ do_paypal_ipn();				}

else
{
	if($PREF{admin_is_logged_in}   &&   $PREF{always_redirect_admins_to})
	{
		$PREF{always_redirect_admins_to} =~ s/%%username%%/$PREF{logged_in_username}/g;
		enc_redirect($PREF{always_redirect_admins_to});
	}
	elsif($PREF{member_is_logged_in}   &&   !$PREF{admin_is_logged_in}   &&   $PREF{always_redirect_members_to}) # need the !admin because admins are members too.
	{
		$PREF{always_redirect_members_to} =~ s/%%username%%/$PREF{logged_in_username}/g;
		enc_redirect($PREF{always_redirect_members_to});
	}
	else
	{
		if($PREF{member_is_logged_in} && $qs !~ /forceloginform=true/)
		{
			print_main_menu();
		}
		else
		{
			prompt_for_login();
		}
	}
}
